commit 157561c7fec70ac439ac879ec8b9a56d74e557fc
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 17:19:48 2016 -0700

    Changed return value from 'int' to 'bool'

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 757a56c..717ee40 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -714,12 +714,12 @@ struct lxc_container {
 	/*!
 	 *
 	 */
-	int (*export_container)(struct lxc_container *c, const char *detailsfile);
+	bool (*export_container)(struct lxc_container *c, const char *detailsfile);
 
 	/*!
 	 *
 	 */
-	int (*export_snapshot)(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
+	bool (*export_snapshot)(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
 
 	/*!
 	 * \brief Determine if the caller may control the container.

commit b2c9f2dc8c9b0165975cfa66690a153881847b21
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 15:50:50 2016 -0700

    Fixed memory leak

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 1d3110e..757a56c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -721,8 +721,6 @@ struct lxc_container {
 	 */
 	int (*export_snapshot)(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
 
-	int (*test)(struct lxc_container *c);
-
 	/*!
 	 * \brief Determine if the caller may control the container.
 	 *

commit 09aa43c0c14c691b1e9ac165a86431e28eca0cf0
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 01:34:46 2016 -0700

    API test, didn't work out

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index ecc66e2..1d3110e 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -712,6 +712,18 @@ struct lxc_container {
 	bool (*snapshot_destroy)(struct lxc_container *c, const char *snapname);
 
 	/*!
+	 *
+	 */
+	int (*export_container)(struct lxc_container *c, const char *detailsfile);
+
+	/*!
+	 *
+	 */
+	int (*export_snapshot)(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
+
+	int (*test)(struct lxc_container *c);
+
+	/*!
 	 * \brief Determine if the caller may control the container.
 	 *
 	 * \param c Container.

commit c6c37c20326c7fcd8a2f072263188cc84c403955
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed May 11 07:51:11 2016 -0600

    c/r: add an option to use faster inotify support in CRIU
    
    The idea here is that criu can use open_by_handle on a configuration which
    will preserve inodes on moves across hosts, but shouldn't do that on
    configurations which won't preserve inodes. Before, we forced it to always
    be slow, but we don't have to do this.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 0e014bc..ecc66e2 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -884,6 +884,13 @@ struct migrate_opts {
 	char *predump_dir; /* relative to directory above */
 	char *pageserver_address; /* where should memory pages be send? */
 	char *pageserver_port;
+
+	/* This flag indicates whether or not the container's rootfs will have
+	 * the same inodes on checkpoint and restore. In the case of e.g. zfs
+	 * send or btrfs send, or an LVM snapshot, this will be true, but it
+	 * won't if e.g. you rsync the filesystems between two machines.
+	 */
+	bool preserves_inodes;
 };
 
 /*!

commit 74eb576cef2f775ed77d2a7909057b1a09540065
Author: Niklas Eiling <niklas.eiling@rwth-aachen.de>
Date:   Wed Mar 30 15:39:45 2016 +0200

    fixed indentation and comments
    
    Signed-off-by: Niklas Eiling <niklas.eiling@rwth-aachen.de>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index a1df67a..0e014bc 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -882,8 +882,8 @@ struct migrate_opts {
 
 	bool stop; /* stop the container after dump? */
 	char *predump_dir; /* relative to directory above */
-    char *pageserver_address; /* where should memory pages be send? */
-    char *pageserver_port;
+	char *pageserver_address; /* where should memory pages be send? */
+	char *pageserver_port;
 };
 
 /*!

commit 4c0c0319a5baa86a4db8e80bbe149ee5bd8c9816
Author: Niklas Eiling <niklas.eiling@rwth-aachen.de>
Date:   Wed Mar 30 12:32:02 2016 +0200

    c/r: support for the criu pageserver
    this enables lxc to perform "disk-less migrations" where memory pages are sent directly to the destination machine instead of being written to the sources filesystem first.
    For this, the migrate_opts struct has been added the strings "pageserver_address" and "pageserver_port" so that criu can be told where to look for a pageserver.
    
    Signed-off-by: Niklas Eiling <niklas.eiling@rwth-aachen.de>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 0755901..a1df67a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -882,6 +882,8 @@ struct migrate_opts {
 
 	bool stop; /* stop the container after dump? */
 	char *predump_dir; /* relative to directory above */
+    char *pageserver_address; /* where should memory pages be send? */
+    char *pageserver_port;
 };
 
 /*!

commit 289cdc7375fca2b445ae576ea82035e46873c746
Author: Wolfgang Bumiller <w.bumiller@proxmox.com>
Date:   Thu Jan 14 14:30:20 2016 +0100

    cleanup: lxc_container::want_* comment descriptions
    
    They change a value and return true on success rather than
    fetching the value as the comments previously suggested.
    
    Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 6d155a1..0755901 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -222,25 +222,24 @@ struct lxc_container {
 	bool (*stop)(struct lxc_container *c);
 
 	/*!
-	 * \brief Determine if the container wants to run disconnected
+	 * \brief Change whether the container wants to run disconnected
 	 * from the terminal.
 	 *
 	 * \param c Container.
 	 * \param state Value for the daemonize bit (0 or 1).
 	 *
-	 * \return \c true if container wants to be daemonised, else \c false.
+	 * \return \c true on success, else \c false.
 	 */
 	bool (*want_daemonize)(struct lxc_container *c, bool state);
 
 	/*!
-	 * \brief Determine whether container wishes all file descriptors
+	 * \brief Change whether the container wishes all file descriptors
 	 *  to be closed on startup.
 	 *
 	 * \param c Container.
 	 * \param state Value for the close_all_fds bit (0 or 1).
 	 *
-	 * \return \c true if container wants all file descriptors closed,
-	 *  else \c false.
+	 * \return \c true on success, else \c false.
 	 */
 	bool (*want_close_all_fds)(struct lxc_container *c, bool state);
 

commit 7ed52ec63cb0cfb11ac598d7ecb9abf53b877da8
Author: Laurent Barbe <laurent@ksperis.com>
Date:   Sun Dec 13 22:30:30 2015 +0100

    Fix API break on bdev_specs
    
    Signed-off-by: Laurent Barbe <laurent@ksperis.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 134477c..6d155a1 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -857,11 +857,11 @@ struct bdev_specs {
 		char *lv; /*!< LVM Logical Volume name */
 		char *thinpool; /*!< LVM thin pool to use, if any */
 	} lvm;
+	char *dir; /*!< Directory path */
 	struct {
 		char *rbdname; /*!< RBD image name */
 		char *rbdpool; /*!< Ceph pool name */
 	} rbd;
-	char *dir; /*!< Directory path */
 };
 
 /*!

commit 7da812df93d392d06630d2f2d7e7c9eec3693149
Author: Laurent Barbe <laurent@ksperis.com>
Date:   Fri Oct 2 12:45:14 2015 +0200

    Add Ceph RBD backingstore
    
    With lxc-create, this will create, map and mount a Rados blockdevice.
    A valid ceph.conf and ceph.client.admin.keyring is needed in /etc/ceph/
    RBD mapping is not manage on reboot.
    
    Signed-off-by: Laurent Barbe <laurent@ksperis.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index e909d81..134477c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -857,6 +857,10 @@ struct bdev_specs {
 		char *lv; /*!< LVM Logical Volume name */
 		char *thinpool; /*!< LVM thin pool to use, if any */
 	} lvm;
+	struct {
+		char *rbdname; /*!< RBD image name */
+		char *rbdpool; /*!< Ceph pool name */
+	} rbd;
 	char *dir; /*!< Directory path */
 };
 

commit aef3d51e61d8e65f31201e4a60eb4102ce5b4385
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Nov 30 15:14:22 2015 -0700

    c/r: add a new ->migrate API call
    
    This patch adds a new ->migrate API call with three commands:
    
    MIGRATE_DUMP: this is basically just ->checkpoint()
    MIGRATE_RESTORE: this is just ->restore()
    MIGRATE_PRE_DUMP: this can be used to invoke criu's pre-dump command on the
        container.
    
    A small addition to the (pre-)dump commands is the ability to specify a
    previous partial dump directory, so that one can use a pre-dump of a
    container.
    
    Finally, this new API call uses a structure to pass options so that it can
    be easily extended in the future (e.g. to CRIU's --leave-frozen option in
    the future, for potentially smarter failure handling on restore).
    
    v2: remember to flip the return code for legacy ->checkpoint and ->restore
        calls
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 38e1a8e..e909d81 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -49,6 +49,8 @@ struct lxc_snapshot;
 
 struct lxc_lock;
 
+struct migrate_opts;
+
 /*!
  * An LXC container.
  *
@@ -812,6 +814,16 @@ struct lxc_container {
 	bool (*snapshot_destroy_all)(struct lxc_container *c);
 
 	/* Post LXC-1.1 additions */
+	/*!
+	 * \brief An API call to perform various migration operations
+	 *
+	 * \param cmd One of the MIGRATE_ contstants.
+	 * \param opts A migrate_opts struct filled with relevant options.
+	 * \param size The size of the migrate_opts struct, i.e. sizeof(struct migrate_opts).
+	 *
+	 * \return \c 0 on success, nonzero on failure.
+	 */
+	int (*migrate)(struct lxc_container *c, unsigned int cmd, struct migrate_opts *opts, unsigned int size);
 };
 
 /*!
@@ -849,6 +861,27 @@ struct bdev_specs {
 };
 
 /*!
+ * \brief Commands for the migrate API call.
+ */
+enum {
+	MIGRATE_PRE_DUMP,
+	MIGRATE_DUMP,
+	MIGRATE_RESTORE,
+};
+
+/*!
+ * \brief Options for the migrate API call.
+ */
+struct migrate_opts {
+	/* new members should be added at the end */
+	char *directory;
+	bool verbose;
+
+	bool stop; /* stop the container after dump? */
+	char *predump_dir; /* relative to directory above */
+};
+
+/*!
  * \brief Create a new container.
  *
  * \param name Name to use for container.

commit e2ae7f6d8ccc3d7936f922b22a3436f944c69f68
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Nov 17 23:05:37 2015 -0600

    lxc_container struct: add comment about moving member fns
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index d8b20ec..38e1a8e 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -51,6 +51,10 @@ struct lxc_lock;
 
 /*!
  * An LXC container.
+ *
+ * Note that changing the order of struct members is an API change, as callers
+ * will end up having the wrong offset when calling a function.  So when making
+ * changes, whenever possible stick to simply appending new members.
  */
 struct lxc_container {
 	// private fields

commit d028235de9ec7664e1c2c904c541a447a768997a
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Sep 21 16:25:47 2015 -0400

    Fix indentation
    
    I've noticed that a bunch of the code we've included over the past few
    weeks has been using 8-spaces rather than tabs, making it all very hard
    to read depending on your tabstop setting.
    
    This commit attempts to revert all of that back to proper tabs and fix a
    few more cases I've noticed here and there.
    
    No functional changes are included in this commit.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index d60e19a..d8b20ec 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -831,17 +831,17 @@ struct lxc_snapshot {
  * \brief Specifications for how to create a new backing store
  */
 struct bdev_specs {
-    char *fstype; /*!< Filesystem type */
-    uint64_t fssize;  /*!< Filesystem size in bytes */
-    struct {
-        char *zfsroot; /*!< ZFS root path */
-    } zfs;
-    struct {
-        char *vg; /*!< LVM Volume Group name */
-        char *lv; /*!< LVM Logical Volume name */
-        char *thinpool; /*!< LVM thin pool to use, if any */
-    } lvm;
-    char *dir; /*!< Directory path */
+	char *fstype; /*!< Filesystem type */
+	uint64_t fssize;  /*!< Filesystem size in bytes */
+	struct {
+		char *zfsroot; /*!< ZFS root path */
+	} zfs;
+	struct {
+		char *vg; /*!< LVM Volume Group name */
+		char *lv; /*!< LVM Logical Volume name */
+		char *thinpool; /*!< LVM thin pool to use, if any */
+	} lvm;
+	char *dir; /*!< Directory path */
 };
 
 /*!

commit d24095e46ad68ae5a770cbd23ac29dce22da3fd8
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Fri May 29 11:39:25 2015 -0400

    Fix ABI compatibility
    
    Until we bump the SONAME to liblxc2, only symbol additions and struct
    member additions are allowed.
    
    Adding struct members in the middle of the struct breaks backward
    compatibility.
    
    This commit makes it clear when struct members were added and moves a
    few members that were added in the middle of the 1.0 struct to the end
    of it.
    
    Note that unfortunately that means we're breaking backward compatibility
    between LXC 1.1.0 and the state after this commit, given 1.1 is
    reasonably new, this is the least damaging way of fixing the problem.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index a136a43..d60e19a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -286,17 +286,6 @@ struct lxc_container {
 	bool (*destroy)(struct lxc_container *c);
 
 	/*!
-	 * \brief Delete the container and all its snapshots.
-	 *
-	 * \param c Container.
-	 *
-	 * \return \c true on success, else \c false.
-	 *
-	 * \note Container must be stopped.
-	 */
-	bool (*destroy_with_snapshots)(struct lxc_container *c);
-
-	/*!
 	 * \brief Save configuaration to a file.
 	 *
 	 * \param c Container.
@@ -718,15 +707,6 @@ struct lxc_container {
 	bool (*snapshot_destroy)(struct lxc_container *c, const char *snapname);
 
 	/*!
-	 * \brief Destroy all the container's snapshot.
-	 *
-	 * \param c Container.
-	 *
-	 * \return \c true on success, else \c false.
-	 */
-	bool (*snapshot_destroy_all)(struct lxc_container *c);
-
-	/*!
 	 * \brief Determine if the caller may control the container.
 	 *
 	 * \param c Container.
@@ -761,6 +741,8 @@ struct lxc_container {
 	 */
 	bool (*remove_device_node)(struct lxc_container *c, const char *src_path, const char *dest_path);
 
+	/* Post LXC-1.0 additions */
+
 	/*!
 	 * \brief Add specified netdev to the container.
 	 *
@@ -804,6 +786,28 @@ struct lxc_container {
 	 *
 	 */
 	bool (*restore)(struct lxc_container *c, char *directory, bool verbose);
+
+	/*!
+	 * \brief Delete the container and all its snapshots.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Container must be stopped.
+	 */
+	bool (*destroy_with_snapshots)(struct lxc_container *c);
+
+	/*!
+	 * \brief Destroy all the container's snapshot.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*snapshot_destroy_all)(struct lxc_container *c);
+
+	/* Post LXC-1.1 additions */
 };
 
 /*!

commit ec64264d78d4ed608553842ce9e1f07eeab2a032
Author: Veres Lajos <vlajos@gmail.com>
Date:   Thu Dec 4 21:57:38 2014 +0000

    typofixes - https://github.com/vlajos/misspell_fixer
    
    Signed-off-by: Veres Lajos <vlajos@gmail.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index f9feeba..a136a43 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -580,7 +580,7 @@ struct lxc_container {
 	 * \param c Container.
 	 * \param[in,out] ttynum Terminal number to attempt to allocate,
 	 *  or \c -1 to allocate the first available tty.
-	 * \param[out] masterfd File descriptor refering to the master side of the pty.
+	 * \param[out] masterfd File descriptor referring to the master side of the pty.
 	 *
 	 * \return tty file descriptor number on success, or \c -1 on
 	 *  failure.

commit 51d0854cd6360b953c37e3bf1b9a85ce031b2075
Author: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
Date:   Tue Sep 16 16:54:42 2014 +0800

    utils: move useful helper functions from lxccontainer to utils.
    
    Function of enter_to_ns() is useful but currently is static for
    lxccontainer.c.
    
    This patch split it into two parts named as switch_to_newuser()
    and switch_to_newnet() into utils.c.
    
    Signed-off-by: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 6344f3d..f9feeba 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -762,6 +762,25 @@ struct lxc_container {
 	bool (*remove_device_node)(struct lxc_container *c, const char *src_path, const char *dest_path);
 
 	/*!
+	 * \brief Add specified netdev to the container.
+	 *
+	 * \param c Container.
+	 * \param dev name of net device.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*attach_interface)(struct lxc_container *c, const char *dev, const char *dst_dev);
+
+	/*!
+	 * \brief Remove specified netdev from the container.
+	 *
+	 * \param c Container.
+	 * \param dev name of net device.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*detach_interface)(struct lxc_container *c, const char *dev, const char *dst_dev);
+	/*!
 	 * \brief Checkpoint a container.
 	 *
 	 * \param c Container.

commit 735f2c6e504a541cbb2592a3f94858bf337a24ff
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Aug 26 09:09:36 2014 -0500

    Add support for checkpoint and restore via CRIU
    
    This patch adds support for checkpointing and restoring containers via CRIU.
    It adds two api calls, ->checkpoint and ->restore, which are wrappers around
    the CRIU CLI. CRIU has an RPC API, but reasons for preferring exec() are
    discussed in [1].
    
    To checkpoint, users specify a directory to dump the container metadata (CRIU
    dump files, plus some additional information about veth pairs and which
    bridges they are attached to) into this directory. On restore, this
    information is read out of the directory, a CRIU command line is constructed,
    and CRIU is exec()d. CRIU uses the lxc-restore-net callback (which in turn
    inspects the image directory with the NIC data) to properly restore the
    network.
    
    This will only work with the current git master of CRIU; anything as of
    a152c843 should work. There is a known bug where containers which have been
    restored cannot be checkpointed [2].
    
    [1]: http://lists.openvz.org/pipermail/criu/2014-July/015117.html
    [2]: http://lists.openvz.org/pipermail/criu/2014-August/015876.html
    
    v2: fixed some problems with the s/int/bool return code form api function
    v3: added a testcase, fixed up the man page synopsis
    v4: fix a small typo in lxc-test-checkpoint-restore
    v5: remove a reference to the old CRIU_PATH, and a bad error about the same
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5085c43..6344f3d 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -760,6 +760,31 @@ struct lxc_container {
 	 * \return \c true on success, else \c false.
 	 */
 	bool (*remove_device_node)(struct lxc_container *c, const char *src_path, const char *dest_path);
+
+	/*!
+	 * \brief Checkpoint a container.
+	 *
+	 * \param c Container.
+	 * \param directory The directory to dump the container to.
+	 * \param stop Whether or not to stop the container after checkpointing.
+	 * \param verbose Enable criu's verbose logs.
+	 *
+	 * \return \c true on success, else \c false.
+	 * present at compile time).
+	 */
+	bool (*checkpoint)(struct lxc_container *c, char *directory, bool stop, bool verbose);
+
+	/*!
+	 * \brief Restore a container from a checkpoint.
+	 *
+	 * \param c Container.
+	 * \param directory The directory to restore the container from.
+	 * \param verbose Enable criu's verbose logs.
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 */
+	bool (*restore)(struct lxc_container *c, char *directory, bool verbose);
 };
 
 /*!

commit 6b0d553864a16462850d87d4d2e9056ea136ebad
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 1 23:34:16 2014 +0000

    unexpanded config file: turn into a string
    
    Originally, we only kept a struct lxc_conf representing the current
    container configuration.  This was insufficient because lxc.include's
    were expanded, so a clone or a snapshot would contain the expanded
    include file contents, rather than the original "lxc.include".  If
    the host's include files are updated, clones and snapshots would not
    inherit those updates.
    
    To address this, we originally added a lxc_unexp_conf, which mirrored
    the lxc_conf, except that lxc.include was not expanded.
    
    This has its own cshortcomings, however,  In particular, if a lxc.include
    has a lxc.cgroup setting, and you use the api to say:
    
    c.clear_config_item("lxc.cgroup")
    
    this is not representable in the lxc_unexp_conf.  (The original problem,
    which was pointed out to me by stgraber, was slightly different, but
    unlike this problem it was not unsolvable).
    
    This patch changes the unexpanded configuration  to be a textual
    representation of the configuration.  This allows us *order* the
    configuration commands, which is what was not possible using the
    struct lxc_conf *lxc_unexp_conf.
    
    The write_config() now becomes a simple fwrite.  However, lxc_clone
    is slightly complicated in parts, the worst of which is the need to
    rewrite the network configuration if we are changing the macaddrs.
    
    With this patch, lxc-clone and clear_config_item do the right thing.
    lxc-test-saveconfig and lxc-test-clonetest both pass.
    
    There is room for improvement - multiple calls to
    
    c.append_config_item("lxc.network.link", "lxcbr0")
    
    will result in multiple such lines in the configuration file.  In that
    particular case it is harmless.  There may be cases where it is not.
    
    Overall, this should be a huge improvement in terms of correctness.
    
    Changelog: Aug 1: updated to current lxc git head.  All lxc-test* and
       python api test passed.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5e74c2e..5085c43 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -99,16 +99,6 @@ struct lxc_container {
 	 */
 	struct lxc_conf *lxc_conf;
 
-	/*!
-	 * \private
-	 * The non-common, unexpanded configuration.  This includes the
-	 * list of lxc.include files, and does not contain any
-	 * individual configuration items from the include files.
-	 * Anything coming from the container's own configuration file
-	 * or from lxcapi_set_config_item() does get added here.
-	 */
-	struct lxc_conf *lxc_unexp_conf;
-
 	// public fields
 	/*! Human-readable string representing last error */
 	char *error_string;

commit 18aa217bb187b551206fe66075229ba382a1dbe4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 27 16:24:06 2014 -0500

    snapshots: move snapshot directory
    
    Originally we kept snapshots under /var/lib/lxcsnaps.  If a
    separate btrfs is mounted at /var/lib/lxc, then we can't
    make btrfs snapshots under /var/lib/lxcsnaps.
    
    This patch moves the default directory to /var/lib/lxc/c/snaps.
    If /var/lib/lxcsnaps already exists, then we continue to use that.
    
    add c->destroy_with_snapshots() and c->snapshot_destroy_all()
    API methods.  c->snashot_destroy_all() can be triggered from
    lxc-snapshot using '-d ALL'.  There is no command to call
    c->destroy_with_snapshots(c) as of yet.
    
    lxclock: use ".$lxcname" for container lock files
    that way we can use /run/lock/lxc/$lxcpath/$lxcname/snaps as a
    directory when locking snapshots without having to worry about
    /run/lock//lxc/$lxcpath/$lxcname being a file.
    
    destroy: split off a container_destroy
    container_destroy() doesn't check for snapshots, so snapshot_rename can
    use it.  api_destroy() now does check for snapshots (previously it only
    checked for fs - i.e. overlayfs/aufs - snapshots).
    
    Add destroy to the manpage, as it was previously undocumented.
    
    Update snapshot testcase accordingly.
    
    [ rebased in the face of commits 840f05df and 7e36f87e. ]
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index d1de399..5e74c2e 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -296,6 +296,17 @@ struct lxc_container {
 	bool (*destroy)(struct lxc_container *c);
 
 	/*!
+	 * \brief Delete the container and all its snapshots.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Container must be stopped.
+	 */
+	bool (*destroy_with_snapshots)(struct lxc_container *c);
+
+	/*!
 	 * \brief Save configuaration to a file.
 	 *
 	 * \param c Container.
@@ -659,7 +670,7 @@ struct lxc_container {
 	 * \brief Create a container snapshot.
 	 *
 	 * Assuming default paths, snapshots will be created as
-	 * \c /var/lib/lxcsnaps/\<c\>/snap\<n\>
+	 * \c /var/lib/lxc/\<c\>/snaps/snap\<n\>
 	 * where \c \<c\> represents the container name and \c \<n\>
 	 * represents the zero-based snapshot number.
 	 *
@@ -701,7 +712,7 @@ struct lxc_container {
 	 *  fail if the  snapshot is overlay-based, since the snapshots
 	 *  will pin the original container.
 	 * \note As an example, if the container exists as \c /var/lib/lxc/c1, snapname might be \c 'snap0'
-	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,
+	 *  (representing \c /var/lib/lxc/c1/snaps/snap0). If \p newname is \p c2,
 	 *  then \c snap0 will be copied to \c /var/lib/lxc/c2.
 	 */
 	bool (*snapshot_restore)(struct lxc_container *c, const char *snapname, const char *newname);
@@ -717,6 +728,15 @@ struct lxc_container {
 	bool (*snapshot_destroy)(struct lxc_container *c, const char *snapname);
 
 	/*!
+	 * \brief Destroy all the container's snapshot.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*snapshot_destroy_all)(struct lxc_container *c);
+
+	/*!
 	 * \brief Determine if the caller may control the container.
 	 *
 	 * \param c Container.

commit f979ac15923809df97d9b7b16a1411d20f386777
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Jun 12 14:24:38 2014 +0000

    Add a unexpanded lxc_conf
    
    Currently when a container's configuration file has lxc.includes,
    any future write_config() will expand the lxc.includes.  This
    affects container clones (and snapshots) as well as users of the
    API who make an update and then c.save_config().
    
    To fix this, separately track the expanded and unexpanded lxc_conf.  The
    unexpanded conf does not contain values read from lxc.includes.  The
    expanded conf does.  Lxc functions mainly need the expanded conf to
    figure out how to configure the container.  The unexpanded conf is used
    at write_config().
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 1d0628a..d1de399 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -99,6 +99,16 @@ struct lxc_container {
 	 */
 	struct lxc_conf *lxc_conf;
 
+	/*!
+	 * \private
+	 * The non-common, unexpanded configuration.  This includes the
+	 * list of lxc.include files, and does not contain any
+	 * individual configuration items from the include files.
+	 * Anything coming from the container's own configuration file
+	 * or from lxcapi_set_config_item() does get added here.
+	 */
+	struct lxc_conf *lxc_unexp_conf;
+
 	// public fields
 	/*! Human-readable string representing last error */
 	char *error_string;

commit f49ad558511e3c0d68ed9d6cffcc3741748223a3
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Tue May 20 20:50:51 2014 -0400

    move bdev_specs struct into lxccontainer.h to allow API users to use it
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index ba15ab7..1d0628a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -758,6 +758,24 @@ struct lxc_snapshot {
 	void (*free)(struct lxc_snapshot *s);
 };
 
+
+/*!
+ * \brief Specifications for how to create a new backing store
+ */
+struct bdev_specs {
+    char *fstype; /*!< Filesystem type */
+    uint64_t fssize;  /*!< Filesystem size in bytes */
+    struct {
+        char *zfsroot; /*!< ZFS root path */
+    } zfs;
+    struct {
+        char *vg; /*!< LVM Volume Group name */
+        char *lv; /*!< LVM Logical Volume name */
+        char *thinpool; /*!< LVM thin pool to use, if any */
+    } lvm;
+    char *dir; /*!< Directory path */
+};
+
 /*!
  * \brief Create a new container.
  *

commit f79b86a34452a004e4014893da058cd049db94cc
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Apr 28 17:33:36 2014 -0500

    Revert "snapshots: move snapshot directory"
    
    This reverts commit 276a086264a0fc1703128578d38c0574127a1c2f.
    
    It breaks lxc-test-snapshot, and perhaps we should go with
    stgraber's suggestion of using $lxcpath/$lxcname/snaps/

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 946a662..ba15ab7 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -649,7 +649,7 @@ struct lxc_container {
 	 * \brief Create a container snapshot.
 	 *
 	 * Assuming default paths, snapshots will be created as
-	 * \c /var/lib/lxc/lxcsnaps/\<c\>/snap\<n\>
+	 * \c /var/lib/lxcsnaps/\<c\>/snap\<n\>
 	 * where \c \<c\> represents the container name and \c \<n\>
 	 * represents the zero-based snapshot number.
 	 *
@@ -691,7 +691,7 @@ struct lxc_container {
 	 *  fail if the  snapshot is overlay-based, since the snapshots
 	 *  will pin the original container.
 	 * \note As an example, if the container exists as \c /var/lib/lxc/c1, snapname might be \c 'snap0'
-	 *  (representing \c /var/lib/lxc/lxcsnaps/c1/snap0). If \p newname is \p c2,
+	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,
 	 *  then \c snap0 will be copied to \c /var/lib/lxc/c2.
 	 */
 	bool (*snapshot_restore)(struct lxc_container *c, const char *snapname, const char *newname);

commit 276a086264a0fc1703128578d38c0574127a1c2f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Apr 16 14:04:45 2014 -0500

    snapshots: move snapshot directory
    
    Originally we kept snapshots under /var/lib/lxcsnaps.  If a
    separate btrfs is mounted at /var/lib/lxc, then we can't
    make btrfs snapshots under /var/lib/lxcsnaps.
    
    This patch moves the default directory to /var/lib/lxc/lxcsnaps.
    If /var/lib/lxcsnaps already exists, then use that.  Don't allow
    any container to be used with the name 'lxcsnaps'.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index ba15ab7..946a662 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -649,7 +649,7 @@ struct lxc_container {
 	 * \brief Create a container snapshot.
 	 *
 	 * Assuming default paths, snapshots will be created as
-	 * \c /var/lib/lxcsnaps/\<c\>/snap\<n\>
+	 * \c /var/lib/lxc/lxcsnaps/\<c\>/snap\<n\>
 	 * where \c \<c\> represents the container name and \c \<n\>
 	 * represents the zero-based snapshot number.
 	 *
@@ -691,7 +691,7 @@ struct lxc_container {
 	 *  fail if the  snapshot is overlay-based, since the snapshots
 	 *  will pin the original container.
 	 * \note As an example, if the container exists as \c /var/lib/lxc/c1, snapname might be \c 'snap0'
-	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,
+	 *  (representing \c /var/lib/lxc/lxcsnaps/c1/snap0). If \p newname is \p c2,
 	 *  then \c snap0 will be copied to \c /var/lib/lxc/c2.
 	 */
 	bool (*snapshot_restore)(struct lxc_container *c, const char *snapname, const char *newname);

commit 36eaa694151aff72a74987034d5f0eeb4261951c
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Fri Mar 7 16:49:25 2014 -0500

    fix fd leak in test-concurrent
    
    Opening a debug log for every thread at every iteration of test-concurrent
    causes it to quickly run out of fd's because this fd is leaked. Fix this
    by adding a new api: lxc_log_close().
    
    As Caglar noted, the log handling is in general a bit "interesting" because
    a logfile can be opened through the per-container api
    c->set_config_item("lxc.logfile") but lxc_log_fd is now per-thread data. It
    just so happens in test-concurrent that there is a 1:1 mapping of threads
    to logfiles.
    
    Split out getting debug logs from quiet since I think they are useful
    separately. If debug is specified, get a log of any mode, not just during
    start.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index b9873eb..ba15ab7 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -865,6 +865,11 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
  */
 int list_all_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
+/*!
+ * \brief Close log file.
+ */
+void lxc_log_close(void);
+
 #ifdef  __cplusplus
 }
 #endif

commit 1f92162dc0432b6f7f8156d22348f22934cbea3f
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Wed Feb 12 14:01:02 2014 -0500

    bdev: Add aufs support
    
    This is pretty much copy/paste from overlayfs.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 92c76b4..b9873eb 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -688,7 +688,7 @@ struct lxc_container {
 	 * \return \c true on success, else \c false.
 	 * \warning If \p newname is the same as the current container
 	 *  name, the container will be destroyed. However, this will
-	 *  fail if the  snapshot is overlayfs-based, since the snapshots
+	 *  fail if the  snapshot is overlay-based, since the snapshots
 	 *  will pin the original container.
 	 * \note As an example, if the container exists as \c /var/lib/lxc/c1, snapname might be \c 'snap0'
 	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,

commit 0464b881e68ef5f50bd7bb9633b70e2e89be039b
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Fri Jan 31 13:56:55 2014 +0000

    shutdown: Rework API and lxc-stop
    
    With this change, shutdown() will no longer call stop() after the
    timeout, instead it'll just return false and it's up to the caller to
    then call stop() if appropriate.
    
    This also updates the bindings, tests and other scripts.
    
    lxc-stop is then updated to do proper option checking and use shutdown,
    stop or reboot as appropriate.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5f5d9b2..92c76b4 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -362,12 +362,10 @@ struct lxc_container {
 	 * SIGPWR.
 	 *
 	 * \param c Container.
-	 * \param timeout Seconds to wait before forcing a hard stop
-	 *  (value must be >0).
+	 * \param timeout Seconds to wait before returning false.
+	 *  (-1 to wait forever, 0 to avoid waiting).
 	 *
-	 * \return \c true if configuration was loaded successfully, else \c false.
-	 *
-	 * \note A \p timeout of \c 0 means do not wait.
+	 * \return \c true if the container was shutdown successfully, else \c false.
 	 */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
 

commit 8ac18377749fee21a29158afd5b0746d6c6771b8
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Mon Jan 27 17:57:37 2014 -0500

    export lxc_cmd_get_config_item via API and use in lxc-info
    
    This allows external users to query network related config items
    from the running containers.
    
    changes since v1:
    - function name change
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 84caa31..5f5d9b2 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -410,6 +410,19 @@ struct lxc_container {
 	 */
 	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
 
+
+	/*!
+	 * \brief Retrieve the value of a config item from running container.
+	 *
+	 * \param c Container.
+	 * \param key Name of option to get.
+	 *
+	 * \return the item or NULL on error.
+	 *
+	 * \note Returned string must be freed by the caller.
+	 */
+	char* (*get_running_config_item)(struct lxc_container *c, const char *key);
+
 	/*!
 	 * \brief Retrieve a list of config item keys given a key
 	 * prefix.

commit 72cf75fa33b97104c5e9905aab1be8d335119e7b
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Wed Jan 22 12:11:37 2014 +0800

    lxc-start: store PID file to lxc_container
    
    So we can remove PID file untill lxc_container_free.
    
    This also fix bug: https://github.com/lxc/lxc/issues/89
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index f3c7d72..84caa31 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -68,6 +68,12 @@ struct lxc_container {
 
 	/*!
 	 * \private
+	 * File to store pid.
+	 */
+	char *pidfile;
+
+	/*!
+	 * \private
 	 * Container semaphore lock.
 	 */
 	struct lxc_lock *slock;

commit dbfa71289dd3b2196cb63f399505bc62bcaf5f4e
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Jan 20 22:01:08 2014 -0500

    Add missing doxygen tag
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 921e47d..f3c7d72 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -786,7 +786,7 @@ int lxc_container_put(struct lxc_container *c);
  */
 int lxc_get_wait_states(const char **states);
 
-/*
+/*!
  * \brief Get the value for a global config key
  *
  * \param key The name of the config key

commit 593e84786e2b4709059989bee489deab5c923779
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Thu Jan 9 17:31:52 2014 -0500

    Re-organize API for global lxc.conf config
    
    Instead of having one function for each possible key in lxc.conf which
    doesn't really scale and requires an API update for every new key,
    switch to a generic lxc_get_global_config_item() function which takes a
    key name as argument.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index a62411b..921e47d 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -786,45 +786,14 @@ int lxc_container_put(struct lxc_container *c);
  */
 int lxc_get_wait_states(const char **states);
 
-/*!
- * \brief Determine path to default configuration file.
- *
- * \return Static string representing full path to default configuration
- *  file.
- *
- * \note Returned string must not be freed.
- */
-const char *lxc_get_default_config_path(void);
-
-/*!
- * \brief Determine default LVM volume group.
- *
- * \return Static string representing default volume group,
- *  or \c NULL on error.
- *
- * \note Returned string must not be freed.
- */
-const char *lxc_get_default_lvm_vg(void);
-
-/*!
- * \brief Determine default LVM thin pool.
- *
- * \return Static string representing default lvm thin pool,
- *  or \c NULL on error.
- *
- * \note Returned string must not be freed.
- */
-const char *lxc_get_default_lvm_thin_pool(void);
-
-/*!
- * \brief Determine default ZFS root.
+/*
+ * \brief Get the value for a global config key
  *
- * \return Static string representing default ZFS root,
- *  or \c NULL on error.
+ * \param key The name of the config key
  *
- * \note Returned string must not be freed.
+ * \return String representing the current value for the key.
  */
-const char *lxc_get_default_zfs_root(void);
+const char *lxc_get_global_config_item(const char *key);
 
 /*!
  * \brief Determine version of LXC.

commit d659597e03725411c366c42dc02c64c0c35a167a
Author: Stephen Ayotte <stephen.ayotte@gmail.com>
Date:   Thu Jan 2 14:30:26 2014 -0500

    Support large bdevs on 32-bit; MB units by default.
    
    Change all instances of "unsigned long" where referring to a bdev size
    to uint64_t; this fixes some overflows on 32-bit machines, where
    "unsigned long" is uint32_t. Support all unit-sizes supported by LVM
    except 's' and 'e' [bkmgt]. Print a warning and use default bdev-size if
    invalid unit-size specified.
    
    Signed-off-by: Stephen Ayotte <stephen.ayotte@gmail.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index fe2dbc2..a62411b 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -26,6 +26,7 @@
 #include <semaphore.h>
 #include <stdbool.h>
 #include <stdlib.h>
+#include <stdint.h>
 
 #include <lxc/attach_options.h>
 
@@ -543,7 +544,7 @@ struct lxc_container {
 	 */
 	struct lxc_container *(*clone)(struct lxc_container *c, const char *newname,
 			const char *lxcpath, int flags, const char *bdevtype,
-			const char *bdevdata, unsigned long newsize, char **hookargs);
+			const char *bdevdata, uint64_t newsize, char **hookargs);
 
 	/*!
 	 * \brief Allocate a console tty for the container.

commit 0a83cbbb7592ccb4901a790e7677884d728df6f7
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 1 13:43:35 2014 -0600

    snapshot: enforce keeping same backing store type (v2)
    
    Stéphane noticed that lxc-snapshot of a dir-backed container
    created an overlayfs container.  The expectation is that the
    user can continue to modify the original container and later make
    a new snapshot, but this doesn't work with the existing behavior -
    the overlayfs clone will end up with the modified contents.
    
    So add a 'LXC_CLONE_KEEPBDEVTYPE' flag, which c->snapshot()
    passes to c->clone().
    
    Also add a LXC_CLONE_MAYBE_SNAPSHOT.  If this is set and a
    backing store does not support snapshotting, then proceed with
    a copy clone.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index f62ff8f..fe2dbc2 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -36,7 +36,9 @@ extern "C" {
 #define LXC_CLONE_KEEPNAME        (1 << 0) /*!< Do not edit the rootfs to change the hostname */
 #define LXC_CLONE_KEEPMACADDR     (1 << 1) /*!< Do not change the MAC address on network interfaces */
 #define LXC_CLONE_SNAPSHOT        (1 << 2) /*!< Snapshot the original filesystem(s) */
-#define LXC_CLONE_MAXFLAGS        (1 << 3) /*!< Number of \c LXC_CLONE_* flags */
+#define LXC_CLONE_KEEPBDEVTYPE    (1 << 3) /*!< Use the same bdev type */
+#define LXC_CLONE_MAYBE_SNAPSHOT  (1 << 4) /*!< Snapshot only if bdev supports it, else copy */
+#define LXC_CLONE_MAXFLAGS        (1 << 5) /*!< Number of \c LXC_CLONE_* flags */
 #define LXC_CREATE_QUIET          (1 << 0) /*!< Redirect \c stdin to \c /dev/zero and \c stdout and \c stderr to \c /dev/null */
 #define LXC_CREATE_MAXFLAGS       (1 << 1) /*!< Number of \c LXC_CREATE* flags */
 

commit f2363e38d07db2ad4796b5580b95e3665ed34a88
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Wed Dec 25 14:27:11 2013 -0500

    adjust include statements (v2)
    
    Use "#include <somefile.h>" style for external or exported headers only.
    
    changes since v1:
     - adjusted formatting as Stéphane suggested
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 7d1839e..f62ff8f 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -22,12 +22,13 @@
 
 #ifndef __LXC_CONTAINER_H
 #define __LXC_CONTAINER_H
-#include "attach_options.h"
 #include <malloc.h>
 #include <semaphore.h>
 #include <stdbool.h>
 #include <stdlib.h>
 
+#include <lxc/attach_options.h>
+
 #ifdef  __cplusplus
 extern "C" {
 #endif

commit 579e783eecaa194bbffd49d27e730a83e836705a
Author: Andrey Mazo <mazo@telum.ru>
Date:   Tue Dec 24 21:08:12 2013 +0400

    Allow use of public API from C++
    
    Signed-off-by: Andrey Mazo <mazo@telum.ru>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 797ad91..7d1839e 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -28,6 +28,10 @@
 #include <stdbool.h>
 #include <stdlib.h>
 
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
 #define LXC_CLONE_KEEPNAME        (1 << 0) /*!< Do not edit the rootfs to change the hostname */
 #define LXC_CLONE_KEEPMACADDR     (1 << 1) /*!< Do not change the MAC address on network interfaces */
 #define LXC_CLONE_SNAPSHOT        (1 << 2) /*!< Snapshot the original filesystem(s) */
@@ -871,4 +875,8 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
  */
 int list_all_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
+#ifdef  __cplusplus
+}
+#endif
+
 #endif

commit 619256b5ee8bf68bf670cd60b0723b94ce069121
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Sat Dec 21 14:48:41 2013 -0500

    remove LXC_CLONE_COPYHOOKS and make lxcapi_clone to copy hooks unconditionally (v3)
    
    changes since v1;
    	incorporated Serge's changes
    changes since v2;
    	added missing Signed-off-by
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index b7c5313..797ad91 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -29,10 +29,9 @@
 #include <stdlib.h>
 
 #define LXC_CLONE_KEEPNAME        (1 << 0) /*!< Do not edit the rootfs to change the hostname */
-#define LXC_CLONE_COPYHOOKS       (1 << 1) /*!< Copy all hooks into the container directory */
-#define LXC_CLONE_KEEPMACADDR     (1 << 2) /*!< Do not change the MAC address on network interfaces */
-#define LXC_CLONE_SNAPSHOT        (1 << 3) /*!< Snapshot the original filesystem(s) */
-#define LXC_CLONE_MAXFLAGS        (1 << 4) /*!< Number of \c LXC_CLONE_* flags */
+#define LXC_CLONE_KEEPMACADDR     (1 << 1) /*!< Do not change the MAC address on network interfaces */
+#define LXC_CLONE_SNAPSHOT        (1 << 2) /*!< Snapshot the original filesystem(s) */
+#define LXC_CLONE_MAXFLAGS        (1 << 3) /*!< Number of \c LXC_CLONE_* flags */
 #define LXC_CREATE_QUIET          (1 << 0) /*!< Redirect \c stdin to \c /dev/zero and \c stdout and \c stderr to \c /dev/null */
 #define LXC_CREATE_MAXFLAGS       (1 << 1) /*!< Number of \c LXC_CREATE* flags */
 
@@ -516,7 +515,6 @@ struct lxc_container {
 	 *  (XXX: should we use the default instead?)
 	 * \param flags Additional \c LXC_CLONE* flags to change the cloning behaviour:
 	 *  - \ref LXC_CLONE_KEEPNAME
-	 *  - \ref LXC_CLONE_COPYHOOKS
 	 *  - \ref LXC_CLONE_KEEPMACADDR
 	 *  - \ref LXC_CLONE_SNAPSHOT
 	 * \param bdevtype Optionally force the cloned bdevtype to a specified plugin.

commit 06e5650eaba7182a09bf73b0fa68100f6b43575f
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Sat Dec 14 00:41:25 2013 -0500

    introduce lxcapi_rename for renaming containers
    
    lxcapi_rename implemented as a convenience function as lately
    I find myself in a need to rename a container due to a
    typo in its name. I could have started over but didn't want
    to spend more time (to installing extra packages and changing
    their configuration) on it.
    
    c->clone() followed by c->destroy() did the trick for me and I
    though it could be helpful to the other people, so here it is.
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 3e1b492..b7c5313 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -326,6 +326,16 @@ struct lxc_container {
 			struct bdev_specs *specs, int flags, ...);
 
 	/*!
+	 * \brief Rename a container
+	 *
+	 * \param c Container.
+	 * \param newname New name to be used for the container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*rename)(struct lxc_container *c, const char *newname);
+
+	/*!
 	 * \brief Request the container reboot by sending it \c SIGINT.
 	 *
 	 * \param c Container.

commit f0ca27269a817ac3b396fc947e350670b31e5487
Author: James Hunt <james.hunt@ubuntu.com>
Date:   Tue Dec 10 10:29:59 2013 +0000

    Make public API string method parameters const where possible.
    
    Signed-off-by: James Hunt <james.hunt@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 4ad3b66..3e1b492 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -436,7 +436,7 @@ struct lxc_container {
 	 * \note The returned array is allocated, so the caller must free it.
 	 * \note The returned array is terminated with a \c NULL entry.
 	 */
-	char** (*get_ips)(struct lxc_container *c, char* interface, char* family, int scope);
+	char** (*get_ips)(struct lxc_container *c, const char* interface, const char* family, int scope);
 
 	/*!
 	 * \brief Retrieve the specified cgroup subsystem value for the container.
@@ -628,7 +628,7 @@ struct lxc_container {
 	 *
 	 * \note \p commentfile may be \c NULL but this is discouraged.
 	 */
-	int (*snapshot)(struct lxc_container *c, char *commentfile);
+	int (*snapshot)(struct lxc_container *c, const char *commentfile);
 
 	/*!
 	 * \brief Obtain a list of container snapshots.
@@ -661,7 +661,7 @@ struct lxc_container {
 	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,
 	 *  then \c snap0 will be copied to \c /var/lib/lxc/c2.
 	 */
-	bool (*snapshot_restore)(struct lxc_container *c, char *snapname, char *newname);
+	bool (*snapshot_restore)(struct lxc_container *c, const char *snapname, const char *newname);
 
 	/*!
 	 * \brief Destroy the specified snapshot.
@@ -671,7 +671,7 @@ struct lxc_container {
 	 *
 	 * \return \c true on success, else \c false.
 	 */
-	bool (*snapshot_destroy)(struct lxc_container *c, char *snapname);
+	bool (*snapshot_destroy)(struct lxc_container *c, const char *snapname);
 
 	/*!
 	 * \brief Determine if the caller may control the container.
@@ -694,7 +694,7 @@ struct lxc_container {
 	 *
 	 * \return \c true on success, else \c false.
 	 */
-	bool (*add_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
+	bool (*add_device_node)(struct lxc_container *c, const char *src_path, const char *dest_path);
 
 	/*!
 	 * \brief Remove specified device from the container.
@@ -706,7 +706,7 @@ struct lxc_container {
 	 *
 	 * \return \c true on success, else \c false.
 	 */
-	bool (*remove_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
+	bool (*remove_device_node)(struct lxc_container *c, const char *src_path, const char *dest_path);
 };
 
 /*!

commit 95ee490bbdb97ab2b4f1dfa63a0a26e0dd1c2f17
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Dec 2 13:58:02 2013 -0500

    Reduce public API (V2)
    
    This removes all but the following headers from our includes:
     - attach_options.h
     - lxccontainer.h
     - version.h
    
    This also removes the duplicate lxc_version function (lxc_get_version
    has been preferred for a while).
    
    lxclock.h is now considered private.
    
    As a result quite a lot of files needed addition of extra includes
    previously inherited from lxclock.h.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index d57aead..4ad3b66 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -22,12 +22,11 @@
 
 #ifndef __LXC_CONTAINER_H
 #define __LXC_CONTAINER_H
-#include "lxclock.h"
 #include "attach_options.h"
-#include <stdlib.h>
 #include <malloc.h>
-
+#include <semaphore.h>
 #include <stdbool.h>
+#include <stdlib.h>
 
 #define LXC_CLONE_KEEPNAME        (1 << 0) /*!< Do not edit the rootfs to change the hostname */
 #define LXC_CLONE_COPYHOOKS       (1 << 1) /*!< Copy all hooks into the container directory */
@@ -41,6 +40,8 @@ struct bdev_specs;
 
 struct lxc_snapshot;
 
+struct lxc_lock;
+
 /*!
  * An LXC container.
  */

commit c9d845b5183650d24b728a90dd8c60e3b50f928c
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Fri Nov 29 11:31:32 2013 -0500

    Update doxygen doc for previous change
    
    Reported-by: James Hunt <james.hunt@ubuntu.com>
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 9093de2..d57aead 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -206,6 +206,7 @@ struct lxc_container {
 	 * from the terminal.
 	 *
 	 * \param c Container.
+	 * \param state Value for the daemonize bit (0 or 1).
 	 *
 	 * \return \c true if container wants to be daemonised, else \c false.
 	 */
@@ -216,6 +217,7 @@ struct lxc_container {
 	 *  to be closed on startup.
 	 *
 	 * \param c Container.
+	 * \param state Value for the close_all_fds bit (0 or 1).
 	 *
 	 * \return \c true if container wants all file descriptors closed,
 	 *  else \c false.

commit 540f932aeb28274e8e7ea1e8f3a8e5889b88e1d6
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Fri Nov 29 10:53:15 2013 -0500

    Allow unsetting daemonize and close_fds
    
    As mentioned in a previous commit, this does two changes:
     - Make want_daemonize return a bool (false on failure, true on success)
     - Make both want_daemonize and want_close_all_fds take a "state"
       argument so the user can choose to unset those flags.
    
    This commit also updates all occurences of those two functions and turns
    the daemonize attribute from an int to a bool.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 6044f4d..9093de2 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -93,7 +93,7 @@ struct lxc_container {
 	int error_num;
 
 	/*! Whether container wishes to be daemonized */
-	int daemonize;
+	bool daemonize;
 
 	/*! Full path to configuration file */
 	char *config_path;
@@ -209,7 +209,7 @@ struct lxc_container {
 	 *
 	 * \return \c true if container wants to be daemonised, else \c false.
 	 */
-	void (*want_daemonize)(struct lxc_container *c);
+	bool (*want_daemonize)(struct lxc_container *c, bool state);
 
 	/*!
 	 * \brief Determine whether container wishes all file descriptors
@@ -220,7 +220,7 @@ struct lxc_container {
 	 * \return \c true if container wants all file descriptors closed,
 	 *  else \c false.
 	 */
-	bool (*want_close_all_fds)(struct lxc_container *c);
+	bool (*want_close_all_fds)(struct lxc_container *c, bool state);
 
 	/*!
 	 * \brief Return current config file name.

commit cf642e1085063cc0081335169ffd83d7cab3899c
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Wed Nov 27 17:59:35 2013 -0500

    Fix typo in doxygen comment
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 6295354..6044f4d 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -510,7 +510,7 @@ struct lxc_container {
 	 *  By default the original is used (subject to snapshot requirements).
 	 * \param bdevdata Information about how to create the new storage
 	 *  (i.e. fstype and fsdata).
-	 *  \param newsize In case of a block device backing store, an
+	 * \param newsize In case of a block device backing store, an
 	 *  optional size. If \c 0, the original backing store's size will
 	 *  be used if possible. Note this only applies to the rootfs. For
 	 *  any other filesystems, the original size will be duplicated.

commit f7f1ba77b76e4d4dc18638cfdc859c3dc1750a9e
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Nov 25 11:52:43 2013 -0500

    Drop trailing white spaces.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 7af24e5..6295354 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -149,7 +149,7 @@ struct lxc_container {
 	 * \brief Determine process ID of the containers init process.
 	 *
 	 * \param c Container.
-	 * 
+	 *
 	 * \return pid of init process as seen from outside the
 	 *  container.
 	 */

commit 953e611ceabed9ccf986e0b234379c2af4bb331a
Author: James Hunt <james.hunt@ubuntu.com>
Date:   Mon Nov 25 13:42:09 2013 +0000

    Add '--enable-api-docs' for doxygen-generated public API docs.
    
    Signed-off-by: James Hunt <james.hunt@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 57b8e78..7af24e5 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -1,4 +1,6 @@
-/* liblxcapi
+/*! \file
+ *
+ * liblxcapi
  *
  * Copyright © 2012 Serge Hallyn <serge.hallyn@ubuntu.com>.
  * Copyright © 2012 Canonical Ltd.
@@ -27,289 +29,835 @@
 
 #include <stdbool.h>
 
-#define LXC_CLONE_KEEPNAME        (1 << 0)
-#define LXC_CLONE_COPYHOOKS       (1 << 1)
-#define LXC_CLONE_KEEPMACADDR     (1 << 2)
-#define LXC_CLONE_SNAPSHOT        (1 << 3)
-#define LXC_CLONE_MAXFLAGS        (1 << 4)
-
-#define LXC_CREATE_QUIET	  (1 << 0)
-#define LXC_CREATE_MAXFLAGS       (1 << 1)
+#define LXC_CLONE_KEEPNAME        (1 << 0) /*!< Do not edit the rootfs to change the hostname */
+#define LXC_CLONE_COPYHOOKS       (1 << 1) /*!< Copy all hooks into the container directory */
+#define LXC_CLONE_KEEPMACADDR     (1 << 2) /*!< Do not change the MAC address on network interfaces */
+#define LXC_CLONE_SNAPSHOT        (1 << 3) /*!< Snapshot the original filesystem(s) */
+#define LXC_CLONE_MAXFLAGS        (1 << 4) /*!< Number of \c LXC_CLONE_* flags */
+#define LXC_CREATE_QUIET          (1 << 0) /*!< Redirect \c stdin to \c /dev/zero and \c stdout and \c stderr to \c /dev/null */
+#define LXC_CREATE_MAXFLAGS       (1 << 1) /*!< Number of \c LXC_CREATE* flags */
 
 struct bdev_specs;
 
 struct lxc_snapshot;
 
+/*!
+ * An LXC container.
+ */
 struct lxc_container {
 	// private fields
+	/*!
+	 * \private
+	 * Name of container.
+	 */
 	char *name;
+
+	/*!
+	 * \private
+	 * Full path to configuration file.
+	 */
 	char *configfile;
+
+	/*!
+	 * \private
+	 * Container semaphore lock.
+	 */
 	struct lxc_lock *slock;
+
+	/*!
+	 * \private
+	 * Container private lock.
+	 */
 	struct lxc_lock *privlock;
-	int numthreads; /* protected by privlock. */
-	struct lxc_conf *lxc_conf; // maybe we'll just want the whole lxc_handler?
+
+	/*!
+	 * \private
+	 * Number of references to this container.
+	 * \note protected by privlock.
+	 */
+	int numthreads;
+
+	/*!
+	 * \private
+	 * Container configuration.
+	 *
+	 * \internal FIXME: do we want the whole lxc_handler?
+	 */
+	struct lxc_conf *lxc_conf;
 
 	// public fields
+	/*! Human-readable string representing last error */
 	char *error_string;
+
+	/*! Last error number */
 	int error_num;
+
+	/*! Whether container wishes to be daemonized */
 	int daemonize;
 
+	/*! Full path to configuration file */
 	char *config_path;
 
-	bool (*is_defined)(struct lxc_container *c);  // did /var/lib/lxc/$name/config exist
+	/*!
+	 * \brief Determine if \c /var/lib/lxc/$name/config exists.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true if container is defined, else \c false.
+	 */
+	bool (*is_defined)(struct lxc_container *c);
+
+	/*!
+	 * \brief Determine state of container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return Static upper-case string representing state of container.
+	 *
+	 * \note Returned string must not be freed.
+	 */
 	const char *(*state)(struct lxc_container *c);
-	bool (*is_running)(struct lxc_container *c);  // true so long as defined and not stopped
+
+	/*!
+	 * \brief Determine if container is running.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
+	bool (*is_running)(struct lxc_container *c);
+
+	/*!
+	 * \brief Freeze running container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*freeze)(struct lxc_container *c);
+
+	/*!
+	 * \brief Thaw a frozen container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*unfreeze)(struct lxc_container *c);
+
+	/*!
+	 * \brief Determine process ID of the containers init process.
+	 *
+	 * \param c Container.
+	 * 
+	 * \return pid of init process as seen from outside the
+	 *  container.
+	 */
 	pid_t (*init_pid)(struct lxc_container *c);
+
+	/*!
+	 * \brief Load the specified configuration for the container.
+	 *
+	 * \param c Container.
+	 * \param alt_file Full path to alternate configuration file, or
+	 *  \c NULL to use the default configuration file.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*load_config)(struct lxc_container *c, const char *alt_file);
-	/* The '...' is the command line.  If provided, it must be ended with a NULL */
+
+	/*!
+	 * \brief Start the container.
+	 *
+	 * \param c Container.
+	 * \param useinit Use lxcinit rather than \c /sbin/init.
+	 * \param argv Array of arguments to pass to init.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*start)(struct lxc_container *c, int useinit, char * const argv[]);
+
+	/*!
+	 * \brief Start the container (list variant).
+	 *
+	 * \param c Container.
+	 * \param useinit Use lxcinit rather than \c /sbin/init.
+	 * \param ... Command-line to pass to init (must end in \c NULL).
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Identical to \ref start except that that the init
+	 *  arguments are specified via a list rather than an array of
+	 *  pointers.
+	 */
 	bool (*startl)(struct lxc_container *c, int useinit, ...);
+
+	/*!
+	 * \brief Stop the container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*stop)(struct lxc_container *c);
+
+	/*!
+	 * \brief Determine if the container wants to run disconnected
+	 * from the terminal.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true if container wants to be daemonised, else \c false.
+	 */
 	void (*want_daemonize)(struct lxc_container *c);
+
+	/*!
+	 * \brief Determine whether container wishes all file descriptors
+	 *  to be closed on startup.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true if container wants all file descriptors closed,
+	 *  else \c false.
+	 */
 	bool (*want_close_all_fds)(struct lxc_container *c);
-	// Return current config file name.  The result is strdup()d, so free the result.
+
+	/*!
+	 * \brief Return current config file name.
+	 *
+	 * \param c Container.
+	 *
+	 * \return config file name, or \c NULL on error.
+	 *
+	 * \note The result is allocated, so the caller must free the result.
+	 */
 	char *(*config_file_name)(struct lxc_container *c);
-	// for wait, timeout == -1 means wait forever, timeout == 0 means don't wait.
-	// otherwise timeout is seconds to wait.
+
+	/*!
+	 * \brief Wait for container to reach a particular state.
+	 *
+	 * \param c Container.
+	 * \param state State to wait for.
+	 * \param timeout Timeout in seconds.
+	 *
+	 * \return \c true if state reached within \p timeout, else \c false.
+	 *
+	 * \note A \p timeout of \c -1 means wait forever. A \p timeout
+	 *  of \c 0 means do not wait.
+	 */
 	bool (*wait)(struct lxc_container *c, const char *state, int timeout);
+
+	/*!
+	 * \brief Set a key/value configuration option.
+	 *
+	 * \param c Container.
+	 * \param key Name of option to set.
+	 * \param value Value of \p name to set.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*set_config_item)(struct lxc_container *c, const char *key, const char *value);
+
+	/*!
+	 * \brief Delete the container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Container must be stopped and have no dependent snapshots.
+	 */
 	bool (*destroy)(struct lxc_container *c);
+
+	/*!
+	 * \brief Save configuaration to a file.
+	 *
+	 * \param c Container.
+	 * \param alt_file Full path to file to save configuration in.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*save_config)(struct lxc_container *c, const char *alt_file);
+
+	/*!
+	 * \brief Create a container.
+	 *
+	 * \param c Container (with lxcpath, name and a starting
+	 *  configuration set).
+	 * \param t Template to execute to instantiate the root
+	 *  filesystem and adjust the configuration.
+	 * \param bdevtype Backing store type to use (if \c NULL, \c dir will be used).
+	 * \param specs Additional parameters for the backing store (for
+	 *  example LVM volume group to use).
+	 * \param flags \c LXC_CREATE_* options (currently only \ref
+	 *  LXC_CREATE_QUIET is supported).
+	 * \param argv Arguments to pass to the template, terminated by \c NULL (if no
+	 *  arguments are required, just pass \c NULL).
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*create)(struct lxc_container *c, const char *t, const char *bdevtype,
 			struct bdev_specs *specs, int flags, char *const argv[]);
+
+	/*!
+	 * \brief Create a container (list variant).
+	 *
+	 * \param c Container (with lxcpath, name and a starting
+	 *  configuration set).
+	 * \param t Template to execute to instantiate the root
+	 *  filesystem and adjust the configuration.
+	 * \param bdevtype Backing store type to use (if \c NULL, \c dir will be used).
+	 * \param specs Additional parameters for the backing store (for
+	 *  example LVM volume group to use).
+	 * \param flags \c LXC_CREATE_* options (currently only \ref
+	 *  LXC_CREATE_QUIET is supported).
+	 * \param ... Command-line to pass to init (must end in \c NULL).
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Identical to \ref create except that the template
+	 *  arguments are specified as a list rather than an array of
+	 *  pointers.
+	 */
 	bool (*createl)(struct lxc_container *c, const char *t, const char *bdevtype,
 			struct bdev_specs *specs, int flags, ...);
-	/* send SIGINT to ask container to reboot */
+
+	/*!
+	 * \brief Request the container reboot by sending it \c SIGINT.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c true if reboot request successful, else \c false.
+	 */
 	bool (*reboot)(struct lxc_container *c);
-	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
+
+	/*!
+	 * \brief Request the container shutdown by sending it \c
+	 * SIGPWR.
+	 *
+	 * \param c Container.
+	 * \param timeout Seconds to wait before forcing a hard stop
+	 *  (value must be >0).
+	 *
+	 * \return \c true if configuration was loaded successfully, else \c false.
+	 *
+	 * \note A \p timeout of \c 0 means do not wait.
+	 */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
-	/* completely clear a configuration */
+
+	/*!
+	 * \brief Completely clear the containers in-memory configuration.
+	 *
+	 * \param c Container.
+	 */
 	void (*clear_config)(struct lxc_container *c);
-	/* clear all network or capability items in the in-memory configuration */
+
+	/*!
+	 * \brief Clear a configuration item.
+	 *
+	 * \param c Container.
+	 * \param key Name of option to clear.
+	 *
+	 * \return \c true on success, else \c false.
+	 *
+	 * \note Analog of \ref set_config_item.
+	 */
 	bool (*clear_config_item)(struct lxc_container *c, const char *key);
-	/* print a config item to a in-memory string allocated by the caller.  Return
-	 * the length which was our would be printed. */
+
+	/*!
+	 * \brief Retrieve the value of a config item.
+	 *
+	 * \param c Container.
+	 * \param key Name of option to get.
+	 * \param[out] retv Caller-allocated buffer to write value of \p key
+	 * into (or \c NULL to determine length of value).
+	 * \param inlen Length of \p retv (may be zero).
+	 *
+	 * \return Length of config items value, or < 0 on error.
+	 *
+	 * \note The caller can (and should) determine how large a buffer to allocate for
+	 *  \p retv by initially passing its value as \c NULL and considering the return value.
+	 *  This function can then be called again passing a newly-allocated suitably-sized buffer.
+	 * \note If \p retv is NULL, \p inlen is ignored.
+	 * \note If \p inlen is smaller than required, the value written
+	 *  to \p retv will be truncated.
+	 */
 	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
+
+	/*!
+	 * \brief Retrieve a list of config item keys given a key
+	 * prefix.
+	 *
+	 * \param c Container.
+	 * \param key Name of option to get.
+	 * \param[out] retv Caller-allocated buffer to write list of keys to
+	 *  (or \c NULL to determine overall length of keys list).
+	 * \param inlen Length of \p retv (may be zero).
+	 *
+	 * \return Length of keys list, or < 0 on error.
+	 *
+	 * \note The list values written to \p retv are separated by
+	 *  a newline character ('\\n').
+	 * \note The caller can (and should) determine how large a buffer to allocate for
+	 *  \p retv by initially passing its value as \c NULL and considering the return value.
+	 *  This function can then be called again passing a newly-allocated suitably-sized buffer.
+	 * \note If \p retv is NULL, \p inlen is ignored.
+	 * \note If \p inlen is smaller than required, the value written
+	 *  to \p retv will be truncated.
+	 */
 	int (*get_keys)(struct lxc_container *c, const char *key, char *retv, int inlen);
-	// Return interface names.  The result is strdup()d, so free the result.
+
+	/*!
+	 * \brief Obtain a list of network interfaces.
+	 * \param c Container.
+	 *
+	 * \return Newly-allocated array of network interfaces, or \c
+	 *  NULL on error.
+	 *
+	 * \note The returned array is allocated, so the caller must free it.
+	 * \note The returned array is terminated with a \c NULL entry.
+	 */
 	char** (*get_interfaces)(struct lxc_container *c);
-	// Return IP addresses.  The result is strdup()d, so free the result.
+
+	/*!
+	 * \brief Determine the list of container IP addresses.
+	 *
+	 * \param c Container.
+	 * \param interface Network interface name to consider.
+	 * \param family Network family (for example "inet", "inet6").
+	 * \param scope IPv6 scope id (ignored if \p family is not "inet6").
+	 *
+	 * \return Newly-allocated array of network interfaces, or \c
+	 *  NULL on error.
+	 *
+	 * \note The returned array is allocated, so the caller must free it.
+	 * \note The returned array is terminated with a \c NULL entry.
+	 */
 	char** (*get_ips)(struct lxc_container *c, char* interface, char* family, int scope);
-	/*
-	 * get_cgroup_item returns the number of bytes read, or an error (<0).
-	 * If retv NULL or inlen 0 is passed in, then the length of the cgroup
-	 * file will be returned.  *   Otherwise it will return the # of bytes read.
-	 * If inlen is less than the number of bytes available, then the returned
-	 * value will be inlen, not the full available size of the file.
+
+	/*!
+	 * \brief Retrieve the specified cgroup subsystem value for the container.
+	 *
+	 * \param c Container.
+	 * \param subsys cgroup subsystem to retrieve.
+	 * \param[out] retv Caller-allocated buffer to write value of \p
+	 *  subsys into (or \c NULL to determine length of value).
+	 * \param inlen length of \p retv (may be zero).
+	 *
+	 * \return Length of \p subsys value, or < 0 on error.
+	 *
+	 * \note If \p retv is \c NULL, \p inlen is ignored.
+	 * \note If \p inlen is smaller than required, the value written
+	 *  to \p retv will be truncated.
 	 */
 	int (*get_cgroup_item)(struct lxc_container *c, const char *subsys, char *retv, int inlen);
+
+	/*!
+	 * \brief Set the specified cgroup subsystem value for the container.
+	 *
+	 * \param c Container.
+	 * \param subsys cgroup subsystem to consider.
+	 * \param value Value to set for \p subsys.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*set_cgroup_item)(struct lxc_container *c, const char *subsys, const char *value);
 
-	/*
-	 * Each container can have a custom configuration path.  However
-	 * by default it will be set to either the LXCPATH configure
-	 * variable, or the lxcpath value in the LXC_GLOBAL_CONF configuration
-	 * file (i.e. /etc/lxc/lxc.conf).
-	 * You can change the value for a specific container with
-	 * set_config_path().  Note there is no other way to specify this in
-	 * general at the moment.
+	/*!
+	 * \brief Determine full path to the containers configuration file.
+	 * Each container can have a custom configuration path. However
+	 * by default it will be set to either the \c LXCPATH configure
+	 * variable, or the lxcpath value in the \c LXC_GLOBAL_CONF configuration
+	 * file (i.e. \c /etc/lxc/lxc.conf).
+	 * The value for a specific container can be changed using
+	 * \ref set_config_path. There is no other way to specify this in general at the moment.
+	 *
+	 * \param c Container.
+	 *
+	 * \return Static string representing full path to configuration
+	 * file.
+	 *
+	 * \note Returned string must not be freed.
 	 */
 	const char *(*get_config_path)(struct lxc_container *c);
+
+	/*!
+	 * \brief Set the full path to the containers configuration
+	 * file.
+	 *
+	 * \param c Container.
+	 * \param path Full path to configuration file.
+	 *
+	 * \return \c true on success, else \c false.
+	 */
 	bool (*set_config_path)(struct lxc_container *c, const char *path);
 
-	/*
-	 * @c: the original container
-	 * @newname: new name for the container.  If NULL, the same name is used, and
-	 *  a new lxcpath MUST be specified.
-	 * @lxcpath: lxcpath in which to create the new container.  If NULL, then the
-	 *  original container's lxcpath will be used.  (Shoudl we use the default
-	 *  instead?)
-	 * @flags: additional flags to modify cloning behavior.
-	 *  LXC_CLONE_KEEPNAME: don't edit the rootfs to change the hostname.
-	 *  LXC_CLONE_COPYHOOKS: copy all hooks into the container dir
-	 *  LXC_CLONE_KEEPMACADDR: don't change the mac address on network interfaces.
-	 *  LXC_CLONE_SNAPSHOT: snapshot the original filesystem(s).  If @devtype was not
-	 *   specified, then do so with the native bdevtype if possible, else use an
-	 *   overlayfs.
-	 * @bdevtype: optionally force the cloned bdevtype to a specified plugin.  By
-	 *  default the original  is used (subject to snapshot requirements).
-	 * @bdevdata: information about how to create the new storage (i.e. fstype and
-	 *  fsdata)
-	 * @newsize: in case of a block device backing store, an optional size.  If 0,
-	 *  then the original backing store's size will be used if possible.  Note this
-	 *  only applies to the rootfs.  For any other filesystems, the original size
-	 *  will be duplicated.
-	 * @hookargs: additional arguments to pass to the clone hook script
+	/*!
+	 * \brief Copy a stopped container.
+	 *
+	 * \param c Original container.
+	 * \param newname New name for the container. If \c NULL, the same
+	 *  name is used and a new lxcpath MUST be specified.
+	 * \param lxcpath lxcpath in which to create the new container. If
+	 *  \c NULL, the original container's lxcpath will be used.
+	 *  (XXX: should we use the default instead?)
+	 * \param flags Additional \c LXC_CLONE* flags to change the cloning behaviour:
+	 *  - \ref LXC_CLONE_KEEPNAME
+	 *  - \ref LXC_CLONE_COPYHOOKS
+	 *  - \ref LXC_CLONE_KEEPMACADDR
+	 *  - \ref LXC_CLONE_SNAPSHOT
+	 * \param bdevtype Optionally force the cloned bdevtype to a specified plugin.
+	 *  By default the original is used (subject to snapshot requirements).
+	 * \param bdevdata Information about how to create the new storage
+	 *  (i.e. fstype and fsdata).
+	 *  \param newsize In case of a block device backing store, an
+	 *  optional size. If \c 0, the original backing store's size will
+	 *  be used if possible. Note this only applies to the rootfs. For
+	 *  any other filesystems, the original size will be duplicated.
+	 * \param hookargs Additional arguments to pass to the clone hook script.
+	 *
+	 * \return Newly-allocated copy of container \p c, or \p NULL on
+	 * error.
+	 *
+	 * \note If devtype was not specified, and \p flags contains \ref
+	 * LXC_CLONE_SNAPSHOT then use the native \p bdevtype if possible,
+	 * else use an overlayfs.
 	 */
 	struct lxc_container *(*clone)(struct lxc_container *c, const char *newname,
-		const char *lxcpath, int flags, const char *bdevtype,
-		const char *bdevdata, unsigned long newsize, char **hookargs);
+			const char *lxcpath, int flags, const char *bdevtype,
+			const char *bdevdata, unsigned long newsize, char **hookargs);
 
-	/* lxcapi_console_getfd: allocate a console tty from container @c
+	/*!
+	 * \brief Allocate a console tty for the container.
 	 *
-	 * @c        : the running container
-	 * @ttynum   : in : tty number to attempt to allocate or -1 to
-	 *                  allocate the first available tty
-	 *             out: the tty number that was allocated
-	 * @masterfd : out: fd refering to the master side of pty
+	 * \param c Container.
+	 * \param[in,out] ttynum Terminal number to attempt to allocate,
+	 *  or \c -1 to allocate the first available tty.
+	 * \param[out] masterfd File descriptor refering to the master side of the pty.
 	 *
-	 * Returns "ttyfd" on success, -1 on failure. The returned "ttyfd" is
-	 * used to keep the tty allocated. The caller should close "ttyfd" to
-	 * indicate that it is done with the allocated console so that it can
-	 * be allocated by another caller.
+	 * \return tty file descriptor number on success, or \c -1 on
+	 *  failure.
+	 *
+	 * \note On successful return, \p ttynum will contain the tty number
+	 *  that was allocated.
+	 * \note The returned file descriptor is used to keep the tty
+	 *  allocated. The caller should call close(2) on the returned file
+	 *  descriptor when no longer required so that it may be allocated
+	 *  by another caller.
 	 */
 	int (*console_getfd)(struct lxc_container *c, int *ttynum, int *masterfd);
 
-	/* lxcapi_console: allocate and run a console tty from container @c
+	/*!
+	 * \brief Allocate and run a console tty.
+	 *
+	 * \param c Container.
+	 * \param ttynum Terminal number to attempt to allocate, \c -1 to
+	 *  allocate the first available tty or \c 0 to allocate the
+	 *  console.
+	 * \param stdinfd File descriptor to read input from.
+	 * \param stdoutfd File descriptor to write output to.
+	 * \param stderrfd File descriptor to write error output to.
+	 * \param escape The escape character (1 == 'a', 2 == 'b', ...).
 	 *
-	 * @c        : the running container
-	 * @ttynum   : tty number to attempt to allocate, -1 to
-	 *             allocate the first available tty, or 0 to allocate
-	 *             the console
-	 * @stdinfd  : fd to read input from
-	 * @stdoutfd : fd to write output to
-	 * @stderrfd : fd to write error output to
-	 * @escape   : the escape character (1 == 'a', 2 == 'b', ...)
+	 * \return \c 0 on success, \c -1 on failure.
 	 *
-	 * Returns 0 on success, -1 on failure. This function will not return
-	 * until the console has been exited by the user.
+	 * \note This function will not return until the console has been
+	 *  exited by the user.
 	 */
 	int (*console)(struct lxc_container *c, int ttynum,
-		       int stdinfd, int stdoutfd, int stderrfd, int escape);
+			int stdinfd, int stdoutfd, int stderrfd, int escape);
 
-	/* create subprocess and attach it to the container, run exec_function inside */
-	int (*attach)(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process);
+	/*!
+	 * \brief Create a sub-process attached to a container and run
+	 *  a function inside it.
+	 *
+	 * \param c Container.
+	 * \param exec_function Function to run.
+	 * \param exec_payload Data to pass to \p exec_function.
+	 * \param options \ref lxc_attach_options_t.
+	 * \param[out] attached_process Process ID of process running inside
+	 *  container \p c that is running \p exec_function.
+	 *
+	 * \return \c 0 on success, \c -1 on error.
+	 */
+	int (*attach)(struct lxc_container *c, lxc_attach_exec_t exec_function,
+			void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process);
 
-	/* run program in container, wait for it to exit */
+	/*!
+	 * \brief Run a program inside a container and wait for it to exit.
+	 *
+	 * \param c Container.
+	 * \param options See \ref attach options.
+	 * \param program Full path inside container of program to run.
+	 * \param argv Array of arguments to pass to \p program.
+	 *
+	 * \return \c waitpid(2) status of exited process that ran \p
+	 * program, or \c -1 on error.
+	 */
 	int (*attach_run_wait)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[]);
-	int (*attach_run_waitl)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...);
 
-	/*
-	* snapshot:
-	* If you have /var/lib/lxc/c1 and call c->snapshot() the firs time, it
-	* will return 0, and the container will be /var/lib/lxcsnaps/c1/snap0.
-	* The second call will return 1, and the snapshot will be
-	* /var/lib/lxcsnaps/c1/snap1.
-	*
-	* On error, returns -1.
-	*/
-	int (*snapshot)(struct lxc_container *c, char *commentfile);
+	/*!
+	 * \brief Run a program inside a container and wait for it to exit (list variant).
+	 *
+	 * \param c Container.
+	 * \param options See \ref attach options.
+	 * \param program Full path inside container of program to run.
+	 * \param ... Command-line to pass to \p program (must end in \c NULL).
+	 *
+	 * \return \c waitpid(2) status of exited process that ran \p
+	 * program, or \c -1 on error.
+	 */
+	int (*attach_run_waitl)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...);
 
-	/*
-	 * snapshot_list() will return a description of all snapshots of c in
-	 * a simple array.  See src/tests/snapshot.c for the proper way to
-	 * free the allocated results.
+	/*!
+	 * \brief Create a container snapshot.
+	 *
+	 * Assuming default paths, snapshots will be created as
+	 * \c /var/lib/lxcsnaps/\<c\>/snap\<n\>
+	 * where \c \<c\> represents the container name and \c \<n\>
+	 * represents the zero-based snapshot number.
+	 *
+	 * \param c Container.
+	 * \param commentfile Full path to file containing a description
+	 *  of the snapshot.
+	 *
+	 * \return -1 on error, or zero-based snapshot number.
 	 *
-	 * Returns the number of snapshots.
+	 * \note \p commentfile may be \c NULL but this is discouraged.
 	 */
-	int (*snapshot_list)(struct lxc_container *, struct lxc_snapshot **);
+	int (*snapshot)(struct lxc_container *c, char *commentfile);
 
-	/*
-	 * snapshot_restore() will create a new container based on a snapshot.
-	 * c is the container whose snapshot we look for, and snapname is the
-	 * specific snapshot name (i.e. "snap0").  newname is the name to be
-	 * used for the restored container.  If newname is the same as
-	 * c->name, then c will first be destroyed.  That will fail if the
-	 * snapshot is overlayfs-based, since the snapshots will pin the
-	 * original container.
+	/*!
+	 * \brief Obtain a list of container snapshots.
+	 *
+	 * \param c Container.
+	 * \param[out] snapshots Dynamically-allocated Array of lxc_snapshot's.
 	 *
-	 * The restored container will be a copy (not snapshot) of the snapshot,
-	 * and restored in the lxcpath of the original container.
+	 * \return Number of snapshots.
 	 *
-	 * As an example, c might be /var/lib/lxc/c1, snapname  might be 'snap0'
-	 * which stands for /var/lib/lxcsnaps/c1/snap0.  If newname is c2,
-	 * then snap0 will be copied to /var/lib/lxc/c2.
+	 * \note The array returned in \p snapshots is allocated, so the caller must free it.
+	 * \note To free an individual snapshot as returned in \p
+	 * snapshots, call the snapshots \c free function (see \c src/tests/snapshot.c for an example).
+	 */
+	int (*snapshot_list)(struct lxc_container *c, struct lxc_snapshot **snapshots);
+
+	/*!
+	 * \brief Create a new container based on a snapshot.
 	 *
-	 * Returns true on success, false on failure.
+	 *  The restored container will be a copy (not snapshot) of the snapshot,
+	 *  and restored in the lxcpath of the original container.
+	 * \param c Container.
+	 * \param snapname Name of snapshot.
+	 * \param newname Name to be used for the restored snapshot.
+	 * \return \c true on success, else \c false.
+	 * \warning If \p newname is the same as the current container
+	 *  name, the container will be destroyed. However, this will
+	 *  fail if the  snapshot is overlayfs-based, since the snapshots
+	 *  will pin the original container.
+	 * \note As an example, if the container exists as \c /var/lib/lxc/c1, snapname might be \c 'snap0'
+	 *  (representing \c /var/lib/lxcsnaps/c1/snap0). If \p newname is \p c2,
+	 *  then \c snap0 will be copied to \c /var/lib/lxc/c2.
 	 */
 	bool (*snapshot_restore)(struct lxc_container *c, char *snapname, char *newname);
 
-	/*
-	 * snapshot_destroy() will destroy the given snapshot of c
+	/*!
+	 * \brief Destroy the specified snapshot.
 	 *
-	 * Returns true on success, false on failure.
+	 * \param c Container.
+	 * \param snapname Name of snapshot.
+	 *
+	 * \return \c true on success, else \c false.
 	 */
 	bool (*snapshot_destroy)(struct lxc_container *c, char *snapname);
 
-	/*
-	 * Return false if there is a control socket for the container monitor,
-	 * and the caller may not access it.  Return true otherwise.
+	/*!
+	 * \brief Determine if the caller may control the container.
+	 *
+	 * \param c Container.
+	 *
+	 * \return \c false if there is a control socket for the
+	 *  container monitor and the caller may not access it, otherwise
+	 * returns \c true.
 	 */
 	bool (*may_control)(struct lxc_container *c);
 
-	/*
-	 * add_device_node:
-	 * @c        : the running container
-	 * @src_path : the path of the device
-	 * @dest_path: the alternate path in the container. If NULL, the src_path is used
+	/*!
+	 * \brief Add specified device to the container.
 	 *
-	 * Returns true if given device succesfully added to container
+	 * \param c Container.
+	 * \param src_path Full path of the device.
+	 * \param dest_path Alternate path in the container (or \p NULL
+	 *  to use \p src_path).
+	 *
+	 * \return \c true on success, else \c false.
 	 */
 	bool (*add_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
-	/*
-	 * remove_device_node:
-	 * @c        : the running container
-	 * @src_path : the path of the device
-	 * @dest_path: the alternate path in the container. If NULL, the src_path is used
+
+	/*!
+	 * \brief Remove specified device from the container.
 	 *
-	 * Returns true if given device succesfully removed from container
+	 * \param c Container.
+	 * \param src_path Full path of the device.
+	 * \param dest_path Alternate path in the container (or \p NULL
+	 *  to use \p src_path).
+	 *
+	 * \return \c true on success, else \c false.
 	 */
 	bool (*remove_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
 };
 
+/*!
+ * \brief An LXC container snapshot.
+ */
 struct lxc_snapshot {
-	char *name;
-	char *comment_pathname;
-	char *timestamp;
-	char *lxcpath;
-	void (*free)(struct lxc_snapshot *);
+	char *name; /*!< Name of snapshot */
+	char *comment_pathname; /*!< Full path to snapshots comment file (may be \c NULL) */
+	char *timestamp; /*!< Time snapshot was created */
+	char *lxcpath; /*!< Full path to LXCPATH for snapshot */
+
+	/*!
+	 * \brief De-allocate the snapshot.
+	 * \param s snapshot.
+	 */
+	void (*free)(struct lxc_snapshot *s);
 };
 
+/*!
+ * \brief Create a new container.
+ *
+ * \param name Name to use for container.
+ * \param configpath Full path to configuration file to use.
+ *
+ * \return Newly-allocated container, or \c NULL on error.
+ */
 struct lxc_container *lxc_container_new(const char *name, const char *configpath);
+
+/*!
+ * \brief Add a reference to the specified container.
+ *
+ * \param c Container.
+ *
+ * \return \c true on success, \c false on error.
+ */
 int lxc_container_get(struct lxc_container *c);
+
+/*!
+ * \brief Drop a reference to the specified container.
+ *
+ * \param c Container.
+ *
+ * \return \c 0 on success, \c 1 if reference was successfully dropped
+ * and container has been freed, and \c -1 on error.
+ *
+ * \warning If \c 1 is returned, \p c is no longer valid.
+ */
 int lxc_container_put(struct lxc_container *c);
+
+/*!
+ * \brief Obtain a list of all container states.
+ * \param[out] states Caller-allocated array to hold all states (may be \c NULL).
+ *
+ * \return Number of container states.
+ *
+ * \note Passing \c NULL for \p states allows the caller to first
+ *  calculate how many states there are before calling the function again, the second time
+ *  providing a suitably-sized array to store the static string pointers
+ *  in.
+ * \note The \p states array should be freed by the caller, but not the strings the elements point to.
+ */
 int lxc_get_wait_states(const char **states);
+
+/*!
+ * \brief Determine path to default configuration file.
+ *
+ * \return Static string representing full path to default configuration
+ *  file.
+ *
+ * \note Returned string must not be freed.
+ */
 const char *lxc_get_default_config_path(void);
+
+/*!
+ * \brief Determine default LVM volume group.
+ *
+ * \return Static string representing default volume group,
+ *  or \c NULL on error.
+ *
+ * \note Returned string must not be freed.
+ */
 const char *lxc_get_default_lvm_vg(void);
+
+/*!
+ * \brief Determine default LVM thin pool.
+ *
+ * \return Static string representing default lvm thin pool,
+ *  or \c NULL on error.
+ *
+ * \note Returned string must not be freed.
+ */
 const char *lxc_get_default_lvm_thin_pool(void);
+
+/*!
+ * \brief Determine default ZFS root.
+ *
+ * \return Static string representing default ZFS root,
+ *  or \c NULL on error.
+ *
+ * \note Returned string must not be freed.
+ */
 const char *lxc_get_default_zfs_root(void);
+
+/*!
+ * \brief Determine version of LXC.
+ * \return Static string representing version of LXC in use.
+ *
+ * \note Returned string must not be freed.
+ */
 const char *lxc_get_version(void);
 
-/*
- * Get a list of defined containers in a lxcpath.
- * @lxcpath: lxcpath under which to look.
- * @names: if not null, then a list of container names will be returned here.
- * @cret: if not null, then a list of lxc_containers will be returned here.
+/*!
+ * \brief Get a list of defined containers in a lxcpath.
  *
- * Returns the number of containers found, or -1 on error.
+ * \param lxcpath lxcpath under which to look.
+ * \param names If not \c NULL, then a list of container names will be returned here.
+ * \param cret If not \c NULL, then a list of lxc_containers will be returned here.
+ *
+ * \return Number of containers found, or \c -1 on error.
+ *
+ * \note Values returned in \p cret are sorted by container name.
  */
 int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
-/*
- * Get a list of active containers in a lxcpath.  Note that some of these
- * containers may not be "defined".
- * @lxcpath: lxcpath under which to look
- * @names: if not null, then a list of container names will be returned here.
- * @cret: if not null, then a list of lxc_containers will be returned here.
+/*!
+ * \brief Get a list of active containers for a given lxcpath.
+ *
+ * \param lxcpath Full \c LXCPATH path to consider.
+ * \param[out] names Dynamically-allocated array of container names.
+ * \param[out] cret Dynamically-allocated list of containers.
+ *
+ * \return Number of containers found, or -1 on error.
  *
- * Returns the number of containers found, or -1 on error.
+ * \note Some of the containers may not be "defined".
+ * \note Values returned in \p cret are sorted by container name.
+ * \note \p names and \p cret may both (or either) be specified as \c NULL.
+ * \note \p names and \p cret must be freed by the caller.
  */
 int list_active_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
-/*
- * Get an array sorted by name of defined and active containers in a lxcpath.
- * @lxcpath: lxcpath under which to look
- * @names: if not null, then an array of container names will be returned here.
- * @cret: if not null, then an array of lxc_containers will be returned here.
+/*!
+ * \brief Get a complete list of all containers for a given lxcpath.
  *
- * Returns the number of containers found, or -1 on error.
+ * \param lxcpath Full \c LXCPATH path to consider.
+ * \param[out] names Dynamically-allocated array of container name.
+ * \param[out] cret Dynamically-allocated list of containers.
+ *
+ * \return Number of containers, or -1 on error.
+ *
+ * \note Some of the containers may not be "defined".
+ * \note Values returned in \p cret are sorted by container name.
+ * \note \p names and \p cret may both (or either) be specified as \c NULL.
+ * \note \p names and \p cret must be freed by the caller.
  */
 int list_all_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
-#if 0
-char ** lxc_get_valid_keys();
-char ** lxc_get_valid_values(char *key);
-#endif
 #endif

commit 4df7f012b9994ea54b1ad68176d8d45a57fa02f3
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Nov 14 12:48:41 2013 -0600

    lxc-start: if we pass in a config file, then don't use any loaded config
    
    To do this, add a c->clear_config() helper to the api.
    
    (this fixes the bug https://bugs.launchpad.net/bugs/1251352)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 3a12372..57b8e78 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -85,6 +85,8 @@ struct lxc_container {
 	bool (*reboot)(struct lxc_container *c);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
+	/* completely clear a configuration */
+	void (*clear_config)(struct lxc_container *c);
 	/* clear all network or capability items in the in-memory configuration */
 	bool (*clear_config_item)(struct lxc_container *c, const char *key);
 	/* print a config item to a in-memory string allocated by the caller.  Return

commit a9a0ed90dd1cdadd412576a45af16419efc0e939
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Wed Nov 13 00:39:00 2013 -0500

    introduce lxcapi_add_device_node and lxcapi_remove_device_node to API (v3)
    
    Adding block/char devices to running container is a common operation so
    provide a common implementation for users to consume.
    
    changes since v2;
    * lets the user set an alternate path inside the container as Stéphane suggested
    
    changes since v1;
    * removed duplicated code
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 486035a..3a12372 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -236,6 +236,25 @@ struct lxc_container {
 	 * and the caller may not access it.  Return true otherwise.
 	 */
 	bool (*may_control)(struct lxc_container *c);
+
+	/*
+	 * add_device_node:
+	 * @c        : the running container
+	 * @src_path : the path of the device
+	 * @dest_path: the alternate path in the container. If NULL, the src_path is used
+	 *
+	 * Returns true if given device succesfully added to container
+	 */
+	bool (*add_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
+	/*
+	 * remove_device_node:
+	 * @c        : the running container
+	 * @src_path : the path of the device
+	 * @dest_path: the alternate path in the container. If NULL, the src_path is used
+	 *
+	 * Returns true if given device succesfully removed from container
+	 */
+	bool (*remove_device_node)(struct lxc_container *c, char *src_path, char *dest_path);
 };
 
 struct lxc_snapshot {

commit 2871830a40751c5a8fc30f47a8b8861dfa09d9dc
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Nov 5 13:16:51 2013 -0500

    add list_all_containers(), returns defined and active containers
    
    Changelog: [serge] remove unneeded explicity qsort call
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 762e1b0..486035a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -277,6 +277,16 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
  */
 int list_active_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
 
+/*
+ * Get an array sorted by name of defined and active containers in a lxcpath.
+ * @lxcpath: lxcpath under which to look
+ * @names: if not null, then an array of container names will be returned here.
+ * @cret: if not null, then an array of lxc_containers will be returned here.
+ *
+ * Returns the number of containers found, or -1 on error.
+ */
+int list_all_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
+
 #if 0
 char ** lxc_get_valid_keys();
 char ** lxc_get_valid_values(char *key);

commit 771d96b3807ed090a5dd341302d6317acdfb16ca
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Sat Oct 19 00:49:20 2013 -0400

    introduce snapshot_destroy
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index b7dc1a4..762e1b0 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -225,6 +225,13 @@ struct lxc_container {
 	bool (*snapshot_restore)(struct lxc_container *c, char *snapname, char *newname);
 
 	/*
+	 * snapshot_destroy() will destroy the given snapshot of c
+	 *
+	 * Returns true on success, false on failure.
+	 */
+	bool (*snapshot_destroy)(struct lxc_container *c, char *snapname);
+
+	/*
 	 * Return false if there is a control socket for the container monitor,
 	 * and the caller may not access it.  Return true otherwise.
 	 */

commit f99c386b60e7f635c2f95a2e3256f21e751fb50b
Author: Sidnei da Silva <sidnei.da.silva@canonical.com>
Date:   Mon Aug 19 19:34:19 2013 -0300

    Add a --thinpool argument to lxc-create, to use thin pool backed lvm when creating the container. When cloning a container backed by a thin pool, the clone will default to the same thin pool.

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5901066..b7dc1a4 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -245,6 +245,7 @@ int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);
 const char *lxc_get_default_config_path(void);
 const char *lxc_get_default_lvm_vg(void);
+const char *lxc_get_default_lvm_thin_pool(void);
 const char *lxc_get_default_zfs_root(void);
 const char *lxc_get_version(void);
 

commit a41f104bfbd69e5f068e5ca312a2eb513d9e81b8
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Oct 11 10:44:39 2013 -0500

    define list container api (v2)
    
    Two new commands are defined: list_defined_containers() and
    list_active_containers().  Both take an lxcpath (NULL means
    use the default lxcpath) and return the number of containers
    found.  If a lxc_container ** is passed in, then an array of
    lxc_container's is returned, one for each container found.
    The caller must then lxc_container_put() each container and
    free the array, as shown in the new list testcase.
    If a char ** is passed in, then an array of container names
    is returned, after which the caller must free all the names
    and the name array, as showsn in the testcase.
    
    Changelog:
    	Check for the container config file before trying to
    	create an lxc_container *, to save some work. [ per
    	stgraber comments]
    	Add names ** argument to return only container names.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 20ab8e8..5901066 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -248,6 +248,27 @@ const char *lxc_get_default_lvm_vg(void);
 const char *lxc_get_default_zfs_root(void);
 const char *lxc_get_version(void);
 
+/*
+ * Get a list of defined containers in a lxcpath.
+ * @lxcpath: lxcpath under which to look.
+ * @names: if not null, then a list of container names will be returned here.
+ * @cret: if not null, then a list of lxc_containers will be returned here.
+ *
+ * Returns the number of containers found, or -1 on error.
+ */
+int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
+
+/*
+ * Get a list of active containers in a lxcpath.  Note that some of these
+ * containers may not be "defined".
+ * @lxcpath: lxcpath under which to look
+ * @names: if not null, then a list of container names will be returned here.
+ * @cret: if not null, then a list of lxc_containers will be returned here.
+ *
+ * Returns the number of containers found, or -1 on error.
+ */
+int list_active_containers(const char *lxcpath, char ***names, struct lxc_container ***cret);
+
 #if 0
 char ** lxc_get_valid_keys();
 char ** lxc_get_valid_values(char *key);

commit b494d2ddf769220da1ef75fd24275ce68cdf297c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 27 21:01:07 2013 -0500

    add c->may_control
    
    This is an api function which will return false if the container
    is running, and the caller may not talk to its monitor over its
    command socket.  Otherwise - if the container is not running, or
    the caller may access it - it returns true.
    
    We can use this in several tools early on to prevent the segvs
    etc which we currently get.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 225fb39..20ab8e8 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -223,6 +223,12 @@ struct lxc_container {
 	 * Returns true on success, false on failure.
 	 */
 	bool (*snapshot_restore)(struct lxc_container *c, char *snapname, char *newname);
+
+	/*
+	 * Return false if there is a control socket for the container monitor,
+	 * and the caller may not access it.  Return true otherwise.
+	 */
+	bool (*may_control)(struct lxc_container *c);
 };
 
 struct lxc_snapshot {

commit 49badbbef602f1b8add1ea55d7cf0e1563bfe0db
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Sat Sep 21 13:00:15 2013 -0400

    return the result of the lxcapi_want_close_all_fds call to the caller
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 8b6c6ef..225fb39 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -68,7 +68,7 @@ struct lxc_container {
 	bool (*startl)(struct lxc_container *c, int useinit, ...);
 	bool (*stop)(struct lxc_container *c);
 	void (*want_daemonize)(struct lxc_container *c);
-	void (*want_close_all_fds)(struct lxc_container *c);
+	bool (*want_close_all_fds)(struct lxc_container *c);
 	// Return current config file name.  The result is strdup()d, so free the result.
 	char *(*config_file_name)(struct lxc_container *c);
 	// for wait, timeout == -1 means wait forever, timeout == 0 means don't wait.

commit 130a188840ae655da41dde4771074ff38abaf46f
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Fri Sep 20 18:45:21 2013 -0400

    Expose underlying close_all_fds config value via API
    
    Being able to set close_all_fds via API would be usefull for the
    situations like running an application (let's say web server)
    that controls the lifecycle of the container using the LXC API.
    We don't want forked process to inherit parent's resource (file, socket, ...)
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 89b55bd..8b6c6ef 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -68,6 +68,7 @@ struct lxc_container {
 	bool (*startl)(struct lxc_container *c, int useinit, ...);
 	bool (*stop)(struct lxc_container *c);
 	void (*want_daemonize)(struct lxc_container *c);
+	void (*want_close_all_fds)(struct lxc_container *c);
 	// Return current config file name.  The result is strdup()d, so free the result.
 	char *(*config_file_name)(struct lxc_container *c);
 	// for wait, timeout == -1 means wait forever, timeout == 0 means don't wait.

commit 799f29ab699f08e67231b012f20a25e23a6c391d
Author: S.Çağlar Onur <caglar@10ur.org>
Date:   Wed Sep 18 15:13:22 2013 -0400

    Add get_interfaces to the API
    
    get_ips accepts an interface name as a parameter but there was no
    way to get the interfaces names from the container. This patch
    introduces a new get_interfaces call to the API so that users
    can obtain the name of the interfaces.
    
    Support for python bindings also introduced as a part of this version.
    
    Signed-off-by: S.Çağlar Onur <caglar@10ur.org>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index f9ae43b..89b55bd 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -90,6 +90,9 @@ struct lxc_container {
 	 * the length which was our would be printed. */
 	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
 	int (*get_keys)(struct lxc_container *c, const char *key, char *retv, int inlen);
+	// Return interface names.  The result is strdup()d, so free the result.
+	char** (*get_interfaces)(struct lxc_container *c);
+	// Return IP addresses.  The result is strdup()d, so free the result.
 	char** (*get_ips)(struct lxc_container *c, char* interface, char* family, int scope);
 	/*
 	 * get_cgroup_item returns the number of bytes read, or an error (<0).

commit f5dd1d532a76a1b57cf341db821eae85ea1118c5
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 6 18:07:47 2013 -0500

    API support for container snapshots (v2)
    
    The api allows for creating, listing, and restoring of container
    snapshots.  Snapshots are created as snapshot clones of the
    original container - i.e. btrfs and lvm will be done as snapshot,
    a directory-backed container will have overlayfs snapshots.  A
    restore is a copy-clone, using the same backing store as the
    original container had.
    
    Changelog:
    
     . remove lxcapi_snap_open, which wasn't defined anyway.
     . rename get_comment to get_commentpath
     . if no newname is specified at restore, use c->name (as we meant to)
       rather than segving.
     . when choosing a snapshot index, use the correct path to check for.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index ad6afa1..f9ae43b 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -38,6 +38,8 @@
 
 struct bdev_specs;
 
+struct lxc_snapshot;
+
 struct lxc_container {
 	// private fields
 	char *name;
@@ -177,6 +179,54 @@ struct lxc_container {
 	/* run program in container, wait for it to exit */
 	int (*attach_run_wait)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[]);
 	int (*attach_run_waitl)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...);
+
+	/*
+	* snapshot:
+	* If you have /var/lib/lxc/c1 and call c->snapshot() the firs time, it
+	* will return 0, and the container will be /var/lib/lxcsnaps/c1/snap0.
+	* The second call will return 1, and the snapshot will be
+	* /var/lib/lxcsnaps/c1/snap1.
+	*
+	* On error, returns -1.
+	*/
+	int (*snapshot)(struct lxc_container *c, char *commentfile);
+
+	/*
+	 * snapshot_list() will return a description of all snapshots of c in
+	 * a simple array.  See src/tests/snapshot.c for the proper way to
+	 * free the allocated results.
+	 *
+	 * Returns the number of snapshots.
+	 */
+	int (*snapshot_list)(struct lxc_container *, struct lxc_snapshot **);
+
+	/*
+	 * snapshot_restore() will create a new container based on a snapshot.
+	 * c is the container whose snapshot we look for, and snapname is the
+	 * specific snapshot name (i.e. "snap0").  newname is the name to be
+	 * used for the restored container.  If newname is the same as
+	 * c->name, then c will first be destroyed.  That will fail if the
+	 * snapshot is overlayfs-based, since the snapshots will pin the
+	 * original container.
+	 *
+	 * The restored container will be a copy (not snapshot) of the snapshot,
+	 * and restored in the lxcpath of the original container.
+	 *
+	 * As an example, c might be /var/lib/lxc/c1, snapname  might be 'snap0'
+	 * which stands for /var/lib/lxcsnaps/c1/snap0.  If newname is c2,
+	 * then snap0 will be copied to /var/lib/lxc/c2.
+	 *
+	 * Returns true on success, false on failure.
+	 */
+	bool (*snapshot_restore)(struct lxc_container *c, char *snapname, char *newname);
+};
+
+struct lxc_snapshot {
+	char *name;
+	char *comment_pathname;
+	char *timestamp;
+	char *lxcpath;
+	void (*free)(struct lxc_snapshot *);
 };
 
 struct lxc_container *lxc_container_new(const char *name, const char *configpath);

commit 250b1eec71b074acdff1c5f6b5a1f0d7d2c20b77
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Tue Sep 3 14:29:46 2013 -0400

    licensing: Add missing headers and FSF address
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index b6a7ced..ad6afa1 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -1,3 +1,23 @@
+/* liblxcapi
+ *
+ * Copyright © 2012 Serge Hallyn <serge.hallyn@ubuntu.com>.
+ * Copyright © 2012 Canonical Ltd.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
 #ifndef __LXC_CONTAINER_H
 #define __LXC_CONTAINER_H
 #include "lxclock.h"

commit 0f081315a9310bf04fe4bc64b900ec6bac36f85d
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 30 15:51:31 2013 -0500

    remove old stale comments (lxc-clone is now implemented)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index e0c465c..b6a7ced 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -157,13 +157,6 @@ struct lxc_container {
 	/* run program in container, wait for it to exit */
 	int (*attach_run_wait)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[]);
 	int (*attach_run_waitl)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...);
-#if 0
-	bool (*commit_cgroups)(struct lxc_container *c);
-	bool (*reread_cgroups)(struct lxc_container *c);
-	// question with clone: how do we handle non-standard config file in orig?
-	struct lxc_container (*clone)(struct container *c);
-	// we'll need some plumbing to support lxc-console
-#endif
 };
 
 struct lxc_container *lxc_container_new(const char *name, const char *configpath);

commit a0e93eeb2293e15a18e6c56271d13907f082c4df
Author: Christian Seiler <christian@iwakd.de>
Date:   Tue May 21 14:57:06 2013 +0200

    Add attach support to container C API
    
    Signed-off-by: Christian Seiler <christian@iwakd.de>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 3399c7f..e0c465c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -1,6 +1,7 @@
 #ifndef __LXC_CONTAINER_H
 #define __LXC_CONTAINER_H
 #include "lxclock.h"
+#include "attach_options.h"
 #include <stdlib.h>
 #include <malloc.h>
 
@@ -150,12 +151,17 @@ struct lxc_container {
 	int (*console)(struct lxc_container *c, int ttynum,
 		       int stdinfd, int stdoutfd, int stderrfd, int escape);
 
+	/* create subprocess and attach it to the container, run exec_function inside */
+	int (*attach)(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process);
+
+	/* run program in container, wait for it to exit */
+	int (*attach_run_wait)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[]);
+	int (*attach_run_waitl)(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...);
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);
 	bool (*reread_cgroups)(struct lxc_container *c);
 	// question with clone: how do we handle non-standard config file in orig?
 	struct lxc_container (*clone)(struct container *c);
-	int (*ns_attach)(struct lxc_container *c, int ns_mask);
 	// we'll need some plumbing to support lxc-console
 #endif
 };

commit dc23c1c817da5c13529432270e51d0f7f3b1e95e
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jul 12 09:44:41 2013 -0500

    create: add a quiet flag
    
    If set, then fds 0,1,2 will be redirected while the creation
    template is executed.
    
    Note, as Dwight has pointed out, if fd 0 is redirected, then if
    templates ask for input there will be a problem.  We could simply
    not redirect fd 0, or we could require that templates work without
    interaction.  I'm assuming here that we want to do the latter, but
    I'm open to changing that.
    
    Reported-by: "S.Çağlar Onur" <caglar@10ur.org>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5449a46..3399c7f 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -12,6 +12,9 @@
 #define LXC_CLONE_SNAPSHOT        (1 << 3)
 #define LXC_CLONE_MAXFLAGS        (1 << 4)
 
+#define LXC_CREATE_QUIET	  (1 << 0)
+#define LXC_CREATE_MAXFLAGS       (1 << 1)
+
 struct bdev_specs;
 
 struct lxc_container {
@@ -51,9 +54,9 @@ struct lxc_container {
 	bool (*destroy)(struct lxc_container *c);
 	bool (*save_config)(struct lxc_container *c, const char *alt_file);
 	bool (*create)(struct lxc_container *c, const char *t, const char *bdevtype,
-			struct bdev_specs *specs, char *const argv[]);
+			struct bdev_specs *specs, int flags, char *const argv[]);
 	bool (*createl)(struct lxc_container *c, const char *t, const char *bdevtype,
-			struct bdev_specs *specs, ...);
+			struct bdev_specs *specs, int flags, ...);
 	/* send SIGINT to ask container to reboot */
 	bool (*reboot)(struct lxc_container *c);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */

commit b515981702133b9aaea1aff378493f054c14d46c
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Wed Jun 12 08:09:16 2013 -0700

    console API improvements
    
    Add a higher level console API that opens a tty/console and runs the
    mainloop as well. Rename existing API to console_getfd(). Use these in
    the python binding.
    
    Allow attaching a console peer after container bootup, including if the
    container was launched with -d. This is made possible by allocation of a
    "proxy" pty as the peer when the console is attached to.
    
    Improve handling of SIGWINCH, the pty size will be correctly set at the
    beginning of a session and future changes when using the lxc_console() API
    will be propagated to it as well.
    
    Refactor some common code between lxc_console.c and console.c. The variable
    wait4q (renamed to saw_escape) was static, making the mainloop callback not
    safe across threads. This wasn't a problem when the callback was in the
    non-threaded lxc-console, but now that it is internal to console.c, we have
    to take care of it. This is now contained in a per-tty state structure.
    
    Don't attempt to open /dev/null as the console peer since /dev/null cannot
    be added to the mainloop (epoll_ctl() fails with EPERM). This isn't needed
    to get the console setup (and the log to work) since the case of not having
    a peer at console init time has to be handled to allow for attaching to it
    later.
    
    Move signalfd libc wrapper/replacement to utils.h.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 5078f03..5449a46 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -115,7 +115,7 @@ struct lxc_container {
 		const char *lxcpath, int flags, const char *bdevtype,
 		const char *bdevdata, unsigned long newsize, char **hookargs);
 
-	/* lxcapi_console: allocate a console tty from container @c
+	/* lxcapi_console_getfd: allocate a console tty from container @c
 	 *
 	 * @c        : the running container
 	 * @ttynum   : in : tty number to attempt to allocate or -1 to
@@ -128,7 +128,24 @@ struct lxc_container {
 	 * indicate that it is done with the allocated console so that it can
 	 * be allocated by another caller.
 	 */
-	int (*console)(struct lxc_container *c, int *ttynum, int *masterfd);
+	int (*console_getfd)(struct lxc_container *c, int *ttynum, int *masterfd);
+
+	/* lxcapi_console: allocate and run a console tty from container @c
+	 *
+	 * @c        : the running container
+	 * @ttynum   : tty number to attempt to allocate, -1 to
+	 *             allocate the first available tty, or 0 to allocate
+	 *             the console
+	 * @stdinfd  : fd to read input from
+	 * @stdoutfd : fd to write output to
+	 * @stderrfd : fd to write error output to
+	 * @escape   : the escape character (1 == 'a', 2 == 'b', ...)
+	 *
+	 * Returns 0 on success, -1 on failure. This function will not return
+	 * until the console has been exited by the user.
+	 */
+	int (*console)(struct lxc_container *c, int ttynum,
+		       int stdinfd, int stdoutfd, int stderrfd, int escape);
 
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);

commit 0115f8fd27b1a31d367bb161a121694f92b45e62
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue May 28 15:25:41 2013 -0400

    add console to lxc api
    
    Make lxc_cmd_console() return the fd from the socket connection to the
    caller. This fd keeps the tty slot allocated until the caller closes
    it. Returning the fd allows for a long lived process to close the fd
    and reuse consoles.
    
    Add API function for console allocation.
    
    Create test program for console API.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index bd3d22a..5078f03 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -115,6 +115,21 @@ struct lxc_container {
 		const char *lxcpath, int flags, const char *bdevtype,
 		const char *bdevdata, unsigned long newsize, char **hookargs);
 
+	/* lxcapi_console: allocate a console tty from container @c
+	 *
+	 * @c        : the running container
+	 * @ttynum   : in : tty number to attempt to allocate or -1 to
+	 *                  allocate the first available tty
+	 *             out: the tty number that was allocated
+	 * @masterfd : out: fd refering to the master side of pty
+	 *
+	 * Returns "ttyfd" on success, -1 on failure. The returned "ttyfd" is
+	 * used to keep the tty allocated. The caller should close "ttyfd" to
+	 * indicate that it is done with the allocated console so that it can
+	 * be allocated by another caller.
+	 */
+	int (*console)(struct lxc_container *c, int *ttynum, int *masterfd);
+
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);
 	bool (*reread_cgroups)(struct lxc_container *c);

commit 1897e3bcd36af9f3fe6d3649910a9adb93e5e988
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 17 23:23:17 2013 +0200

    Move container creation fully into the api
    
    1. implement bdev->create:
    
    python and lua: send NULL for bdevtype and bdevspecs.
    They'll want to be updated to pass those in in a way that makes
    sense, but I can't think about that right now.
    
    2. templates: pass --rootfs
    
    If the container is backed by a device which must be mounted (i.e.
    lvm) then pass the actual rootfs mount destination to the
    templates.
    
    Note that the lxc.rootfs can be a mounted block device.  The template
    should actually be installing the rootfs under the path where the
    lxc.rootfs is *mounted*.
    
    Still, some people like to run templates by hand and assume purely
    directory backed containers, so continue to support that use case
    (i.e. if no --rootfs is listed).
    
    Make sure the templates don't re-write lxc.rootfs if it is
    already in the config.  (Most were already checking for that)
    
    3. Replace lxc-create script with lxc_create.c program.
    
    Changelog:
    May 24: when creating a container, create $lxcpath/$name/partial,
    and flock it.  When done, close that file and unlink it.  In
    lxc_container_new() and lxcapi_start(), check for this file.  If
    it is locked, create is ongoing.  If it exists but is not locked,
    create() was killed - remove the container.
    
    May 24: dont disk-lock during lxcapi_create.  The partial lock
    is sufficient.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 3a80d0f..bd3d22a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -12,6 +12,8 @@
 #define LXC_CLONE_SNAPSHOT        (1 << 3)
 #define LXC_CLONE_MAXFLAGS        (1 << 4)
 
+struct bdev_specs;
+
 struct lxc_container {
 	// private fields
 	char *name;
@@ -48,8 +50,10 @@ struct lxc_container {
 	bool (*set_config_item)(struct lxc_container *c, const char *key, const char *value);
 	bool (*destroy)(struct lxc_container *c);
 	bool (*save_config)(struct lxc_container *c, const char *alt_file);
-	bool (*create)(struct lxc_container *c, const char *t, char *const argv[]);
-	bool (*createl)(struct lxc_container *c, const char *t, ...);
+	bool (*create)(struct lxc_container *c, const char *t, const char *bdevtype,
+			struct bdev_specs *specs, char *const argv[]);
+	bool (*createl)(struct lxc_container *c, const char *t, const char *bdevtype,
+			struct bdev_specs *specs, ...);
 	/* send SIGINT to ask container to reboot */
 	bool (*reboot)(struct lxc_container *c);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */

commit 3e625e2d2e12b919dd9590b97badc6108ee67b1a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu May 16 23:03:47 2013 +0200

    lxc-stop: use api, remove lxc_shutdown, extend lxc-stop functionality
    
    implement c->reboot(c) in the api.
    
    Also if the container is not running, return -2.  Currently
    lxc-stop will return 0, so you cannot tell the difference
    between successfull stopping and noop.
    
    Per stgraber's email:
    
     - Remove lxc-shutdown
     - Change lxc-stop so that:
       * Default behaviour is to call shutdown(), wait 15s for STOPPED, if
    not STOPPED, print a message to the user and call stop() [ NOTE:
    actually 60 seconds per followup thread]
       * We have a -r option to reboot the container (with proper check that
    the container indeed rebooted within the next 15s)
       * We have a -s option to shutdown the container without the automatic
    fallback to stop()
       * Add a -k option allowing a user to just kill a container
    (equivalent to old lxc-stop, no shutdown() call and no delay).
    
    and update manpages.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 1ca7519..3a80d0f 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -50,6 +50,8 @@ struct lxc_container {
 	bool (*save_config)(struct lxc_container *c, const char *alt_file);
 	bool (*create)(struct lxc_container *c, const char *t, char *const argv[]);
 	bool (*createl)(struct lxc_container *c, const char *t, ...);
+	/* send SIGINT to ask container to reboot */
+	bool (*reboot)(struct lxc_container *c);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
 	/* clear all network or capability items in the in-memory configuration */

commit df271a59cbfcfbe98fa4bd7af3ae595633539a12
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed May 22 16:24:00 2013 -0500

    lxclock: Replace named sempahore with flock
    
    The problem: if a task is killed while holding a posix semaphore,
    there appears to be no way to have the semaphore be reliably
    autmoatically released.  The only trick which seemed promising
    is to store the pid of the lock holder in some file and have
    later lock seekers check whether that task has died.
    
    Instead of going down that route, this patch switches from a
    named posix semaphore to flock.  The advantage is that when
    the task is killed, its fds are closed and locks are automatically
    released.
    
    The disadvantage of flock is that we can't rely on it to exclude
    threads.  Therefore c->slock must now always be wrapped inside
    c->privlock.
    
    This patch survived basic testing with the lxcapi_create patchset,
    where now killing lxc-create while it was holding the lock did
    not lock up future api commands.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 1c464fe..1ca7519 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -16,8 +16,8 @@ struct lxc_container {
 	// private fields
 	char *name;
 	char *configfile;
-	sem_t *slock;
-	sem_t *privlock;
+	struct lxc_lock *slock;
+	struct lxc_lock *privlock;
 	int numthreads; /* protected by privlock. */
 	struct lxc_conf *lxc_conf; // maybe we'll just want the whole lxc_handler?
 

commit 2acf77955239ec0046451fa16812d2884e6bd19b
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Thu May 23 15:44:39 2013 -0400

    fix memory leaks in cgroup functions
    
    There were several memory leaks in the cgroup functions, notably in the
    success cases.
    
    The cgpath test program was refactored and additional tests added to it.
    It was used in various modes under valgrind to test that the leaks were
    fixed.
    
    Simplify lxc_cgroup_path_get() and cgroup_path_get by having them return a
    char * instead of an int and an output char * argument. The only return
    values ever used were -1 and 0, which are now handled with NULL and non-NULL
    returns respectively.
    
    Use consistent variable names of cgabspath when refering to an absolute path
    to a cgroup subsystem or file, and cgrelpath when refering to a container
    "group/name" within the cgroup heirarchy.
    
    Remove unused subsystem argument to lxc_cmd_get_cgroup_path().
    
    Remove unused #define MAXPRIOLEN
    
    Make template arg to lxcapi_create() const
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 22ccb0b..1c464fe 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -48,8 +48,8 @@ struct lxc_container {
 	bool (*set_config_item)(struct lxc_container *c, const char *key, const char *value);
 	bool (*destroy)(struct lxc_container *c);
 	bool (*save_config)(struct lxc_container *c, const char *alt_file);
-	bool (*create)(struct lxc_container *c, char *t, char *const argv[]);
-	bool (*createl)(struct lxc_container *c, char *t, ...);
+	bool (*create)(struct lxc_container *c, const char *t, char *const argv[]);
+	bool (*createl)(struct lxc_container *c, const char *t, ...);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
 	/* clear all network or capability items in the in-memory configuration */

commit 481624b37b37ffa98b735cf3f94e35d1fbd729e0
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue May 21 13:30:09 2013 -0400

    fix build with --enable-tests
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index bf3168c..22ccb0b 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -103,6 +103,7 @@ struct lxc_container {
 	 *  then the original backing store's size will be used if possible.  Note this
 	 *  only applies to the rootfs.  For any other filesystems, the original size
 	 *  will be duplicated.
+	 * @hookargs: additional arguments to pass to the clone hook script
 	 */
 	struct lxc_container *(*clone)(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags, const char *bdevtype,

commit 9c83a661397456e1455d739bcadfa38f05ce2fe6
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Fri Apr 26 16:01:58 2013 +0200

    lxcapi: Add new get_ips() call
    
    This adds a new get_ips call which takes a family (inet, inet6 or NULL),
    a network interface (or NULL for all) and a scope (0 for global) and returns
    a char** of all the IPs in the container.
    
    This also adds a matching python3 binding (function result is a tuple) and
    deprecates the previous pure-python get_ips() implementation.
    
    WARNING: The python get_ips() call is quite different from the previous
    implementation. The timeout argument has been removed, the family names are
    slightly different (inet/inet6 vs ipv4/ipv6) and an extra scope parameter
    has been added.
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 67fbed4..bf3168c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -58,6 +58,7 @@ struct lxc_container {
 	 * the length which was our would be printed. */
 	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
 	int (*get_keys)(struct lxc_container *c, const char *key, char *retv, int inlen);
+	char** (*get_ips)(struct lxc_container *c, char* interface, char* family, int scope);
 	/*
 	 * get_cgroup_item returns the number of bytes read, or an error (<0).
 	 * If retv NULL or inlen 0 is passed in, then the length of the cgroup

commit 148e91f56799f03c868deca8dcad473983a1a2bf
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 14 16:10:37 2013 -0500

    lxc: add clone hook.
    
    Add a clone hook called from api_clone.  Pass arguments to it from
    lxc_clone.c.
    
    The clone update hook is called while the container's bdev is mounted.
    Information about the container is passed in through environment
    variables LXC_ROOTFS_PATH, LXC_NAME, The LXC_ROOTFS_MOUNT, and
    LXC_CONFIG_FILE.
    
    LXC_ROOTFS_MOUNT=/usr/lib/x86_64-linux-gnu/lxc
    LXC_CONFIG_FILE=/var/lib/lxc/demo3/config
    LXC_ROOTFS_PATH=/var/lib/lxc/demo3/rootfs
    LXC_NAME=demo3
    
    So from the hook, updates to the container should be made under
    $LXC_ROOTFS_MOUNT/ .
    
    The hook also receives command line arguments as follows:
    First argument is container name, second is always 'lxc', third
    is the hook name (always clone), then come the arguments which
    were passed to lxc-clone.  I.e. when I did:
    
    sudo lxc-clone demo2 demo3 -- hey there dude
    
    the arguments passed in were "demo3 lxc clone hey there dude"
    
    I personally would like to drop the first two arguments.  The
    name is available as $LXC_NAME, and the section argument ('lxc')
    is meaningless.  However, doing so risks invalidating existing
    hooks.
    
    Soon analogous create and destroy hooks will be added as well.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index b6bd97c..67fbed4 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -105,7 +105,7 @@ struct lxc_container {
 	 */
 	struct lxc_container *(*clone)(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags, const char *bdevtype,
-		const char *bdevdata, unsigned long newsize);
+		const char *bdevdata, unsigned long newsize, char **hookargs);
 
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);

commit a8428dfa2c6a43ee195f4be3e04a519ca1fc6ec0
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Apr 29 22:09:06 2013 +0200

    introduce lxc_config
    
    It's a tiny program (exported through the api) wrapping the util.c
    helpers for reading /etc/lxc/lxc.conf variables, and replaces
    the kludgy shell duplication in lxc.functions.in
    
    Changelog: Apr 30: address feedback from Dwight
    	(exit error on failure, and use 'lxcpath' as name, not
    	'default_path').
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index a4be753..b6bd97c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -122,6 +122,8 @@ int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);
 const char *lxc_get_default_config_path(void);
+const char *lxc_get_default_lvm_vg(void);
+const char *lxc_get_default_zfs_root(void);
 const char *lxc_get_version(void);
 
 #if 0

commit 9be53773792fc9e8bd173edc3b7ac7e144875387
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 16 08:07:05 2013 -0500

    implement backend drivers and container clone API (v3)
    
    1. commonize waitpid users to use a single helper.  We frequently want
    to run something in a clean namespace, or fork off a script.  This
    lets us keep the function doing fork:(1)exec(2)waitpid simpler.
    
    2. start a blockdev backend implementation.  This will be used for
    mounting, copying, and snapshotting container filesystems.
    
    3. implement btrfs, lvm, directory, and overlayfs backends.
    
    4. For overlayfs, support a new lxc.rootfs format of
    'bdevtype:<extra>'.  This means you can now use overlayfs-based
    containers without using lxc-start-ephemeral, by using
    lxc.rootfs = overlayfs:/readonly-dir:writeable-dir
    
    5. add a set of simple clone testcases
    
    6. Write a new lxc_clone.c based on api clone.
    
    Still to do (there's more, but off top of my head):
    
    1. support zfs, aufs
    2. have clone handle other mount entries (right now it only clones
    the rootfs)
    3. python, lua, and go bindings (not me :)
    4. lxc-destroy: if lvm backing store, check for snapshots of it.
       (what about directories which have overlayfs clones?)
    
    Changes since v2:
    	Initialize random generator when picking new macaddr (reported
    	  by caglar@10ur.org)
    	Fix wrong use of bitmask flags
    	On copy-clone of btrfs, create a subvolume
    	lxc_clone.c: respect the command line usage of the old script
    	lxc-clone(1): update documentation
    	Refuse to try changing backing stores expect to overlayfs, as
    	  it is not implemented (yet) anyway.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    
    Conflicts:
    	src/lxc/utils.h

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index de9854c..a4be753 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -1,9 +1,17 @@
+#ifndef __LXC_CONTAINER_H
+#define __LXC_CONTAINER_H
 #include "lxclock.h"
 #include <stdlib.h>
 #include <malloc.h>
 
 #include <stdbool.h>
 
+#define LXC_CLONE_KEEPNAME        (1 << 0)
+#define LXC_CLONE_COPYHOOKS       (1 << 1)
+#define LXC_CLONE_KEEPMACADDR     (1 << 2)
+#define LXC_CLONE_SNAPSHOT        (1 << 3)
+#define LXC_CLONE_MAXFLAGS        (1 << 4)
+
 struct lxc_container {
 	// private fields
 	char *name;
@@ -72,6 +80,33 @@ struct lxc_container {
 	const char *(*get_config_path)(struct lxc_container *c);
 	bool (*set_config_path)(struct lxc_container *c, const char *path);
 
+	/*
+	 * @c: the original container
+	 * @newname: new name for the container.  If NULL, the same name is used, and
+	 *  a new lxcpath MUST be specified.
+	 * @lxcpath: lxcpath in which to create the new container.  If NULL, then the
+	 *  original container's lxcpath will be used.  (Shoudl we use the default
+	 *  instead?)
+	 * @flags: additional flags to modify cloning behavior.
+	 *  LXC_CLONE_KEEPNAME: don't edit the rootfs to change the hostname.
+	 *  LXC_CLONE_COPYHOOKS: copy all hooks into the container dir
+	 *  LXC_CLONE_KEEPMACADDR: don't change the mac address on network interfaces.
+	 *  LXC_CLONE_SNAPSHOT: snapshot the original filesystem(s).  If @devtype was not
+	 *   specified, then do so with the native bdevtype if possible, else use an
+	 *   overlayfs.
+	 * @bdevtype: optionally force the cloned bdevtype to a specified plugin.  By
+	 *  default the original  is used (subject to snapshot requirements).
+	 * @bdevdata: information about how to create the new storage (i.e. fstype and
+	 *  fsdata)
+	 * @newsize: in case of a block device backing store, an optional size.  If 0,
+	 *  then the original backing store's size will be used if possible.  Note this
+	 *  only applies to the rootfs.  For any other filesystems, the original size
+	 *  will be duplicated.
+	 */
+	struct lxc_container *(*clone)(struct lxc_container *c, const char *newname,
+		const char *lxcpath, int flags, const char *bdevtype,
+		const char *bdevdata, unsigned long newsize);
+
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);
 	bool (*reread_cgroups)(struct lxc_container *c);
@@ -93,3 +128,4 @@ const char *lxc_get_version(void);
 char ** lxc_get_valid_keys();
 char ** lxc_get_valid_values(char *key);
 #endif
+#endif

commit b6b918a1d4f91da7bb41da202112ac8fddf947f7
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Mar 11 11:57:51 2013 -0400

    API: export lxc_get_version()
    
    Signed-off-by: Stéphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index f0c4565..de9854c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -87,6 +87,7 @@ int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);
 const char *lxc_get_default_config_path(void);
+const char *lxc_get_version(void);
 
 #if 0
 char ** lxc_get_valid_keys();

commit 67e571de63a8e465dc8f1b17e16744a1d3fb552c
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Tue Feb 19 11:48:56 2013 -0500

    Introduce --lxcpath cmdline option, and make default_lxc_path() return const char *
    
    For the lxc-* C binaries, introduce a -P|--lxcpath command line option
    to override the system default.
    
    With this, I can
    
        lxc-create -t ubuntu -n r1
        lxc-create -t ubuntu -n r1 -P /home/ubuntu/lxcbase
        lxc-start -n r1 -d
        lxc-start -n r1 -d -P /home/ubuntu/lxcbase
        lxc-console -n r1 -d -P /home/ubuntu/lxcbase
        lxc-stop -n r1
    
    all working with the right containers (module cgroup stuff).
    
    To do:
        * lxc monitor needs to be made to handle cgroups.
          This is another very invasive one.  I started doing this as
          a part of this set, but that gets hairy, so I'm sending this
          separately.  Note that lxc-wait and lxc-monitor don't work
          without this, and there may be niggles in what I said works
          above - since start.c is doing lxc_monitor_send_state etc
          to the shared abstract unix domain socket.
        * Need to handle the cgroup conflicts.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 46c46c5..f0c4565 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -86,7 +86,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);
-char *lxc_get_default_config_path(void);
+const char *lxc_get_default_config_path(void);
 
 #if 0
 char ** lxc_get_valid_keys();

commit 83c98d825e4e644b18276dde5deaa555ee36b629
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Feb 11 17:31:39 2013 -0500

    Update Lua API
    
    Add [gs]et_config_path from API to Lua binding. Add additional optional
    parameter to container_new(). Add tests for these new Lua API bindings.
    Commit 2a59a681 changed the meaning of lxc_path_get() in the binding,
    causing lua script breakage. Reinstate original behavior of
    lxc_path_get() and rename it to lxc_default_config_path_get() to make
    its intent clearer.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index de802a8..46c46c5 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -86,6 +86,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);
+char *lxc_get_default_config_path(void);
 
 #if 0
 char ** lxc_get_valid_keys();

commit afeecbba0359d2b4404cdf896e6b6d0b5a8443b0
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Fri Feb 8 16:06:32 2013 -0600

    lxc api: fix some config_path oddities
    
    1. When calling c->set_config_path(), update configfile.  I.e. if we
    are setting the config_path to /var/lib/lxc, then the configfile should
    be changed to /var/lib/lxc/$container/config
    
    2. Add an optional configpath argument to lxc_container_new.  If NULL,
    then the default will be used (as before).  If set, then the passed-in
    path will be used.  This way you can do
    
    	c1 = lxc.Container("r1", "/var/lib/lxc");
    	c2 = lxc.Container("r2", "/home/user/lxcbase");
    
    (Note I did *not* implement the python or lua binding to pass that
    argument along)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 32c501e..de802a8 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -82,7 +82,7 @@ struct lxc_container {
 #endif
 };
 
-struct lxc_container *lxc_container_new(const char *name);
+struct lxc_container *lxc_container_new(const char *name, const char *configpath);
 int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);

commit 2a59a68183e55e38beedb6442938e31eb7d4749c
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Wed Feb 6 15:11:19 2013 -0600

    Switch from use of LXCPATH to a configurable default_lxc_path
    
    Here is a patch to introduce a configurable system-wide
    lxcpath.  It seems to work with lxc-create, lxc-start,
    and basic python3 lxc usage through the api.
    
    For shell functions, a new /usr/share/lxc/lxc.functions is
    introduced which sets some of the basic global variables,
    including evaluating the right place for lxc_path.
    
    I have not converted any of the other python code, as I was
    not sure where we should keep the common functions (i.e.
    for now just default_lxc_path()).
    
    configure.ac: add an option for setting the global config file name.
    utils: add a default_lxc_path() function
    Use default_lxc_path in .c files
    define get_lxc_path() and set_lxc_path() in C api
    use get_lxc_path() in lua api
    create sh helper for getting default path from config file
    fix up scripts to use lxc.functions
    
    Changelog:
      feb6:
    	fix lxc_path in lxc.functions
    	utils.c: as Dwight pointed out, don't close a NULL fin.
    	utils.c: fix the parsing of lxcpath line
    	lxc-start: print which rcfile we are using
    	commands.c: As Dwight alluded to, the sockname handling was just
    	   ridiculous.  Clean that up.
    	use Dwight's recommendation for lxc.functions path: $datadir/lxc
    	make lxccontainer->get_config_path() return const char *
    		Per Dwight's suggestion, much nicer than returning strdup.
      feb6 (v2):
            lxccontainer: set c->config_path before using it.
    	convert legacy lxc-ls
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index a6fdb2b..32c501e 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -18,6 +18,8 @@ struct lxc_container {
 	int error_num;
 	int daemonize;
 
+	char *config_path;
+
 	bool (*is_defined)(struct lxc_container *c);  // did /var/lib/lxc/$name/config exist
 	const char *(*state)(struct lxc_container *c);
 	bool (*is_running)(struct lxc_container *c);  // true so long as defined and not stopped
@@ -58,6 +60,18 @@ struct lxc_container {
 	int (*get_cgroup_item)(struct lxc_container *c, const char *subsys, char *retv, int inlen);
 	bool (*set_cgroup_item)(struct lxc_container *c, const char *subsys, const char *value);
 
+	/*
+	 * Each container can have a custom configuration path.  However
+	 * by default it will be set to either the LXCPATH configure
+	 * variable, or the lxcpath value in the LXC_GLOBAL_CONF configuration
+	 * file (i.e. /etc/lxc/lxc.conf).
+	 * You can change the value for a specific container with
+	 * set_config_path().  Note there is no other way to specify this in
+	 * general at the moment.
+	 */
+	const char *(*get_config_path)(struct lxc_container *c);
+	bool (*set_config_path)(struct lxc_container *c, const char *path);
+
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);
 	bool (*reread_cgroups)(struct lxc_container *c);

commit 794dd12099da53adec33e8291f0f470629f8b8f6
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Thu Dec 6 18:41:15 2012 -0600

    api: add set_cgroup_item and get_cgroup_item (to c api)
    
    set_cgroup_item takes a pointer to a running container, a cgroup subsystem
    name, and a char *value and it mimicks
    	'lxc-cgroup -n containername subsys value'
    get_cgroup_item takes a pointer to a running container, a a cgroup
    subsystem name, a destination value * and the length of the value being
    sent in, and returns the length of what was read from the cgroup file.
    If a 0 len is passed in, then the length of the file is returned.  So
    you can do
    
    	len = c->get_cgroup_item(c, "devices.list", NULL, 0);
    	v = malloc(len+1);
    	ret = c->get_cgroup_item(c, "devices.list", v, len);
    
    to read the whole file.
    
    This patch also disables the lxc-init part of the startone test, which
    was failing because lxc-init has been moved due to multiarch issues.
    The test is salvagable, but saving it was beyond this effort.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 9c9296c..a6fdb2b 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -48,6 +48,15 @@ struct lxc_container {
 	 * the length which was our would be printed. */
 	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
 	int (*get_keys)(struct lxc_container *c, const char *key, char *retv, int inlen);
+	/*
+	 * get_cgroup_item returns the number of bytes read, or an error (<0).
+	 * If retv NULL or inlen 0 is passed in, then the length of the cgroup
+	 * file will be returned.  *   Otherwise it will return the # of bytes read.
+	 * If inlen is less than the number of bytes available, then the returned
+	 * value will be inlen, not the full available size of the file.
+	 */
+	int (*get_cgroup_item)(struct lxc_container *c, const char *subsys, char *retv, int inlen);
+	bool (*set_cgroup_item)(struct lxc_container *c, const char *subsys, const char *value);
 
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);

commit 12a50cc6ab5c8a4aa0bcb7ddcd7095265f7bb62b
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 15:28:14 2012 -0500

    Make config api items const
    
    This makes it easier to write a binding, and presents a cleaner API. Use
    strdupa in a few places to get mutable strings for tokenizing / parsing.
    Also change the argv type in lxcapi_start and lxcapi_create to match
    that of execv(3).
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 9e4267a..9c9296c 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -24,9 +24,9 @@ struct lxc_container {
 	bool (*freeze)(struct lxc_container *c);
 	bool (*unfreeze)(struct lxc_container *c);
 	pid_t (*init_pid)(struct lxc_container *c);
-	bool (*load_config)(struct lxc_container *c, char *alt_file);
+	bool (*load_config)(struct lxc_container *c, const char *alt_file);
 	/* The '...' is the command line.  If provided, it must be ended with a NULL */
-	bool (*start)(struct lxc_container *c, int useinit, char ** argv);
+	bool (*start)(struct lxc_container *c, int useinit, char * const argv[]);
 	bool (*startl)(struct lxc_container *c, int useinit, ...);
 	bool (*stop)(struct lxc_container *c);
 	void (*want_daemonize)(struct lxc_container *c);
@@ -34,20 +34,20 @@ struct lxc_container {
 	char *(*config_file_name)(struct lxc_container *c);
 	// for wait, timeout == -1 means wait forever, timeout == 0 means don't wait.
 	// otherwise timeout is seconds to wait.
-	bool (*wait)(struct lxc_container *c, char *state, int timeout);
-	bool (*set_config_item)(struct lxc_container *c, char *key, char *value);
+	bool (*wait)(struct lxc_container *c, const char *state, int timeout);
+	bool (*set_config_item)(struct lxc_container *c, const char *key, const char *value);
 	bool (*destroy)(struct lxc_container *c);
-	bool (*save_config)(struct lxc_container *c, char *alt_file);
-	bool (*create)(struct lxc_container *c, char *t, char **argv);
+	bool (*save_config)(struct lxc_container *c, const char *alt_file);
+	bool (*create)(struct lxc_container *c, char *t, char *const argv[]);
 	bool (*createl)(struct lxc_container *c, char *t, ...);
 	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
 	bool (*shutdown)(struct lxc_container *c, int timeout);
 	/* clear all network or capability items in the in-memory configuration */
-	bool (*clear_config_item)(struct lxc_container *c, char *key);
+	bool (*clear_config_item)(struct lxc_container *c, const char *key);
 	/* print a config item to a in-memory string allocated by the caller.  Return
 	 * the length which was our would be printed. */
-	int (*get_config_item)(struct lxc_container *c, char *key, char *retv, int inlen);
-	int (*get_keys)(struct lxc_container *c, char *key, char *retv, int inlen);
+	int (*get_config_item)(struct lxc_container *c, const char *key, char *retv, int inlen);
+	int (*get_keys)(struct lxc_container *c, const char *key, char *retv, int inlen);
 
 #if 0
 	bool (*commit_cgroups)(struct lxc_container *c);
@@ -59,7 +59,7 @@ struct lxc_container {
 #endif
 };
 
-struct lxc_container *lxc_container_new(char *name);
+struct lxc_container *lxc_container_new(const char *name);
 int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
 int lxc_get_wait_states(const char **states);

commit b45a7402bf5e6a0c4d03c5a428670bad7c1b4c8e
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 15:57:53 2012 -0500

    Use autoconf LXCPATH instead of hardcoded LXCDIR
    
    LXCDIR is only used in lxc_container_new, whereas LXCPATH is used throughout
    the rest of lxc, and even in the same file as lxc_container_new (for example
    create_container_dir()).
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index cad31ee..9e4267a 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -18,7 +18,6 @@ struct lxc_container {
 	int error_num;
 	int daemonize;
 
-#define LXCDIR "/var/lib/lxc"
 	bool (*is_defined)(struct lxc_container *c);  // did /var/lib/lxc/$name/config exist
 	const char *(*state)(struct lxc_container *c);
 	bool (*is_running)(struct lxc_container *c);  // true so long as defined and not stopped

commit 4a7c7daa260467f3c9b234495bf3283fe31c01cb
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Sep 4 14:18:03 2012 -0500

    Fix passing non-const char* in for const char*
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 6320633..cad31ee 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -63,7 +63,7 @@ struct lxc_container {
 struct lxc_container *lxc_container_new(char *name);
 int lxc_container_get(struct lxc_container *c);
 int lxc_container_put(struct lxc_container *c);
-int lxc_get_wait_states(char **states);
+int lxc_get_wait_states(const char **states);
 
 #if 0
 char ** lxc_get_valid_keys();

commit 72d0e1cb2facaa4b8ba2f15e311d6bb9491badb7
Author: Stéphane Graber <stgraber@ubuntu.com>
Date:   Mon Aug 27 18:53:00 2012 -0400

    Merge the liblxc API work by Serge Hallyn.
    
    This turns liblxc into a public library implementing a container structure.
    The container structure is meant to cover most LXC commands and can easily be
    used to write bindings in other programming languages.
    
    More information on the new functions can be found in src/lxc/lxccontainer.h
    Test programs using the API can also be found in src/tests/
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stéphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
new file mode 100644
index 0000000..6320633
--- /dev/null
+++ b/src/lxc/lxccontainer.h
@@ -0,0 +1,71 @@
+#include "lxclock.h"
+#include <stdlib.h>
+#include <malloc.h>
+
+#include <stdbool.h>
+
+struct lxc_container {
+	// private fields
+	char *name;
+	char *configfile;
+	sem_t *slock;
+	sem_t *privlock;
+	int numthreads; /* protected by privlock. */
+	struct lxc_conf *lxc_conf; // maybe we'll just want the whole lxc_handler?
+
+	// public fields
+	char *error_string;
+	int error_num;
+	int daemonize;
+
+#define LXCDIR "/var/lib/lxc"
+	bool (*is_defined)(struct lxc_container *c);  // did /var/lib/lxc/$name/config exist
+	const char *(*state)(struct lxc_container *c);
+	bool (*is_running)(struct lxc_container *c);  // true so long as defined and not stopped
+	bool (*freeze)(struct lxc_container *c);
+	bool (*unfreeze)(struct lxc_container *c);
+	pid_t (*init_pid)(struct lxc_container *c);
+	bool (*load_config)(struct lxc_container *c, char *alt_file);
+	/* The '...' is the command line.  If provided, it must be ended with a NULL */
+	bool (*start)(struct lxc_container *c, int useinit, char ** argv);
+	bool (*startl)(struct lxc_container *c, int useinit, ...);
+	bool (*stop)(struct lxc_container *c);
+	void (*want_daemonize)(struct lxc_container *c);
+	// Return current config file name.  The result is strdup()d, so free the result.
+	char *(*config_file_name)(struct lxc_container *c);
+	// for wait, timeout == -1 means wait forever, timeout == 0 means don't wait.
+	// otherwise timeout is seconds to wait.
+	bool (*wait)(struct lxc_container *c, char *state, int timeout);
+	bool (*set_config_item)(struct lxc_container *c, char *key, char *value);
+	bool (*destroy)(struct lxc_container *c);
+	bool (*save_config)(struct lxc_container *c, char *alt_file);
+	bool (*create)(struct lxc_container *c, char *t, char **argv);
+	bool (*createl)(struct lxc_container *c, char *t, ...);
+	/* send SIGPWR.  if timeout is not 0 or -1, do a hard stop after timeout seconds */
+	bool (*shutdown)(struct lxc_container *c, int timeout);
+	/* clear all network or capability items in the in-memory configuration */
+	bool (*clear_config_item)(struct lxc_container *c, char *key);
+	/* print a config item to a in-memory string allocated by the caller.  Return
+	 * the length which was our would be printed. */
+	int (*get_config_item)(struct lxc_container *c, char *key, char *retv, int inlen);
+	int (*get_keys)(struct lxc_container *c, char *key, char *retv, int inlen);
+
+#if 0
+	bool (*commit_cgroups)(struct lxc_container *c);
+	bool (*reread_cgroups)(struct lxc_container *c);
+	// question with clone: how do we handle non-standard config file in orig?
+	struct lxc_container (*clone)(struct container *c);
+	int (*ns_attach)(struct lxc_container *c, int ns_mask);
+	// we'll need some plumbing to support lxc-console
+#endif
+};
+
+struct lxc_container *lxc_container_new(char *name);
+int lxc_container_get(struct lxc_container *c);
+int lxc_container_put(struct lxc_container *c);
+int lxc_get_wait_states(char **states);
+
+#if 0
+char ** lxc_get_valid_keys();
+char ** lxc_get_valid_values(char *key);
+#endif
