commit 157561c7fec70ac439ac879ec8b9a56d74e557fc
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 17:19:48 2016 -0700

    Changed return value from 'int' to 'bool'

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c4b55b1..28c434a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -100,8 +100,8 @@ static bool container_destroy(struct lxc_container *c);
 static bool get_snappath_dir(struct lxc_container *c, char *snappath);
 static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
 static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);
-static int lxcapi_export_container(struct lxc_container *c, const char *detailsfile);
-static int lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
+// static int lxcapi_export_container(struct lxc_container *c, const char *detailsfile);
+// static int lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
 
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
@@ -321,6 +321,7 @@ int lxc_container_put(struct lxc_container *c)
 
 static bool do_lxcapi_is_defined(struct lxc_container *c)
 {
+	printf("CHECK LXX-IS-DEFINED\n");
 	struct stat statbuf;
 	bool ret = false;
 	int statret;
@@ -3722,24 +3723,30 @@ WRAP_API(bool, lxcapi_snapshot_destroy_all)
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-static int do_lxcapi_export_container(struct lxc_container *c, const char *detailsfile)
+static bool do_lxcapi_export_container(struct lxc_container *c, const char *detailsfile)
 {
+	if (!c || !c->name || !c->config_path)
+		return false;
+
 	printf("EXPORT CONTAINER\n");
-	return 5;
+	return true;
 }
 
-WRAP_API_1(int, lxcapi_export_container, const char *)
+WRAP_API_1(bool, lxcapi_export_container, const char *)
 
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-static int do_lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile)
+static bool do_lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile)
 {
+	if (!c || !c->name || !c->config_path)
+		return false;
+
 	printf("EXPORT SNAPSHOT\n");
-	return 0;
+	return true;
 }
 
-WRAP_API_2(int, lxcapi_export_snapshot, const char *, const char *)
+WRAP_API_2(bool, lxcapi_export_snapshot, const char *, const char *)
 
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------

commit b2c9f2dc8c9b0165975cfa66690a153881847b21
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 15:50:50 2016 -0700

    Fixed memory leak

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fc5f8ca..c4b55b1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -100,6 +100,8 @@ static bool container_destroy(struct lxc_container *c);
 static bool get_snappath_dir(struct lxc_container *c, char *snappath);
 static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
 static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);
+static int lxcapi_export_container(struct lxc_container *c, const char *detailsfile);
+static int lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile);
 
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
@@ -3722,7 +3724,7 @@ WRAP_API(bool, lxcapi_snapshot_destroy_all)
 
 static int do_lxcapi_export_container(struct lxc_container *c, const char *detailsfile)
 {
-	fprintf(stderr, "EXPORT CONTAINER\n");
+	printf("EXPORT CONTAINER\n");
 	return 5;
 }
 
@@ -3733,7 +3735,7 @@ WRAP_API_1(int, lxcapi_export_container, const char *)
 
 static int do_lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile)
 {
-	fprintf(stderr, "EXPORT SNAPSHOT\n");
+	printf("EXPORT SNAPSHOT\n");
 	return 0;
 }
 
@@ -3742,17 +3744,6 @@ WRAP_API_2(int, lxcapi_export_snapshot, const char *, const char *)
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-static int do_lxc_test(struct lxc_container *c)
-{
-	fprintf(stderr, "TEST\n");
-	return 0;
-}
-
-WRAP_API(int, lxc_test)
-
-//-----------------------------------------------------------------------------
-//-----------------------------------------------------------------------------
-
 static bool do_lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
@@ -4191,7 +4182,6 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 	c->migrate = lxcapi_migrate;
-	c->test = lxc_test;
 
 	return c;
 

commit 09aa43c0c14c691b1e9ac165a86431e28eca0cf0
Author: Qingwei Lan <qingweilan@gmail.com>
Date:   Fri May 20 01:34:46 2016 -0700

    API test, didn't work out

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8bd9b8e..fc5f8ca 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3717,6 +3717,42 @@ static bool do_lxcapi_snapshot_destroy_all(struct lxc_container *c)
 
 WRAP_API(bool, lxcapi_snapshot_destroy_all)
 
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+static int do_lxcapi_export_container(struct lxc_container *c, const char *detailsfile)
+{
+	fprintf(stderr, "EXPORT CONTAINER\n");
+	return 5;
+}
+
+WRAP_API_1(int, lxcapi_export_container, const char *)
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+static int do_lxcapi_export_snapshot(struct lxc_container *c, const char *snapshotname, const char *detailsfile)
+{
+	fprintf(stderr, "EXPORT SNAPSHOT\n");
+	return 0;
+}
+
+WRAP_API_2(int, lxcapi_export_snapshot, const char *, const char *)
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+static int do_lxc_test(struct lxc_container *c)
+{
+	fprintf(stderr, "TEST\n");
+	return 0;
+}
+
+WRAP_API(int, lxc_test)
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
 static bool do_lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
@@ -4145,6 +4181,8 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->snapshot_restore = lxcapi_snapshot_restore;
 	c->snapshot_destroy = lxcapi_snapshot_destroy;
 	c->snapshot_destroy_all = lxcapi_snapshot_destroy_all;
+	c->export_container = lxcapi_export_container;
+	c->export_snapshot = lxcapi_export_snapshot;
 	c->may_control = lxcapi_may_control;
 	c->add_device_node = lxcapi_add_device_node;
 	c->remove_device_node = lxcapi_remove_device_node;
@@ -4153,6 +4191,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 	c->migrate = lxcapi_migrate;
+	c->test = lxc_test;
 
 	return c;
 

commit 9d928ec50fd75f7f392c7978395ec755650587f3
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri May 6 18:19:16 2016 +0000

    c/r: rearrange things to pass struct migrate_opts all the way down
    
    If we don't do this, we'll end up changing the function signatures for the
    internal __criu_* functions each time we add a new parameter, which will
    get very annoying very quickly. Since we already have the user's arguments
    struct, let's just pass that all the way down.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 50cfc69..8bd9b8e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3968,13 +3968,13 @@ static int do_lxcapi_migrate(struct lxc_container *c, unsigned int cmd,
 
 	switch (cmd) {
 	case MIGRATE_PRE_DUMP:
-		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir, opts->pageserver_address, opts->pageserver_port);
+		ret = !__criu_pre_dump(c, opts);
 		break;
 	case MIGRATE_DUMP:
-		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir, opts->pageserver_address, opts->pageserver_port);
+		ret = !__criu_dump(c, opts);
 		break;
 	case MIGRATE_RESTORE:
-		ret = !__criu_restore(c, opts->directory, opts->verbose);
+		ret = !__criu_restore(c, opts);
 		break;
 	default:
 		ERROR("invalid migrate command %u", cmd);

commit 222306afba0067f99acf422728196b5e8122f760
Author: Leonid Isaev <leonid.isaev@jila.colorado.edu>
Date:   Thu Apr 21 13:20:39 2016 -0600

    Initialize a pointer in split_init_cmd() to avoid gcc warnings
    
    gcc -Wall warns about uninitialized variables (-Wmaybe-uninitialized), and
    -Werror makes it fatal. This change allows the build to succeed by NULL'ifying
    the pointer passed to strtok_r().
    
    Note that strtok_r(3) anyway ignores a non-NULL arg3 pointer on the 1st call
    with non-NULL arg1 string.
    
    Signed-off-by: Leonid Isaev <leonid.isaev@jila.colorado.edu>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9f12ca2..50cfc69 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -670,7 +670,7 @@ static char **split_init_cmd(const char *incmd)
 {
 	size_t len;
 	int nargs = 0;
-	char *copy, *p, *saveptr;
+	char *copy, *p, *saveptr = NULL;
 	char **argv;
 
 	if (!incmd)

commit 763429b6bf45991c4171ee3434013769e5e99063
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Tue Apr 5 23:53:49 2016 +0200

    add more error handling + cleanup copy_storage()
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a6003a6..9f12ca2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2829,7 +2829,8 @@ bool should_default_to_snapshot(struct lxc_container *c0,
 }
 
 static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
-		const char *newtype, int flags, const char *bdevdata, uint64_t newsize)
+			const char *newtype, int flags, const char *bdevdata,
+			uint64_t newsize)
 {
 	struct bdev *bdev;
 	int need_rdep;
@@ -2837,38 +2838,53 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	if (should_default_to_snapshot(c0, c))
 		flags |= LXC_CLONE_SNAPSHOT;
 
-	bdev = bdev_copy(c0, c->name, c->config_path, newtype, flags,
-			bdevdata, newsize, &need_rdep);
+	bdev = bdev_copy(c0, c->name, c->config_path, newtype, flags, bdevdata,
+			 newsize, &need_rdep);
 	if (!bdev) {
-		ERROR("Error copying storage");
+		ERROR("Error copying storage.");
 		return -1;
 	}
+
+	/* Set new rootfs. */
 	free(c->lxc_conf->rootfs.path);
 	c->lxc_conf->rootfs.path = strdup(bdev->src);
+
+	/* Set new bdev type. */
 	free(c->lxc_conf->rootfs.bdev_type);
 	c->lxc_conf->rootfs.bdev_type = strdup(bdev->type);
 	bdev_put(bdev);
+
 	if (!c->lxc_conf->rootfs.path) {
-		ERROR("Out of memory while setting storage path");
+		ERROR("Out of memory while setting storage path.");
+		return -1;
+	}
+	if (!c->lxc_conf->rootfs.bdev_type) {
+		ERROR("Out of memory while setting rootfs backend.");
 		return -1;
 	}
-	// We will simply append a new lxc.rootfs entry to the unexpanded config
+
+	/* Append a new lxc.rootfs entry to the unexpanded config. */
 	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs", false);
-	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs", c->lxc_conf->rootfs.path)) {
-		ERROR("Error saving new rootfs to cloned config");
+	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs",
+					 c->lxc_conf->rootfs.path)) {
+		ERROR("Error saving new rootfs to cloned config.");
 		return -1;
 	}
+
+	/* Append a new lxc.rootfs.backend entry to the unexpanded config. */
 	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs.backend", false);
-	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs.backend", c->lxc_conf->rootfs.bdev_type)) {
-		ERROR("Error saving new rootfs to cloned config");
+	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs.backend",
+					 c->lxc_conf->rootfs.bdev_type)) {
+		ERROR("Error saving new rootfs backend to cloned config.");
 		return -1;
 	}
+
 	if (flags & LXC_CLONE_SNAPSHOT)
 		copy_rdepends(c, c0);
 	if (need_rdep) {
 		if (!add_rdepends(c, c0))
 			WARN("Error adding reverse dependency from %s to %s",
-				c->name, c0->name);
+			     c->name, c0->name);
 	}
 
 	mod_all_rdeps(c, true);

commit 8869eb5f8358b61f3e9e2cf7540311dc46fb4b4e
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Tue Apr 5 20:43:02 2016 +0200

    set lxc.rootfs.backend on copy/snapshot as well
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 29cbd33..a6003a6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2845,6 +2845,8 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	}
 	free(c->lxc_conf->rootfs.path);
 	c->lxc_conf->rootfs.path = strdup(bdev->src);
+	free(c->lxc_conf->rootfs.bdev_type);
+	c->lxc_conf->rootfs.bdev_type = strdup(bdev->type);
 	bdev_put(bdev);
 	if (!c->lxc_conf->rootfs.path) {
 		ERROR("Out of memory while setting storage path");
@@ -2856,6 +2858,11 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		ERROR("Error saving new rootfs to cloned config");
 		return -1;
 	}
+	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs.backend", false);
+	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs.backend", c->lxc_conf->rootfs.bdev_type)) {
+		ERROR("Error saving new rootfs to cloned config");
+		return -1;
+	}
 	if (flags & LXC_CLONE_SNAPSHOT)
 		copy_rdepends(c, c0);
 	if (need_rdep) {

commit 39460be89e946c9fbce3c4553b1d9d24d310365d
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Tue Apr 5 19:23:12 2016 +0200

    set lxc.rootfs.backend on container creation
    
    Since specifying lxc.rootfs.backend can lead to performance improvements we
    always set it during container creation.
    
    This also fixes a bug. do_bdev_create() tried to be smart and retrieve the lower
    directory when bdev->type == overlayfs or aufs thereby cutting the path.
    However, this operation is done in ovl_mount() and aufs_mount() and both
    functions need the full src path for this. The bug didn't show before because
    when creating a overlayfs container with e.g.:
    
    	lxc-create -n c -t busybox -B overlayfs
    
    still left bdev->type set to dir and so the code for retrieving the lower dir in
    do_bdev_create() was skipped. But by setting lxc.rootfs.backend on container
    creation we force bdev->type to be set to e.g. overlayfs and the code gets
    executed thereby exposing the bug.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5c6d499..29cbd33 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1037,6 +1037,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	}
 
 	do_lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+	do_lxcapi_set_config_item(c, "lxc.rootfs.backend", bdev->type);
 
 	/* if we are not root, chown the rootfs dir to root in the
 	 * target uidmap */
@@ -1076,7 +1077,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool need_
 	}
 
 	if (pid == 0) { // child
-		char *patharg, *namearg, *rootfsarg, *src;
+		char *patharg, *namearg, *rootfsarg;
 		struct bdev *bdev = NULL;
 		int i;
 		int ret, len, nargs = 0;
@@ -1087,18 +1088,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool need_
 			exit(1);
 		}
 
-		src = c->lxc_conf->rootfs.path;
-		/*
-		 * for an overlay create, what the user wants is the template to fill
-		 * in what will become the readonly lower layer.  So don't mount for
-		 * the template
-		 */
-		if (strncmp(src, "overlayfs:", 10) == 0)
-			src = ovl_getlower(src+10);
-		if (strncmp(src, "aufs:", 5) == 0)
-			src = ovl_getlower(src+5);
-
-		bdev = bdev_init(c->lxc_conf, src, c->lxc_conf->rootfs.mount, NULL);
+		bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 		if (!bdev) {
 			ERROR("Error opening rootfs");
 			exit(1);

commit 74eb576cef2f775ed77d2a7909057b1a09540065
Author: Niklas Eiling <niklas.eiling@rwth-aachen.de>
Date:   Wed Mar 30 15:39:45 2016 +0200

    fixed indentation and comments
    
    Signed-off-by: Niklas Eiling <niklas.eiling@rwth-aachen.de>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 81e1cdf..5c6d499 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3955,12 +3955,10 @@ static int do_lxcapi_migrate(struct lxc_container *c, unsigned int cmd,
 
 	switch (cmd) {
 	case MIGRATE_PRE_DUMP:
-		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir,
-                               opts->pageserver_address, opts->pageserver_port);
+		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir, opts->pageserver_address, opts->pageserver_port);
 		break;
 	case MIGRATE_DUMP:
-		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir,
-                           opts->pageserver_address, opts->pageserver_port);
+		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir, opts->pageserver_address, opts->pageserver_port);
 		break;
 	case MIGRATE_RESTORE:
 		ret = !__criu_restore(c, opts->directory, opts->verbose);

commit 4c0c0319a5baa86a4db8e80bbe149ee5bd8c9816
Author: Niklas Eiling <niklas.eiling@rwth-aachen.de>
Date:   Wed Mar 30 12:32:02 2016 +0200

    c/r: support for the criu pageserver
    this enables lxc to perform "disk-less migrations" where memory pages are sent directly to the destination machine instead of being written to the sources filesystem first.
    For this, the migrate_opts struct has been added the strings "pageserver_address" and "pageserver_port" so that criu can be told where to look for a pageserver.
    
    Signed-off-by: Niklas Eiling <niklas.eiling@rwth-aachen.de>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f5a44d0..81e1cdf 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3955,10 +3955,12 @@ static int do_lxcapi_migrate(struct lxc_container *c, unsigned int cmd,
 
 	switch (cmd) {
 	case MIGRATE_PRE_DUMP:
-		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir);
+		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir,
+                               opts->pageserver_address, opts->pageserver_port);
 		break;
 	case MIGRATE_DUMP:
-		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir);
+		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir,
+                           opts->pageserver_address, opts->pageserver_port);
 		break;
 	case MIGRATE_RESTORE:
 		ret = !__criu_restore(c, opts->directory, opts->verbose);

commit 25086a5fe4f4b8a000e4ca2d184efd3ed7810c65
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Tue Mar 29 08:50:27 2016 +0200

    better naming for mmap helpers
    
    Rename lxc_mmap()/lxc_munmap() to lxc_strmmap()/lxc_strmunmap().
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8e2f413..f5a44d0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2164,7 +2164,7 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 
 			if (fbuf.st_size != 0) {
 
-				buf = lxc_mmap(NULL, fbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+				buf = lxc_strmmap(NULL, fbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
 				if (buf == MAP_FAILED) {
 					SYSERROR("Failed to create mapping %s", path);
 					close(fd);
@@ -2177,7 +2177,7 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 					bytes += len;
 				}
 
-				lxc_munmap(buf, fbuf.st_size);
+				lxc_strmunmap(buf, fbuf.st_size);
 				if (ftruncate(fd, fbuf.st_size - bytes) < 0) {
 					SYSERROR("Failed to truncate file %s", path);
 					close(fd);

commit aeea34d70951c0b9109fd69e92954e882bcf4d88
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Sun Mar 27 18:42:24 2016 +0200

    use lxc_mmap() and lxc_munmap()
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ab48fb5..8e2f413 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2163,13 +2163,8 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 			}
 
 			if (fbuf.st_size != 0) {
-				/* write terminating \0-byte to file */
-				if (pwrite(fd, "", 1, fbuf.st_size) <= 0) {
-					close(fd);
-					goto out;
-				}
 
-				buf = mmap(NULL, fbuf.st_size + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+				buf = lxc_mmap(NULL, fbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
 				if (buf == MAP_FAILED) {
 					SYSERROR("Failed to create mapping %s", path);
 					close(fd);
@@ -2182,7 +2177,7 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 					bytes += len;
 				}
 
-				munmap(buf, fbuf.st_size + 1);
+				lxc_munmap(buf, fbuf.st_size);
 				if (ftruncate(fd, fbuf.st_size - bytes) < 0) {
 					SYSERROR("Failed to truncate file %s", path);
 					close(fd);

commit b7088add705cfda0f63aaf00535f246c68d8cdc8
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Mar 22 09:24:01 2016 -0600

    c/r: rename restore & friends to __criu_restore
    
    Hopefully this will avoid name collisions with any user binaries, since
    criu is just an implementation detail.
    
    Closes #907
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c11ffe0..ab48fb5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3960,13 +3960,13 @@ static int do_lxcapi_migrate(struct lxc_container *c, unsigned int cmd,
 
 	switch (cmd) {
 	case MIGRATE_PRE_DUMP:
-		ret = !pre_dump(c, opts->directory, opts->verbose, opts->predump_dir);
+		ret = !__criu_pre_dump(c, opts->directory, opts->verbose, opts->predump_dir);
 		break;
 	case MIGRATE_DUMP:
-		ret = !dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir);
+		ret = !__criu_dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir);
 		break;
 	case MIGRATE_RESTORE:
-		ret = !restore(c, opts->directory, opts->verbose);
+		ret = !__criu_restore(c, opts->directory, opts->verbose);
 		break;
 	default:
 		ERROR("invalid migrate command %u", cmd);

commit 49a2ed808cc2b53425d0fee55e9fc563dd961bf6
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Mar 15 14:43:44 2016 -0700

    nesting: document how to enable nesting in container configurations
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index bb34bcd..c11ffe0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1375,6 +1375,9 @@ static bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	fprintf(f, "\n");
 #endif
 	fprintf(f, "# For additional config options, please look at lxc.container.conf(5)\n");
+	fprintf(f, "\n# Uncomment the following line to support nesting containers:\n");
+	fprintf(f, "#lxc.include = " LXCTEMPLATECONFIG "/nesting.conf\n");
+	fprintf(f, "# (Be aware this has security implications)\n\n");
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");
 		free(contents);

commit 740fe426b78ab4967ee5d3b2fe162b0664818091
Author: Katze <binary@benary.org>
Date:   Fri Feb 5 18:53:59 2016 +0100

    fix typo
    
    Signed-off-by: benaryorg <binary@benary.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 402b96f..bb34bcd 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -173,7 +173,7 @@ static int create_partial(struct lxc_container *c)
 		return -1;
 	}
 	if ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {
-		SYSERROR("Erorr creating partial file");
+		SYSERROR("Error creating partial file");
 		return -1;
 	}
 	lk.l_type = F_WRLCK;

commit e4ebeab1cdf3ae4844c3a78d47d2aad5d9de9cbd
Author: Carlos Alberto Lopez Perez <clopez@igalia.com>
Date:   Fri Jan 29 15:39:22 2016 +0100

    Ignore any container with a name starting by '.'
    
      * This are either '.', '..' or a hidden directory.
        And this names should not be used for a container
        in any case.
    
      * Before this patch, if you created a git repository under lxc.lxcpath (it
        can be useful to keep track of the configurations of your containers)
    
        Then, when you run lxc-ls you will get the following output:
    
            # lxc-ls
            .git      container1      container2    ....
    
        This is because there is a 'config' file inside the '.git' directory.
        It is where git stores the configuration of the repository.
    
        And the test lxc-ls does to check if a directory contains a container
        is just to check if the 'directory/config' file exists.
    
    Signed-off-by: Carlos Alberto Lopez Perez <clopez@igalia.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7f2a390..402b96f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4188,9 +4188,9 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 	while (!readdir_r(dir, &dirent, &direntp)) {
 		if (!direntp)
 			break;
-		if (!strcmp(direntp->d_name, "."))
-			continue;
-		if (!strcmp(direntp->d_name, ".."))
+
+		// Ignore '.', '..' and any hidden directory
+		if (!strncmp(direntp->d_name, ".", 1))
 			continue;
 
 		if (!config_file_exists(lxcpath, direntp->d_name))

commit 9a09badcf580aed1ef9e3b502730f34f387fa21c
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Thu Jan 14 21:39:05 2016 +0100

    check for btrfs fs in should_default_to_snapshot
    
    Check if we're really on a btrfs filesystem before we call btrfs_same_fs().
    Otherwise we will report misleading errors although everything went fine.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 490a59d..7f2a390 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2833,6 +2833,10 @@ bool should_default_to_snapshot(struct lxc_container *c0,
 
 	snprintf(p0, l0, "%s/%s", c0->config_path, c0->name);
 	snprintf(p1, l1, "%s/%s", c1->config_path, c1->name);
+
+	if (!is_btrfs_fs(p0) || !is_btrfs_fs(p1))
+		return false;
+
 	return btrfs_same_fs(p0, p1) == 0;
 }
 

commit 15a90a10d90b7722db66b7622b47344e1ccad97d
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jan 11 13:07:05 2016 -0800

    copy_storage: try to use snapshot for btrfs
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 802a930..490a59d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -41,6 +41,7 @@
 #include "attach.h"
 #include "bdev/bdev.h"
 #include "bdev/lxcoverlay.h"
+#include "bdev/lxcbtrfs.h"
 #include "cgroup.h"
 #include "conf.h"
 #include "config.h"
@@ -2817,12 +2818,33 @@ static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)
 	return bret;
 }
 
+/*
+ * If the fs natively supports snapshot clones with no penalty,
+ * then default to those even if not requested.
+ * Currently we only do this for btrfs.
+ */
+bool should_default_to_snapshot(struct lxc_container *c0,
+				struct lxc_container *c1)
+{
+	size_t l0 = strlen(c0->config_path) + strlen(c0->name) + 2;
+	size_t l1 = strlen(c1->config_path) + strlen(c1->name) + 2;
+	char *p0 = alloca(l0 + 1);
+	char *p1 = alloca(l1 + 1);
+
+	snprintf(p0, l0, "%s/%s", c0->config_path, c0->name);
+	snprintf(p1, l1, "%s/%s", c1->config_path, c1->name);
+	return btrfs_same_fs(p0, p1) == 0;
+}
+
 static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		const char *newtype, int flags, const char *bdevdata, uint64_t newsize)
 {
 	struct bdev *bdev;
 	int need_rdep;
 
+	if (should_default_to_snapshot(c0, c))
+		flags |= LXC_CLONE_SNAPSHOT;
+
 	bdev = bdev_copy(c0, c->name, c->config_path, newtype, flags,
 			bdevdata, newsize, &need_rdep);
 	if (!bdev) {

commit 7d72b9596c6555d374ef32e83c0272d16a1d71dc
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jan 4 14:34:49 2016 -0800

    coverity: close fout on error in is_wlan()
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 78bf3e0..802a930 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3057,6 +3057,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	c->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);
 	if (!c->lxc_conf->unexpanded_config) {
 		ERROR("Out of memory");
+		fclose(fout);
 		goto out;
 	}
 	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs", false);

commit 3c16d0cb4d4d618dd83feefd1ab2854c9550d2cb
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Thu Dec 17 20:14:58 2015 +0100

    Split bdev into modules: btrfs
    
    Create a module for btrfs: lxcbtrfs.{c,h}.
    
    The functions:
    
    	- get_btrfs_subvol_path()
    	- btrfs_list_get_path_rootid()
    	- is_btrfs_fs()
    	- btrfs_detect()
    	- btrfs_mount()
    	- btrfs_umount()
    	- btrfs_subvolume_create()
    	- btrfs_same_fs()
    	- btrfs_snapshot()
    	- btrfs_snapshot_wrapper()
    	- btrfs_clonepaths()
    	- btrfs_do_destroy_subvol()
    	- get_btrfs_tree_idx()
    	- my_btrfs_tree *create_my_btrfs_tree()
    	- update_tree_node()
    	- add_btrfs_tree_node()
    	- free_btrfs_tree()
    	- do_remove_btrfs_children()
    	- btrfs_recursive_destroy()
    	- btrfs_try_remove_subvol()
    	- btrfs_destroy()
    	- btrfs_create()
    
    and the structs:
    
    	- struct mytree_node
    	- struct my_btrfs_tree
    
    move from bdev.{c,h} to lxcbtrfs.{c,h}.
    
    Rename the header file
    
    	- lxc-btrfs.h --> lxcbtrfs.h
    
    Adapt Makefile.am to include lxcbtrfs.{c,h} and remove lxc-btrfs.h.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 68644c0..78bf3e0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -40,7 +40,7 @@
 
 #include "attach.h"
 #include "bdev/bdev.h"
-#include "bdev/overlay.h"
+#include "bdev/lxcoverlay.h"
 #include "cgroup.h"
 #include "conf.h"
 #include "config.h"

commit f2e50c442dd40325ec75ff9be32da72dc28b371a
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Thu Dec 17 20:14:58 2015 +0100

    Split bdev into modules: btrfs
    
    Create a module for btrfs: lxcbtrfs.{c,h}.
    
    The functions:
    
    	- get_btrfs_subvol_path()
    	- btrfs_list_get_path_rootid()
    	- is_btrfs_fs()
    	- btrfs_detect()
    	- btrfs_mount()
    	- btrfs_umount()
    	- btrfs_subvolume_create()
    	- btrfs_same_fs()
    	- btrfs_snapshot()
    	- btrfs_snapshot_wrapper()
    	- btrfs_clonepaths()
    	- btrfs_do_destroy_subvol()
    	- get_btrfs_tree_idx()
    	- my_btrfs_tree *create_my_btrfs_tree()
    	- update_tree_node()
    	- add_btrfs_tree_node()
    	- free_btrfs_tree()
    	- do_remove_btrfs_children()
    	- btrfs_recursive_destroy()
    	- btrfs_try_remove_subvol()
    	- btrfs_destroy()
    	- btrfs_create()
    
    and the structs:
    
    	- struct mytree_node
    	- struct my_btrfs_tree
    
    move from bdev.{c,h} to lxcbtrfs.{c,h}.
    
    Rename the header file
    
    	- lxc-btrfs.h --> lxcbtrfs.h
    
    Adapt Makefile.am to include lxcbtrfs.{c,h} and remove lxc-btrfs.h.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 68644c0..78bf3e0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -40,7 +40,7 @@
 
 #include "attach.h"
 #include "bdev/bdev.h"
-#include "bdev/overlay.h"
+#include "bdev/lxcoverlay.h"
 #include "cgroup.h"
 #include "conf.h"
 #include "config.h"

commit 83e79752a2cf2b25fc94acabd465227f0404571d
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Sun Dec 13 19:44:09 2015 +0100

    Unify naming for overlay types & functions
    
    Use ovl_ as prefix for types and functions.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 97abced..68644c0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1093,9 +1093,9 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool need_
 		 * the template
 		 */
 		if (strncmp(src, "overlayfs:", 10) == 0)
-			src = overlay_getlower(src+10);
+			src = ovl_getlower(src+10);
 		if (strncmp(src, "aufs:", 5) == 0)
-			src = overlay_getlower(src+5);
+			src = ovl_getlower(src+5);
 
 		bdev = bdev_init(c->lxc_conf, src, c->lxc_conf->rootfs.mount, NULL);
 		if (!bdev) {
@@ -3125,7 +3125,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	}
 
 	// update absolute paths for overlay mount directories
-	if (update_ovl_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)
+	if (ovl_update_abs_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)
 		goto out;
 
 	// We've now successfully created c2's storage, so clear it out if we

commit 38683db41204cb221892beeb88d67a1df4a07287
Author: Christian Brauner <christian.brauner@mailbox.org>
Date:   Sat Dec 12 22:48:33 2015 +0100

    Split bdev into modules: overlay
    
    With this commit we start to split bdev.{c,h} into modules located in the
    subfolder bdev. We start by creating a module for overlay: overlay.{c,h}.
    
    - The functions:
    
    	- overlayfs_detect()
    	- overlayfs_mount()
    	- overlayfs_umount()
    	- overlayfs_clonepaths()
    	- overlayfs_destroy()
    	- overlayfs_create()
    
      move from bdev.{c,h} to overlay.{c,h}. The only thing that remains in bdev.c
      is the static definition of
    
    	- static const struct bdev_ops overlayfs_ops
    
    - The functions:
    
    	- update_ovl_paths()
    	- overlay_getlower()
    
      move from lxccontainer.c to overlay.{c,h}. update_ovl_paths() is used to
      update absolute paths for overlay lxc.mount.entry entries but it seems to fit
      more here than into lxccontainer.c.
      The Function overlay_getlower() is used to extract the lower directory for
      overlay (and aufs) rootfs. It should at some point become a common helper.
    
    - The functions:
    
    	- do_rsync()
    	- dir_new_path()
    
       remain in bdev.c for now but become extern. We declare them extern in
       overlay.c to be able to call them. As the comment to them correctly notices,
       they should at some point become common helpers and probably move to
       utils.{c,h} or some other more appropriate place.
    
    - The structs:
    
    	- struct bdev; /* defined in bdev.h */
    	- struct bdev_specs; /* defined in lxccontainer.h */
    	- struct lxc_conf; /* defined conf.h */
    
      are forward declared/put as incomplete types in overlay.h so that the
      functions have access to it.
    
    - The header overlay.h is *not* included in bdev.h but only in bdev.c so that
      when bdev.h is included the public functions in overlay.h cannot be accessed,
      i.e. if an implementation wants to call functions from overlay.h they need to
      explicitly include it. (As is e.g. done in the case of lxccontainer.c.)
    
    - The header
    
    	- lxc-btrfs.h
    
      also moves to the bdev subfolder.
    
    - Adapt Makefile.am to the new bdev layout.
    
    Signed-off-by: Christian Brauner <christian.brauner@mailbox.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1dacc1a..97abced 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -19,48 +19,46 @@
  */
 
 #define _GNU_SOURCE
-#include <sys/mman.h>
 #include <assert.h>
-#include <stdarg.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <sys/mount.h>
+#include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sched.h>
-#include <dirent.h>
-#include <sched.h>
-#include <arpa/inet.h>
+#include <grp.h>
 #include <libgen.h>
+#include <pthread.h>
+#include <sched.h>
+#include <stdarg.h>
 #include <stdint.h>
-#include <grp.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <sys/mman.h>
+#include <sys/mount.h>
 #include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 
-#include <lxc/lxccontainer.h>
-#include <lxc/version.h>
-#include <lxc/network.h>
-
-#include "config.h"
-#include "lxc.h"
-#include "state.h"
+#include "attach.h"
+#include "bdev/bdev.h"
+#include "bdev/overlay.h"
+#include "cgroup.h"
 #include "conf.h"
+#include "config.h"
+#include "commands.h"
 #include "confile.h"
 #include "console.h"
-#include "cgroup.h"
-#include "commands.h"
 #include "criu.h"
 #include "log.h"
-#include "bdev.h"
-#include "utils.h"
-#include "attach.h"
+#include "lxc.h"
+#include "lxccontainer.h"
+#include "lxclock.h"
 #include "monitor.h"
 #include "namespace.h"
 #include "network.h"
-#include "lxclock.h"
 #include "sync.h"
+#include "state.h"
+#include "utils.h"
+#include "version.h"
 
 #if HAVE_IFADDRS_H
 #include <ifaddrs.h>
@@ -2997,102 +2995,6 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	return ret;
 }
 
-/* When we clone a container with overlay lxc.mount.entry entries we need to
-*  update absolute paths for upper- and workdir. This update is done in two
-*  locations: lxc_conf->unexpanded_config and lxc_conf->mount_list. Both updates
-*  are done independent of each other since lxc_conf->mountlist may container
-*  more mount entries (e.g. from other included files) than
-*  lxc_conf->unexpanded_config . */
-static int update_ovl_paths(struct lxc_conf *lxc_conf, const char *lxc_path,
-			    const char *lxc_name, const char *newpath,
-			    const char *newname)
-{
-	char new_upper[MAXPATHLEN];
-	char new_work[MAXPATHLEN];
-	char old_upper[MAXPATHLEN];
-	char old_work[MAXPATHLEN];
-	char *cleanpath = NULL;
-	int i;
-	int fret = -1;
-	int ret = 0;
-	struct lxc_list *iterator;
-	const char *ovl_dirs[] = {"br", "upperdir", "workdir"};
-
-	cleanpath = strdup(newpath);
-	if (!cleanpath)
-		goto err;
-
-	remove_trailing_slashes(cleanpath);
-
-	/* We have to update lxc_conf->unexpanded_config separately from
-	*  lxc_conf->mount_list. */
-	for (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {
-		if (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,
-						  lxc_name, newname,
-						  ovl_dirs[i]))
-			goto err;
-	}
-
-	ret = snprintf(old_work, MAXPATHLEN, "workdir=%s/%s", lxc_path, lxc_name);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		goto err;
-
-	ret = snprintf(new_work, MAXPATHLEN, "workdir=%s/%s", cleanpath, newname);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		goto err;
-
-	lxc_list_for_each(iterator, &lxc_conf->mount_list) {
-		char *mnt_entry = NULL;
-		char *new_mnt_entry = NULL;
-		char *tmp = NULL;
-		char *tmp_mnt_entry = NULL;
-		mnt_entry = iterator->elem;
-
-		if (strstr(mnt_entry, "overlay"))
-			tmp = "upperdir";
-		else if (strstr(mnt_entry, "aufs"))
-			tmp = "br";
-
-		if (!tmp)
-			continue;
-
-		ret = snprintf(old_upper, MAXPATHLEN, "%s=%s/%s", tmp, lxc_path, lxc_name);
-		if (ret < 0 || ret >= MAXPATHLEN)
-			goto err;
-
-		ret = snprintf(new_upper, MAXPATHLEN, "%s=%s/%s", tmp, cleanpath, newname);
-		if (ret < 0 || ret >= MAXPATHLEN)
-			goto err;
-
-		if (strstr(mnt_entry, old_upper)) {
-			tmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);
-		}
-
-		if (strstr(mnt_entry, old_work)) {
-			if (tmp_mnt_entry)
-				new_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);
-			else
-				new_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);
-		}
-
-		if (new_mnt_entry) {
-			free(iterator->elem);
-			iterator->elem = strdup(new_mnt_entry);
-		} else if (tmp_mnt_entry) {
-			free(iterator->elem);
-			iterator->elem = strdup(tmp_mnt_entry);
-		}
-
-		free(new_mnt_entry);
-		free(tmp_mnt_entry);
-	}
-
-	fret = 0;
-err:
-	free(cleanpath);
-	return fret;
-}
-
 static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, uint64_t newsize,

commit aef3d51e61d8e65f31201e4a60eb4102ce5b4385
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Nov 30 15:14:22 2015 -0700

    c/r: add a new ->migrate API call
    
    This patch adds a new ->migrate API call with three commands:
    
    MIGRATE_DUMP: this is basically just ->checkpoint()
    MIGRATE_RESTORE: this is just ->restore()
    MIGRATE_PRE_DUMP: this can be used to invoke criu's pre-dump command on the
        container.
    
    A small addition to the (pre-)dump commands is the ability to specify a
    previous partial dump directory, so that one can use a pre-dump of a
    container.
    
    Finally, this new API call uses a structure to pass options so that it can
    be easily extended in the future (e.g. to CRIU's --leave-frozen option in
    the future, for potentially smarter failure handling on restore).
    
    v2: remember to flip the return code for legacy ->checkpoint and ->restore
        calls
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index bc5d585..1dacc1a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4004,112 +4004,69 @@ static bool do_lxcapi_detach_interface(struct lxc_container *c, const char *ifna
 
 WRAP_API_2(bool, lxcapi_detach_interface, const char *, const char *)
 
-static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+static int do_lxcapi_migrate(struct lxc_container *c, unsigned int cmd,
+			     struct migrate_opts *opts, unsigned int size)
 {
-	pid_t pid;
-	int status;
-	char path[PATH_MAX];
-
-	if (!criu_ok(c))
-		return false;
-
-	if (mkdir(directory, 0700) < 0 && errno != EEXIST)
-		return false;
-
-	status = snprintf(path, sizeof(path), "%s/inventory.img", directory);
-	if (status < 0 || status >= sizeof(path))
-		return false;
+	int ret;
 
-	if (access(path, F_OK) == 0) {
-		ERROR("please use a fresh directory for the dump directory\n");
-		return false;
+	/* If the caller has a bigger (newer) struct migrate_opts, let's make
+	 * sure that the stuff on the end is zero, i.e. that they didn't ask us
+	 * to do anything special.
+	 */
+	if (size > sizeof(*opts)) {
+		unsigned char *addr;
+		unsigned char *end;
+
+		addr = (void *)opts + sizeof(*opts);
+		end  = (void *)opts + size;
+		for (; addr < end; addr++) {
+			if (*addr) {
+				return -E2BIG;
+			}
+		}
 	}
 
-	pid = fork();
-	if (pid < 0)
-		return false;
-
-	if (pid == 0) {
-		struct criu_opts os;
+	switch (cmd) {
+	case MIGRATE_PRE_DUMP:
+		ret = !pre_dump(c, opts->directory, opts->verbose, opts->predump_dir);
+		break;
+	case MIGRATE_DUMP:
+		ret = !dump(c, opts->directory, opts->stop, opts->verbose, opts->predump_dir);
+		break;
+	case MIGRATE_RESTORE:
+		ret = !restore(c, opts->directory, opts->verbose);
+		break;
+	default:
+		ERROR("invalid migrate command %u", cmd);
+		ret = -EINVAL;
+	}
 
-		os.action = "dump";
-		os.directory = directory;
-		os.c = c;
-		os.stop = stop;
-		os.verbose = verbose;
+	return ret;
+}
 
-		/* exec_criu() returning is an error */
-		exec_criu(&os);
-		exit(1);
-	} else {
-		pid_t w = waitpid(pid, &status, 0);
-		if (w == -1) {
-			SYSERROR("waitpid");
-			return false;
-		}
+WRAP_API_3(int, lxcapi_migrate, unsigned int, struct migrate_opts *, unsigned int)
 
-		if (WIFEXITED(status)) {
-			return !WEXITSTATUS(status);
-		}
+static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+{
+	struct migrate_opts opts = {
+		.directory = directory,
+		.stop = stop,
+		.verbose = verbose,
+	};
 
-		return false;
-	}
+	return !do_lxcapi_migrate(c, MIGRATE_DUMP, &opts, sizeof(opts));
 }
 
 WRAP_API_3(bool, lxcapi_checkpoint, char *, bool, bool)
 
 static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
-	pid_t pid;
-	int status, nread;
-	int pipefd[2];
-
-	if (!criu_ok(c))
-		return false;
-
-	if (geteuid()) {
-		ERROR("Must be root to restore\n");
-		return false;
-	}
-
-	if (pipe(pipefd)) {
-		ERROR("failed to create pipe");
-		return false;
-	}
-
-	pid = fork();
-	if (pid < 0) {
-		close(pipefd[0]);
-		close(pipefd[1]);
-		return false;
-	}
-
-	if (pid == 0) {
-		close(pipefd[0]);
-		// this never returns
-		do_restore(c, pipefd[1], directory, verbose);
-	}
-
-	close(pipefd[1]);
-
-	nread = read(pipefd[0], &status, sizeof(status));
-	close(pipefd[0]);
-	if (sizeof(status) != nread) {
-		ERROR("reading status from pipe failed");
-		goto err_wait;
-	}
-
-	// If the criu process was killed or exited nonzero, wait() for the
-	// handler, since the restore process died. Otherwise, we don't need to
-	// wait, since the child becomes the monitor process.
-	if (!WIFEXITED(status) || WEXITSTATUS(status))
-		goto err_wait;
-	return true;
+	struct migrate_opts opts = {
+		.directory = directory,
+		.verbose = verbose,
+	};
 
-err_wait:
-	if (wait_for_pid(pid))
-		ERROR("restore process died");
-	return false;
+	return !do_lxcapi_migrate(c, MIGRATE_RESTORE, &opts, sizeof(opts));
 }
 
 WRAP_API_2(bool, lxcapi_restore, char *, bool)
@@ -4255,6 +4212,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->detach_interface = lxcapi_detach_interface;
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
+	c->migrate = lxcapi_migrate;
 
 	return c;
 

commit 8164f0e253e9c148a3c3c09eec5e0ebe56602805
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Dec 2 14:30:52 2015 -0700

    api wrapper: only reset the current config if this call set it
    
    Instead of *always* resetting the current_config to null, we should only
    reset it if this API call set it.
    
    This allows nesting of API calls, e.g. c->checkpoint() can pass stuff into
    criu.c, which can call c->init_pid() and not lose the ability to log stuff
    afterwards.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2804841..bc5d585 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -345,9 +345,17 @@ out:
 static rettype fnname(struct lxc_container *c)				\
 {									\
 	rettype ret;							\
-	current_config = c ? c->lxc_conf : NULL;			\
+	bool reset_config = false;					\
+									\
+	if (!current_config && c && c->lxc_conf) {			\
+		current_config = c->lxc_conf;				\
+		reset_config = true;					\
+	}								\
+									\
 	ret = do_##fnname(c);						\
-	current_config = NULL;						\
+	if (reset_config)						\
+		current_config = NULL;					\
+									\
 	return ret;							\
 }
 
@@ -355,9 +363,17 @@ static rettype fnname(struct lxc_container *c)				\
 static rettype fnname(struct lxc_container *c, t1 a1)			\
 {									\
 	rettype ret;							\
-	current_config = c ? c->lxc_conf : NULL;			\
+	bool reset_config = false;					\
+									\
+	if (!current_config && c && c->lxc_conf) {			\
+		current_config = c->lxc_conf;				\
+		reset_config = true;					\
+	}								\
+									\
 	ret = do_##fnname(c, a1);					\
-	current_config = NULL;						\
+	if (reset_config)						\
+		current_config = NULL;					\
+									\
 	return ret;							\
 }
 
@@ -365,9 +381,17 @@ static rettype fnname(struct lxc_container *c, t1 a1)			\
 static rettype fnname(struct lxc_container *c, t1 a1, t2 a2)		\
 {									\
 	rettype ret;							\
-	current_config = c ? c->lxc_conf : NULL;			\
+	bool reset_config = false;					\
+									\
+	if (!current_config && c && c->lxc_conf) {			\
+		current_config = c->lxc_conf;				\
+		reset_config = true;					\
+	}								\
+									\
 	ret = do_##fnname(c, a1, a2);					\
-	current_config = NULL;						\
+	if (reset_config)						\
+		current_config = NULL;					\
+									\
 	return ret;							\
 }
 
@@ -375,9 +399,17 @@ static rettype fnname(struct lxc_container *c, t1 a1, t2 a2)		\
 static rettype fnname(struct lxc_container *c, t1 a1, t2 a2, t3 a3)	\
 {									\
 	rettype ret;							\
-	current_config = c ? c->lxc_conf : NULL;			\
+	bool reset_config = false;					\
+									\
+	if (!current_config && c && c->lxc_conf) {			\
+		current_config = c->lxc_conf;				\
+		reset_config = true;					\
+	}								\
+									\
 	ret = do_##fnname(c, a1, a2, a3);				\
-	current_config = NULL;						\
+	if (reset_config)						\
+		current_config = NULL;					\
+									\
 	return ret;							\
 }
 

commit a8dfe4e08da61a454afca3c94e94a88fb310ebba
Author: Wolfgang Bumiller <w.bumiller@proxmox.com>
Date:   Mon Nov 30 08:58:53 2015 +0100

    Added lxc.monitor.unshare
    
    If manual mounting with elevated permissions is required
    this can currently only be done in pre-start hooks or before
    starting LXC. In both cases the mounts would appear in the
    host's namespace.
    With this flag the namespace is unshared before the startup
    sequence, so that mounts performed in the pre-start hook
    don't show up on the host.
    
    Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 69816da..2804841 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -820,6 +820,18 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 
 	conf->reboot = 0;
 
+	/* Unshare the mount namespace if requested */
+	if (conf->monitor_unshare) {
+		if (unshare(CLONE_NEWNS)) {
+			SYSERROR("failed to unshare mount namespace");
+			return false;
+		}
+		if (mount(NULL, "/", NULL, MS_SLAVE|MS_REC, NULL)) {
+			SYSERROR("Failed to make / rslave at startup");
+			return false;
+		}
+	}
+
 reboot:
 	if (lxc_check_inherited(conf, daemonize, -1)) {
 		ERROR("Inherited fds found");

commit 3b3925198558354089acf651e9cbb339a7b6bc9a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Nov 17 15:05:05 2015 -0600

    lxcapi_clone: restore the unexpanded config len
    
    Otherwise it gets shortened with the temporary len but never
    restored - which will only break API users which do a clone
    then continue to use the original container, meaning this is
    a hard one to detect.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index adc29c5..69816da 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3059,6 +3059,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	int ret, storage_copied = 0;
 	char *origroot = NULL, *saved_unexp_conf = NULL;
 	struct clone_update_data data;
+	size_t saved_unexp_len;
 	FILE *fout;
 	pid_t pid;
 
@@ -3106,6 +3107,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	}
 
 	saved_unexp_conf = c->lxc_conf->unexpanded_config;
+	saved_unexp_len = c->lxc_conf->unexpanded_len;
 	c->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);
 	if (!c->lxc_conf->unexpanded_config) {
 		ERROR("Out of memory");
@@ -3118,6 +3120,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	free(c->lxc_conf->unexpanded_config);
 	c->lxc_conf->unexpanded_config = saved_unexp_conf;
 	saved_unexp_conf = NULL;
+	c->lxc_conf->unexpanded_len = saved_unexp_len;
 
 	sprintf(newpath, "%s/%s/rootfs", lxcpath, newname);
 	if (mkdir(newpath, 0755) < 0) {

commit 5eea90e8505d9f336bb28379d8575be159fdd2e1
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Nov 11 17:13:25 2015 +0000

    clone: clear the rootfs out of unexpanded config
    
    Closes #694
    
    When we start cloning container c1 to c2, we first save c1's
    configuration in c2's as a starting point.  We long ago cleared
    out the lxc.rootfs entry before saving it, so that if we are
    killed before we update the rootfs, c2's rootfs doesn't point
    to c1's.  Because then lxc-destroy -n c2 would delete c1's rootfs.
    
    But when we introduced the unexpanded_config, we didn't update
    this code to clear the rootfs out of the unexpanded_config, which
    is what now actually gets saved in write_config().
    
    Do so.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5207255..adc29c5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3057,7 +3057,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	struct lxc_container *c2 = NULL;
 	char newpath[MAXPATHLEN];
 	int ret, storage_copied = 0;
-	char *origroot = NULL;
+	char *origroot = NULL, *saved_unexp_conf = NULL;
 	struct clone_update_data data;
 	FILE *fout;
 	pid_t pid;
@@ -3104,9 +3104,20 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 		SYSERROR("open %s", newpath);
 		goto out;
 	}
+
+	saved_unexp_conf = c->lxc_conf->unexpanded_config;
+	c->lxc_conf->unexpanded_config = strdup(saved_unexp_conf);
+	if (!c->lxc_conf->unexpanded_config) {
+		ERROR("Out of memory");
+		goto out;
+	}
+	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs", false);
 	write_config(fout, c->lxc_conf);
 	fclose(fout);
 	c->lxc_conf->rootfs.path = origroot;
+	free(c->lxc_conf->unexpanded_config);
+	c->lxc_conf->unexpanded_config = saved_unexp_conf;
+	saved_unexp_conf = NULL;
 
 	sprintf(newpath, "%s/%s/rootfs", lxcpath, newname);
 	if (mkdir(newpath, 0755) < 0) {

commit 030ce9a9656c08eb0ba5b469132437874215bed4
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Mon Nov 2 23:20:36 2015 +0100

    Update absolute paths for overlay and aufs mounts
    
    When using overlay and aufs mounts with lxc.mount.entry users have to specify
    absolute paths for upperdir and workdir which will then get created
    automatically by mount_entry_create_overlay_dirs() and
    mount_entry_create_aufs_dirs() in conf.c. When we clone a container with
    overlay or aufs lxc.mount.entry entries we need to update these absolute paths.
    In order to do this we add the function update_ovl_paths() in
    lxccontainer.c. The function updates the mounts in two locations:
    
            1) lxc_conf->mount_list
    
    and
    
            2) lxc_conf->unexpanded_config (by calling clone_update_unexp_ovl_dir())
    
    If we were to only update 2) we would end up with wrong upperdir and workdir
    mounts as the absolute paths would still point to the container that serves as
    the base for the clone. If we were to only update 1) we would end up with wrong
    upperdir and workdir lxc.mount.entry entries in the clone's config as the
    absolute paths in upperdir and workdir would still point to the container that
    serves as the base for the clone. Updating both will get the job done.
    
    NOTE: This function does not sanitize paths apart from removing trailing
    slashes. (So when a user specifies //home//someone/// it will be cleaned to
    //home//someone. This is the minimal path cleansing which is also done by
    lxc_container_new().) But the mount_entry_create_overlay_dirs() and
    mount_entry_create_aufs_dirs() functions both try to be extremely strict about
    when to create upperdirs and workdirs. They will only accept sanitized paths,
    i.e. they require /home/someone. I think this is a (safety) virtue and we
    should consider sanitizing paths in general. In short: update_ovl_paths() does
    update all absolute paths to the new container but
    mount_entry_create_overlay_dirs() and mount_entry_create_aufs_dirs() will still
    refuse to create upperdir and workdir when the updated path is unclean. This
    happens easily when e.g. a user calls lxc-clone -o OLD -n NEW -P
    //home//chb///.
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 87a941c..5207255 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2953,6 +2953,102 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	return ret;
 }
 
+/* When we clone a container with overlay lxc.mount.entry entries we need to
+*  update absolute paths for upper- and workdir. This update is done in two
+*  locations: lxc_conf->unexpanded_config and lxc_conf->mount_list. Both updates
+*  are done independent of each other since lxc_conf->mountlist may container
+*  more mount entries (e.g. from other included files) than
+*  lxc_conf->unexpanded_config . */
+static int update_ovl_paths(struct lxc_conf *lxc_conf, const char *lxc_path,
+			    const char *lxc_name, const char *newpath,
+			    const char *newname)
+{
+	char new_upper[MAXPATHLEN];
+	char new_work[MAXPATHLEN];
+	char old_upper[MAXPATHLEN];
+	char old_work[MAXPATHLEN];
+	char *cleanpath = NULL;
+	int i;
+	int fret = -1;
+	int ret = 0;
+	struct lxc_list *iterator;
+	const char *ovl_dirs[] = {"br", "upperdir", "workdir"};
+
+	cleanpath = strdup(newpath);
+	if (!cleanpath)
+		goto err;
+
+	remove_trailing_slashes(cleanpath);
+
+	/* We have to update lxc_conf->unexpanded_config separately from
+	*  lxc_conf->mount_list. */
+	for (i = 0; i < sizeof(ovl_dirs) / sizeof(ovl_dirs[0]); i++) {
+		if (!clone_update_unexp_ovl_paths(lxc_conf, lxc_path, newpath,
+						  lxc_name, newname,
+						  ovl_dirs[i]))
+			goto err;
+	}
+
+	ret = snprintf(old_work, MAXPATHLEN, "workdir=%s/%s", lxc_path, lxc_name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		goto err;
+
+	ret = snprintf(new_work, MAXPATHLEN, "workdir=%s/%s", cleanpath, newname);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		goto err;
+
+	lxc_list_for_each(iterator, &lxc_conf->mount_list) {
+		char *mnt_entry = NULL;
+		char *new_mnt_entry = NULL;
+		char *tmp = NULL;
+		char *tmp_mnt_entry = NULL;
+		mnt_entry = iterator->elem;
+
+		if (strstr(mnt_entry, "overlay"))
+			tmp = "upperdir";
+		else if (strstr(mnt_entry, "aufs"))
+			tmp = "br";
+
+		if (!tmp)
+			continue;
+
+		ret = snprintf(old_upper, MAXPATHLEN, "%s=%s/%s", tmp, lxc_path, lxc_name);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			goto err;
+
+		ret = snprintf(new_upper, MAXPATHLEN, "%s=%s/%s", tmp, cleanpath, newname);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			goto err;
+
+		if (strstr(mnt_entry, old_upper)) {
+			tmp_mnt_entry = lxc_string_replace(old_upper, new_upper, mnt_entry);
+		}
+
+		if (strstr(mnt_entry, old_work)) {
+			if (tmp_mnt_entry)
+				new_mnt_entry = lxc_string_replace(old_work, new_work, tmp_mnt_entry);
+			else
+				new_mnt_entry = lxc_string_replace(old_work, new_work, mnt_entry);
+		}
+
+		if (new_mnt_entry) {
+			free(iterator->elem);
+			iterator->elem = strdup(new_mnt_entry);
+		} else if (tmp_mnt_entry) {
+			free(iterator->elem);
+			iterator->elem = strdup(tmp_mnt_entry);
+		}
+
+		free(new_mnt_entry);
+		free(tmp_mnt_entry);
+	}
+
+	fret = 0;
+err:
+	free(cleanpath);
+	return fret;
+}
+
 static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, uint64_t newsize,
@@ -3068,6 +3164,10 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 		}
 	}
 
+	// update absolute paths for overlay mount directories
+	if (update_ovl_paths(c2->lxc_conf, c->config_path, c->name, lxcpath, newname) < 0)
+		goto out;
+
 	// We've now successfully created c2's storage, so clear it out if we
 	// fail after this
 	storage_copied = 1;

commit fd51a89b60d06f1f207196e5fe6e8e8f7bea3beb
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Nov 5 22:18:52 2015 +0000

    support arguments in lxc.init_cmd
    
    Otherwise something like
    	lxc.init_cmd = /sbin/init debug verbose
    fails trying to execute a file called "/sbin/init debug verbose"
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index eccc154..87a941c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -618,10 +618,64 @@ static bool am_single_threaded(void)
 	return count == 1;
 }
 
-/*
- * I can't decide if it'd be more convenient for callers if we accept '...',
- * or a null-terminated array (i.e. execl vs execv)
- */
+static void push_arg(char ***argp, char *arg, int *nargs)
+{
+	char **argv;
+	char *copy;
+
+	do {
+		copy = strdup(arg);
+	} while (!copy);
+	do {
+		argv = realloc(*argp, (*nargs + 2) * sizeof(char *));
+	} while (!argv);
+	*argp = argv;
+	argv[*nargs] = copy;
+	(*nargs)++;
+	argv[*nargs] = NULL;
+}
+
+static char **split_init_cmd(const char *incmd)
+{
+	size_t len;
+	int nargs = 0;
+	char *copy, *p, *saveptr;
+	char **argv;
+
+	if (!incmd)
+		return NULL;
+
+	len = strlen(incmd) + 1;
+	copy = alloca(len);
+	strncpy(copy, incmd, len);
+	copy[len-1] = '\0';
+
+	do {
+		argv = malloc(sizeof(char *));
+	} while (!argv);
+	argv[0] = NULL;
+	for (p = strtok_r(copy, " ", &saveptr); p != NULL;
+			p = strtok_r(NULL, " ", &saveptr))
+		push_arg(&argv, p, &nargs);
+
+	if (nargs == 0) {
+		free(argv);
+		return NULL;
+	}
+	return argv;
+}
+
+static void free_init_cmd(char **argv)
+{
+	int i = 0;
+
+	if (!argv)
+		return;
+	while (argv[i])
+		free(argv[i++]);
+	free(argv);
+}
+
 static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
@@ -632,7 +686,7 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 		"/sbin/init",
 		NULL,
 	};
-	char *init_cmd[2];
+	char **init_cmd = NULL;
 
 	/* container exists */
 	if (!c)
@@ -673,15 +727,14 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 		return ret == 0 ? true : false;
 	}
 
-	if (!argv) {
-		if (conf->init_cmd) {
-			init_cmd[0] = conf->init_cmd;
-			init_cmd[1] = NULL;
-			argv = init_cmd;
-		}
-		else
-			argv = default_args;
-	}
+	/* if no argv was passed in, use lxc.init_cmd if provided in
+	 * configuration */
+	if (!argv)
+		argv = init_cmd = split_init_cmd(conf->init_cmd);
+
+	/* ... and otherwise use default_args */
+	if (!argv)
+		argv = default_args;
 
 	/*
 	* say, I'm not sure - what locks do we want here?  Any?
@@ -790,6 +843,8 @@ out:
 		c->pidfile = NULL;
 	}
 
+	free_init_cmd(init_cmd);
+
 	if (daemonize)
 		exit (ret == 0 ? true : false);
 	else

commit 120146b993a576617d785ebb52157bb00d2e91a4
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Nov 5 13:44:30 2015 -0500

    Init error_num to 1
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 42e23e7..eccc154 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -637,6 +637,10 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 	/* container exists */
 	if (!c)
 		return false;
+
+	/* If anything fails before we set error_num, we want an error in there */
+	c->error_num = 1;
+
 	/* container has been setup */
 	if (!c->lxc_conf)
 		return false;

commit d028235de9ec7664e1c2c904c541a447a768997a
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Sep 21 16:25:47 2015 -0400

    Fix indentation
    
    I've noticed that a bunch of the code we've included over the past few
    weeks has been using 8-spaces rather than tabs, making it all very hard
    to read depending on your tabstop setting.
    
    This commit attempts to revert all of that back to proper tabs and fix a
    few more cases I've noticed here and there.
    
    No functional changes are included in this commit.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index dd891dc..42e23e7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2049,49 +2049,49 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 				goto out;
 			}
 		} else if (!inc) {
-                        if ((fd = open(path, O_RDWR | O_CLOEXEC)) < 0)
-                                goto out;
-
-                        if (fstat(fd, &fbuf) < 0) {
-                                close(fd);
-                                goto out;
-                        }
-
-                        if (fbuf.st_size != 0) {
-                                /* write terminating \0-byte to file */
-                                if (pwrite(fd, "", 1, fbuf.st_size) <= 0) {
-                                        close(fd);
-                                        goto out;
-                                }
-
-                                buf = mmap(NULL, fbuf.st_size + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-                                if (buf == MAP_FAILED) {
-                                        SYSERROR("Failed to create mapping %s", path);
-                                        close(fd);
-                                        goto out;
-                                }
-
-                                len = strlen(newpath);
-                                while ((del = strstr((char *)buf, newpath))) {
-                                        memmove(del, del + len, strlen(del) - len + 1);
-                                        bytes += len;
-                                }
-
-                                munmap(buf, fbuf.st_size + 1);
-                                if (ftruncate(fd, fbuf.st_size - bytes) < 0) {
-                                        SYSERROR("Failed to truncate file %s", path);
-                                        close(fd);
-                                        goto out;
-                                }
-                        }
-                        close(fd);
-                }
+			if ((fd = open(path, O_RDWR | O_CLOEXEC)) < 0)
+				goto out;
+
+			if (fstat(fd, &fbuf) < 0) {
+				close(fd);
+				goto out;
+			}
+
+			if (fbuf.st_size != 0) {
+				/* write terminating \0-byte to file */
+				if (pwrite(fd, "", 1, fbuf.st_size) <= 0) {
+					close(fd);
+					goto out;
+				}
+
+				buf = mmap(NULL, fbuf.st_size + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+				if (buf == MAP_FAILED) {
+					SYSERROR("Failed to create mapping %s", path);
+					close(fd);
+					goto out;
+				}
+
+				len = strlen(newpath);
+				while ((del = strstr((char *)buf, newpath))) {
+					memmove(del, del + len, strlen(del) - len + 1);
+					bytes += len;
+				}
+
+				munmap(buf, fbuf.st_size + 1);
+				if (ftruncate(fd, fbuf.st_size - bytes) < 0) {
+					SYSERROR("Failed to truncate file %s", path);
+					close(fd);
+					goto out;
+				}
+			}
+			close(fd);
+		}
 
 		/* If the lxc-snapshot file is empty, remove it. */
 		if (stat(path, &fbuf) < 0)
 			goto out;
-                if (!fbuf.st_size) {
-                        remove(path);
+		if (!fbuf.st_size) {
+			remove(path);
 		}
 	}
 
@@ -2212,12 +2212,12 @@ static bool has_snapshots(struct lxc_container *c)
 }
 
 static bool do_destroy_container(struct lxc_conf *conf) {
-        if (am_unpriv()) {
-                if (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)
-                        return false;
-                return true;
-        }
-        return bdev_destroy(conf);
+	if (am_unpriv()) {
+		if (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)
+			return false;
+		return true;
+	}
+	return bdev_destroy(conf);
 }
 
 static int lxc_rmdir_onedev_wrapper(void *data)
@@ -2281,13 +2281,13 @@ static bool container_destroy(struct lxc_container *c)
 		}
 	}
 
-        if (conf && conf->rootfs.path && conf->rootfs.mount) {
-                if (!do_destroy_container(conf)) {
-                        ERROR("Error destroying rootfs for %s", c->name);
-                        goto out;
-                }
-                INFO("Destroyed rootfs for %s", c->name);
-        }
+	if (conf && conf->rootfs.path && conf->rootfs.mount) {
+		if (!do_destroy_container(conf)) {
+			ERROR("Error destroying rootfs for %s", c->name);
+			goto out;
+		}
+		INFO("Destroyed rootfs for %s", c->name);
+	}
 
 	mod_all_rdeps(c, false);
 
@@ -2302,7 +2302,7 @@ static bool container_destroy(struct lxc_container *c)
 		ERROR("Error destroying container directory for %s", c->name);
 		goto out;
 	}
-        INFO("Destroyed directory for %s", c->name);
+	INFO("Destroyed directory for %s", c->name);
 
 	bret = true;
 
@@ -2889,7 +2889,7 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	if (!p)
 		return -1;
 	*p = '\0';
-        ret = do_create_container_dir(path, conf);
+	ret = do_create_container_dir(path, conf);
 	*p = '/';
 	return ret;
 }

commit d825fff3cae40b89c26d838847021239e89df922
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Tue Sep 15 21:24:04 2015 +0200

    Make mod_all_rdeps() public It will now also be called from start.c
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0ba4fc0..dd891dc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2111,7 +2111,7 @@ static void strip_newline(char *p)
 		p[len-1] = '\0';
 }
 
-static void mod_all_rdeps(struct lxc_container *c, bool inc)
+void mod_all_rdeps(struct lxc_container *c, bool inc)
 {
 	struct lxc_container *p;
 	char *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];

commit 42342bed255ed2cb72e371e1890c264f04201042
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Fri Sep 11 08:07:37 2015 +0200

    Ensure that mmap()ed memory is \0-terminated (v3)
    
    Use pwrite() to write terminating \0-byte
    
    This allows us to use standard string handling functions and we can avoid using
    the GNU-extension memmem(). This simplifies removing the container from the
    lxc_snapshots file. Wrap strstr() in a while loop to remove duplicate entries.
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0eaf98e..0ba4fc0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1983,13 +1983,13 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 {
 	FILE *f1;
 	struct stat fbuf;
-	char *buf = NULL;
-	char *del;
+	void *buf = NULL;
+	char *del = NULL;
 	char path[MAXPATHLEN];
 	char newpath[MAXPATHLEN];
 	int fd, ret, n = 0, v = 0;
 	bool bret = false;
-	size_t len, difflen;
+	size_t len = 0, bytes = 0;
 
 	if (container_disk_lock(c0))
 		return false;
@@ -2049,55 +2049,49 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 				goto out;
 			}
 		} else if (!inc) {
-			fd = open(path, O_RDWR | O_CLOEXEC);
-			if (fd < 0)
-				goto out;
+                        if ((fd = open(path, O_RDWR | O_CLOEXEC)) < 0)
+                                goto out;
 
-			ret = fstat(fd, &fbuf);
-			if (ret < 0) {
-				close(fd);
-				goto out;
-			}
+                        if (fstat(fd, &fbuf) < 0) {
+                                close(fd);
+                                goto out;
+                        }
 
-			if (fbuf.st_size != 0) {
-				buf = mmap(NULL, fbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-				if (buf == MAP_FAILED) {
-					SYSERROR("Failed to create mapping %s", path);
-					close(fd);
-					goto out;
-				}
-			}
-
-			len = strlen(newpath);
+                        if (fbuf.st_size != 0) {
+                                /* write terminating \0-byte to file */
+                                if (pwrite(fd, "", 1, fbuf.st_size) <= 0) {
+                                        close(fd);
+                                        goto out;
+                                }
 
-			/* mmap()ed memory is only \0-terminated when it is not
-			 * a multiple of a pagesize. Hence, we'll use memmem(). */
-                        if ((del = memmem(buf, fbuf.st_size, newpath, len))) {
-                                /* remove container entry */
-                                if (del != buf + fbuf.st_size - len) {
-                                        difflen = fbuf.st_size - (del-buf);
-                                        memmove(del, del + len, strnlen(del, difflen) - len);
+                                buf = mmap(NULL, fbuf.st_size + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+                                if (buf == MAP_FAILED) {
+                                        SYSERROR("Failed to create mapping %s", path);
+                                        close(fd);
+                                        goto out;
                                 }
 
-                                munmap(buf, fbuf.st_size);
+                                len = strlen(newpath);
+                                while ((del = strstr((char *)buf, newpath))) {
+                                        memmove(del, del + len, strlen(del) - len + 1);
+                                        bytes += len;
+                                }
 
-                                if (ftruncate(fd, fbuf.st_size - len) < 0) {
+                                munmap(buf, fbuf.st_size + 1);
+                                if (ftruncate(fd, fbuf.st_size - bytes) < 0) {
                                         SYSERROR("Failed to truncate file %s", path);
                                         close(fd);
                                         goto out;
                                 }
-                        } else {
-                                munmap(buf, fbuf.st_size);
-			}
-
-			close(fd);
-		}
+                        }
+                        close(fd);
+                }
 
 		/* If the lxc-snapshot file is empty, remove it. */
 		if (stat(path, &fbuf) < 0)
 			goto out;
-		if (!fbuf.st_size) {
-			remove(path);
+                if (!fbuf.st_size) {
+                        remove(path);
 		}
 	}
 

commit 297c2d5893fc8f1290a90c8dc44295738dc0b0a3
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Tue Sep 8 22:37:15 2015 +0200

    Destroy bdevs using bdev_destroy() from bdev.h
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fb99892..0eaf98e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2217,48 +2217,25 @@ static bool has_snapshots(struct lxc_container *c)
 	return count > 0;
 }
 
+static bool do_destroy_container(struct lxc_conf *conf) {
+        if (am_unpriv()) {
+                if (userns_exec_1(conf, bdev_destroy_wrapper, conf) < 0)
+                        return false;
+                return true;
+        }
+        return bdev_destroy(conf);
+}
+
 static int lxc_rmdir_onedev_wrapper(void *data)
 {
 	char *arg = (char *) data;
 	return lxc_rmdir_onedev(arg, "snaps");
 }
 
-static int do_bdev_destroy(struct lxc_conf *conf)
-{
-	struct bdev *r;
-	int ret = 0;
-
-	r = bdev_init(conf, conf->rootfs.path, conf->rootfs.mount, NULL);
-	if (!r)
-		return -1;
-
-	if (r->ops->destroy(r) < 0)
-		ret = -1;
-	bdev_put(r);
-	return ret;
-}
-
-static int bdev_destroy_wrapper(void *data)
-{
-	struct lxc_conf *conf = data;
-
-	if (setgid(0) < 0) {
-		ERROR("Failed to setgid to 0");
-		return -1;
-	}
-	if (setgroups(0, NULL) < 0)
-		WARN("Failed to clear groups");
-	if (setuid(0) < 0) {
-		ERROR("Failed to setuid to 0");
-		return -1;
-	}
-	return do_bdev_destroy(conf);
-}
-
 static bool container_destroy(struct lxc_container *c)
 {
 	bool bret = false;
-	int ret;
+	int ret = 0;
 	struct lxc_conf *conf;
 
 	if (!c || !do_lxcapi_is_defined(c))
@@ -2310,16 +2287,13 @@ static bool container_destroy(struct lxc_container *c)
 		}
 	}
 
-	if (conf && conf->rootfs.path && conf->rootfs.mount) {
-		if (am_unpriv())
-			ret = userns_exec_1(conf, bdev_destroy_wrapper, conf);
-		else
-			ret = do_bdev_destroy(conf);
-		if (ret < 0) {
-			ERROR("Error destroying rootfs for %s", c->name);
-			goto out;
-		}
-	}
+        if (conf && conf->rootfs.path && conf->rootfs.mount) {
+                if (!do_destroy_container(conf)) {
+                        ERROR("Error destroying rootfs for %s", c->name);
+                        goto out;
+                }
+                INFO("Destroyed rootfs for %s", c->name);
+        }
 
 	mod_all_rdeps(c, false);
 
@@ -2334,6 +2308,8 @@ static bool container_destroy(struct lxc_container *c)
 		ERROR("Error destroying container directory for %s", c->name);
 		goto out;
 	}
+        INFO("Destroyed directory for %s", c->name);
+
 	bret = true;
 
 out:

commit f08fee55a1f0ca62c2c97a2d2fd5ef1d7fbae8ee
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Mon Sep 7 23:41:35 2015 +0200

    Do not use strlen() on non-null terminated buffer
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 932d658..fb99892 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1989,7 +1989,7 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 	char newpath[MAXPATHLEN];
 	int fd, ret, n = 0, v = 0;
 	bool bret = false;
-	size_t len;
+	size_t len, difflen;
 
 	if (container_disk_lock(c0))
 		return false;
@@ -2072,19 +2072,22 @@ static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc
 
 			/* mmap()ed memory is only \0-terminated when it is not
 			 * a multiple of a pagesize. Hence, we'll use memmem(). */
-			if ((del = memmem(buf, fbuf.st_size, newpath, len))) {
-				/* remove container entry */
-				memmove(del, del + len, strlen(del) - len + 1);
-
-				munmap(buf, fbuf.st_size);
-
-				if (ftruncate(fd, fbuf.st_size - len) < 0) {
-					SYSERROR("Failed to truncate file %s", path);
-					close(fd);
-					goto out;
-				}
-			} else {
-				munmap(buf, fbuf.st_size);
+                        if ((del = memmem(buf, fbuf.st_size, newpath, len))) {
+                                /* remove container entry */
+                                if (del != buf + fbuf.st_size - len) {
+                                        difflen = fbuf.st_size - (del-buf);
+                                        memmove(del, del + len, strnlen(del, difflen) - len);
+                                }
+
+                                munmap(buf, fbuf.st_size);
+
+                                if (ftruncate(fd, fbuf.st_size - len) < 0) {
+                                        SYSERROR("Failed to truncate file %s", path);
+                                        close(fd);
+                                        goto out;
+                                }
+                        } else {
+                                munmap(buf, fbuf.st_size);
 			}
 
 			close(fd);

commit 0f4cdd778133cada7ca27288bd84a4d80a0a0e9a
Author: David Ward <david.ward@ll.mit.edu>
Date:   Tue Jun 23 10:57:24 2015 -0400

    When creating container, save configuration if rootfs already exists
    
    Commit 6c6892b "fix multithreaded create()" prevented the container
    configuration from being saved if the backing store does not need
    to be created.
    
    Signed-off-by: David Ward <david.ward@ll.mit.edu>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ce2ec8a..932d658 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1383,6 +1383,8 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 	if (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
 		/* Rootfs already existed, user just wanted to save the
 		 * loaded configuration */
+		if (!c->save_config(c, NULL))
+			ERROR("failed to save starting configuration for %s\n", c->name);
 		ret = true;
 		goto out;
 	}

commit 00370edd533c2a6851aa145b7045fc6fcdb621c8
Author: David Ward <david.ward@ll.mit.edu>
Date:   Tue Jun 23 10:57:25 2015 -0400

    Fix container creation without a rootfs
    
    It is not an error to create a container without a template or rootfs.
    
    Signed-off-by: David Ward <david.ward@ll.mit.edu>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 45b1798..ce2ec8a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1365,13 +1365,18 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 		goto free_tpath;
 
 	/*
-	 * either template or rootfs.path should be set.
 	 * if both template and rootfs.path are set, template is setup as rootfs.path.
 	 * container is already created if we have a config and rootfs.path is accessible
 	 */
-	if (!c->lxc_conf->rootfs.path && !tpath)
-		/* no template passed in and rootfs does not exist: error */
+	if (!c->lxc_conf->rootfs.path && !tpath) {
+		/* no template passed in and rootfs does not exist */
+		if (!c->save_config(c, NULL)) {
+			ERROR("failed to save starting configuration for %s\n", c->name);
+			goto out;
+		}
+		ret = true;
 		goto out;
+	}
 	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
 		/* rootfs passed into configuration, but does not exist: error */
 		goto out;

commit 0ea055b395656950608c9b82009a31344898a035
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Tue Aug 11 10:33:46 2015 +0200

    mod_rdep(): Write path and name of clone to file
    
    If we currently create clone-snapshots via lxc-clone only the plain total
    number of the containers it serves as a base-container is written to the file
    "lxc-snapshots". This commit modifies mod_rdep() so it will store the paths and
    names to the containers that are clone-snapshots (similar to the "lxc_rdepends"
    file for the clones). **Users which still have containers that have a non-empty
    (with a number > 0 as an entry) "lxc-snapshots" file in the old format are not
    affected by this change. It will be used until all old clones have been
    deleted!** For all others, the "lxc_snapshots" file placed under the original
    container now looks like this:
    
          /var/lib/lxc
          bb
          /var/lib/lxc
          cc
          /opt
          dd
    
    This is an example of a container that provides the base for three
    clone-snapshots bb, cc, and dd. Where bb and cc both are placed in the usual
    path for privileged containers and dd is placed in a custom path.
    
    - Add additional argument to function that takes in the clone-snapshotted
      lxc_container.
    - Have mod_rdep() write the path and name of the clone-snapshotted container the
      file lxc_snapshots of the original container.
    - If a clone-snapshot gets deleted the corresponding line in the file
      lxc_snapshot of the original container will be deleted and the file updated
      via mmap() + memmove() + munmap().
    - Adapt has_fs_snapshots().
    - **If an lxc-snapshot file in the old format is found we'll keep using it.**
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5291634..f022f0d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -19,6 +19,7 @@
  */
 
 #define _GNU_SOURCE
+#include <sys/mman.h>
 #include <assert.h>
 #include <stdarg.h>
 #include <pthread.h>
@@ -1970,47 +1971,130 @@ out:
 
 WRAP_API_1(bool, lxcapi_save_config, const char *)
 
-static bool mod_rdep(struct lxc_container *c, bool inc)
+
+static bool mod_rdep(struct lxc_container *c0, struct lxc_container *c, bool inc)
 {
+	FILE *f1;
+	struct stat fbuf;
+	char *buf = NULL;
+	char *del;
 	char path[MAXPATHLEN];
-	int ret, v = 0;
-	FILE *f;
+	char newpath[MAXPATHLEN];
+	int fd, ret, n = 0, v = 0;
 	bool bret = false;
+	size_t len;
 
-	if (container_disk_lock(c))
+	if (container_disk_lock(c0))
 		return false;
-	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_snapshots", c->config_path,
-			c->name);
+
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_snapshots", c0->config_path, c0->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
-	f = fopen(path, "r");
-	if (f) {
-		ret = fscanf(f, "%d", &v);
-		fclose(f);
-		if (ret != 1) {
-			ERROR("Corrupted file %s", path);
-			goto out;
-		}
-	}
-	v += inc ? 1 : -1;
-	f = fopen(path, "w");
-	if (!f)
-		goto out;
-	if (fprintf(f, "%d\n", v) < 0) {
-		ERROR("Error writing new snapshots value");
-		fclose(f);
+	ret = snprintf(newpath, MAXPATHLEN, "%s\n%s\n", c->config_path, c->name);
+	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
+
+	/* If we find an lxc-snapshot file using the old format only listing the
+	 * number of snapshots we will keep using it. */
+	f1 = fopen(path, "r");
+	if (f1) {
+		n = fscanf(f1, "%d", &v);
+		fclose(f1);
+		if (n == 1 && v == 0) {
+			remove(path);
+			n = 0;
+		}
 	}
-	ret = fclose(f);
-	if (ret != 0) {
-		SYSERROR("Error writing to or closing snapshots file");
-		goto out;
+	if (n == 1) {
+		v += inc ? 1 : -1;
+		f1 = fopen(path, "w");
+		if (!f1)
+			goto out;
+		if (fprintf(f1, "%d\n", v) < 0) {
+			ERROR("Error writing new snapshots value");
+			fclose(f1);
+			goto out;
+		}
+		ret = fclose(f1);
+		if (ret != 0) {
+			SYSERROR("Error writing to or closing snapshots file");
+			goto out;
+		}
+	} else {
+		/* Here we know that we have or can use an lxc-snapshot file
+		 * using the new format. */
+		if (inc) {
+			f1 = fopen(path, "a");
+			if (!f1)
+				goto out;
+
+			if (fprintf(f1, "%s", newpath) < 0) {
+				ERROR("Error writing new snapshots entry");
+				ret = fclose(f1);
+				if (ret != 0)
+					SYSERROR("Error writing to or closing snapshots file");
+				goto out;
+			}
+
+			ret = fclose(f1);
+			if (ret != 0) {
+				SYSERROR("Error writing to or closing snapshots file");
+				goto out;
+			}
+		} else if (!inc) {
+			fd = open(path, O_RDWR | O_CLOEXEC);
+			if (fd < 0)
+				goto out;
+
+			ret = fstat(fd, &fbuf);
+			if (ret < 0) {
+				close(fd);
+				goto out;
+			}
+
+			if (fbuf.st_size != 0) {
+				buf = mmap(NULL, fbuf.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+				if (buf == MAP_FAILED) {
+					SYSERROR("Failed to create mapping %s", path);
+					close(fd);
+					goto out;
+				}
+			}
+
+			len = strlen(newpath);
+
+			/* mmap()ed memory is only \0-terminated when it is not
+			 * a multiple of a pagesize. Hence, we'll use memmem(). */
+			if ((del = memmem(buf, fbuf.st_size, newpath, len))) {
+				/* remove container entry */
+				memmove(del, del + len, strlen(del) - len + 1);
+
+				munmap(buf, fbuf.st_size);
+
+				if (ftruncate(fd, fbuf.st_size - len) < 0) {
+					SYSERROR("Failed to truncate file %s", path);
+					close(fd);
+					goto out;
+				}
+			} else {
+				munmap(buf, fbuf.st_size);
+			}
+
+			close(fd);
+		}
+
+		/* If the lxc-snapshot file is empty, remove it. */
+		if (stat(path, &fbuf) < 0)
+			goto out;
+		if (!fbuf.st_size) {
+			remove(path);
+		}
 	}
 
 	bret = true;
 
 out:
-	container_disk_unlock(c);
+	container_disk_unlock(c0);
 	return bret;
 }
 
@@ -2052,8 +2136,8 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 				lxcpath, lxcname);
 			continue;
 		}
-		if (!mod_rdep(p, inc))
-			ERROR("Failed to increase numsnapshots for %s:%s",
+		if (!mod_rdep(p, c, inc))
+			ERROR("Failed to update snapshots file for %s:%s",
 				lxcpath, lxcname);
 		lxc_container_put(p);
 	}
@@ -2065,22 +2149,30 @@ out:
 
 static bool has_fs_snapshots(struct lxc_container *c)
 {
+	FILE *f;
 	char path[MAXPATHLEN];
 	int ret, v;
-	FILE *f;
+	struct stat fbuf;
 	bool bret = false;
 
 	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_snapshots", c->config_path,
 			c->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
-	f = fopen(path, "r");
-	if (!f)
-		goto out;
-	ret = fscanf(f, "%d", &v);
-	fclose(f);
-	if (ret != 1)
+	/* If the file doesn't exist there are no snapshots. */
+	if (stat(path, &fbuf) < 0)
 		goto out;
+	v = fbuf.st_size;
+	if (v != 0) {
+		f = fopen(path, "r");
+		if (!f)
+			goto out;
+		ret = fscanf(f, "%d", &v);
+		fclose(f);
+		// TODO: Figure out what to do with the return value of fscanf.
+		if (ret != 1)
+			INFO("Container uses new lxc-snapshots format %s", path);
+	}
 	bret = v != 0;
 
 out:

commit 3d7ad474b07937d39c6c8d7c7fcba67a46900eb0
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Fri Aug 14 20:17:21 2015 +0200

    Make LXC_CLONE_KEEPNAME work
    
    - Passing the LXC_CLONE_KEEPNAME flag to do_lxcapi_clone() was not respected and
      let to unexpected behaviour for e.g. lxc-clone. We wrap
      clear_unexp_config_line() and set_config_item_line() in an appropriate
      if-condition.
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4918aab..5291634 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2906,12 +2906,15 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	if (ret < 0)
 		goto out;
 
-	clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
 
 	// update utsname
-	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
-		ERROR("Error setting new hostname");
-		goto out;
+	if (!(flags & LXC_CLONE_KEEPNAME)) {
+		clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
+
+		if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
+			ERROR("Error setting new hostname");
+			goto out;
+		}
 	}
 
 	// copy hooks

commit ab7efcf51d369a4dae93c14653f6519fc5ec4d47
Author: Robert Schiele <rschiele@gmail.com>
Date:   Fri Aug 21 07:35:34 2015 +0200

    check for NULL pointers before calling setenv()
    
    Latest glibc release actually honours calling setenv with a NULL
    pointer by causing SIGSEGV but checking pointers before submitting
    to any system function is a good idea anyway.
    
    Signed-off-by: Robert Schiele <rschiele@gmail.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4918aab..d7da125 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2174,16 +2174,16 @@ static bool container_destroy(struct lxc_container *c)
 
 	if (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {
 		/* Start of environment variable setup for hooks */
-		if (setenv("LXC_NAME", c->name, 1)) {
+		if (c->name && setenv("LXC_NAME", c->name, 1)) {
 			SYSERROR("failed to set environment variable for container name");
 		}
-		if (setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
+		if (conf->rcfile && setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
 			SYSERROR("failed to set environment variable for config path");
 		}
-		if (setenv("LXC_ROOTFS_MOUNT", conf->rootfs.mount, 1)) {
+		if (conf->rootfs.mount && setenv("LXC_ROOTFS_MOUNT", conf->rootfs.mount, 1)) {
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
-		if (setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
+		if (conf->rootfs.path && setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
 		if (conf->console.path && setenv("LXC_CONSOLE", conf->console.path, 1)) {
@@ -2743,19 +2743,19 @@ static int clone_update_rootfs(struct clone_update_data *data)
 
 	if (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {
 		/* Start of environment variable setup for hooks */
-		if (setenv("LXC_SRC_NAME", c0->name, 1)) {
+		if (c0->name && setenv("LXC_SRC_NAME", c0->name, 1)) {
 			SYSERROR("failed to set environment variable for source container name");
 		}
-		if (setenv("LXC_NAME", c->name, 1)) {
+		if (c->name && setenv("LXC_NAME", c->name, 1)) {
 			SYSERROR("failed to set environment variable for container name");
 		}
-		if (setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
+		if (conf->rcfile && setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
 			SYSERROR("failed to set environment variable for config path");
 		}
-		if (setenv("LXC_ROOTFS_MOUNT", bdev->dest, 1)) {
+		if (bdev->dest && setenv("LXC_ROOTFS_MOUNT", bdev->dest, 1)) {
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
-		if (setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
+		if (conf->rootfs.path && setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
 

commit 965ef7f4600e556a91db4f5ecd3f084a28ede6c1
Author: Serge Hallyn <serge@hallyn.com>
Date:   Fri Aug 14 10:59:19 2015 -0500

    Revert "Refactor lxc-snapshot, lxc-clone, make LXC_CLONE_KEEPNAME work and add option to destroy container with all snapshots to lxc-destroy"

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5291634..4918aab 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2906,15 +2906,12 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	if (ret < 0)
 		goto out;
 
+	clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
 
 	// update utsname
-	if (!(flags & LXC_CLONE_KEEPNAME)) {
-		clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
-
-		if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
-			ERROR("Error setting new hostname");
-			goto out;
-		}
+	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
+		ERROR("Error setting new hostname");
+		goto out;
 	}
 
 	// copy hooks

commit ec8449f8dcf3bdffd9600a6152aa067521e01baa
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Aug 10 11:12:18 2015 -0600

    c/r: get rid of dump_net_info()
    
    This was originally used to propagate the bridge and veth names across
    hosts, but now we extract both from the container's config file, and
    nothing reads the files that dump_net_info() writes, so let's just get rid
    of them.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 223e78e..f1bd979 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3733,9 +3733,6 @@ static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool
 		return false;
 	}
 
-	if (!dump_net_info(c, directory))
-		return false;
-
 	pid = fork();
 	if (pid < 0)
 		return false;

commit 8bee8851308142a428134cc53a6c1d7db14bfac4
Author: Wolfgang Bumiller <w.bumiller@proxmox.com>
Date:   Mon Jul 27 07:33:08 2015 +0200

    pass on reboot flag and delete old veth on reboot
    
    When setting lxc.network.veth.pair to get a fixed interface
    name the recreation of it after a reboot caused an EEXIST.
    -) The reboot flag is now a three-state value. It's set to
    1 to request a reboot, and 2 during a reboot until after
    lxc_spawn where it is reset to 0.
    -) If the reboot is set (!= 0) within instantiate_veth and
    a fixed name is used, the interface is now deleted before
    being recreated.
    
    Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1c103e8..223e78e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -760,9 +760,9 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 		pid_fp = NULL;
 	}
 
-reboot:
 	conf->reboot = 0;
 
+reboot:
 	if (lxc_check_inherited(conf, daemonize, -1)) {
 		ERROR("Inherited fds found");
 		ret = 1;
@@ -772,9 +772,9 @@ reboot:
 	ret = lxc_start(c->name, argv, conf, c->config_path, daemonize);
 	c->error_num = ret;
 
-	if (conf->reboot) {
+	if (conf->reboot == 1) {
 		INFO("container requested reboot");
-		conf->reboot = 0;
+		conf->reboot = 2;
 		goto reboot;
 	}
 

commit 222dc581ce28b75ecc59f7d2747ac7a31c397743
Author: Robert LeBlanc <rdleblanc@bluehost.com>
Date:   Thu Aug 13 14:14:52 2015 -0600

    Small trivial typo.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1c103e8..38d8377 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2666,7 +2666,7 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	// We will simply append a new lxc.rootfs entry to the unexpanded config
 	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs", false);
 	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs", c->lxc_conf->rootfs.path)) {
-		ERROR("Error saving new rootfs to cloend config");
+		ERROR("Error saving new rootfs to cloned config");
 		return -1;
 	}
 	if (flags & LXC_CLONE_SNAPSHOT)

commit eab218fbf7c70ab3143440ef1165e5bdd4f51a71
Author: Christian Brauner <christianvanbrauner@gmail.com>
Date:   Sat Aug 8 01:31:21 2015 +0200

    Make LXC_CLONE_KEEPNAME work
    
    Passing the LXC_CLONE_KEEPNAME flag to do_lxcapi_clone() was not respected. We
    wrap clear_unexp_config_line() and set_config_item_line() in an appropriate
    if-condition.
    
    Signed-off-by: Christian Brauner <christianvanbrauner@gmail.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1c103e8..bf942ac 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2906,12 +2906,15 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	if (ret < 0)
 		goto out;
 
-	clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
 
 	// update utsname
-	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
-		ERROR("Error setting new hostname");
-		goto out;
+	if (!(flags & LXC_CLONE_KEEPNAME)) {
+		clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
+
+		if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
+			ERROR("Error setting new hostname");
+			goto out;
+		}
 	}
 
 	// copy hooks

commit 13353dc420e3a7b6ff1234b0ce9fbd3a1802837c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jun 10 23:08:15 2015 -0500

    daemonized start: exit children on failure, don't return
    
    When starting a daemonized container, only the original parent
    thread should return to the caller.  The first forked child
    immediately exits after forking, but the grandparent child
    was in some places returning on error - causing a second instance
    of the calling function.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Tycho Andersen <tycho.andersen@canonical.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7708a8c..1c103e8 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -712,19 +712,19 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 		pid = fork();
 		if (pid < 0) {
 			SYSERROR("Error doing dual-fork");
-			return false;
+			exit(1);
 		}
 		if (pid != 0)
 			exit(0);
 		/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
 		if (chdir("/")) {
 			SYSERROR("Error chdir()ing to /.");
-			return false;
+			exit(1);
 		}
 		lxc_check_inherited(conf, true, -1);
 		if (null_stdfds() < 0) {
 			ERROR("failed to close fds");
-			return false;
+			exit(1);
 		}
 		setsid();
 	} else {
@@ -742,6 +742,8 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 		if (pid_fp == NULL) {
 			SYSERROR("Failed to create pidfile '%s' for '%s'",
 				 c->pidfile, c->name);
+			if (daemonize)
+				exit(1);
 			return false;
 		}
 
@@ -749,6 +751,8 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 			SYSERROR("Failed to write '%s'", c->pidfile);
 			fclose(pid_fp);
 			pid_fp = NULL;
+			if (daemonize)
+				exit(1);
 			return false;
 		}
 

commit 69aeabac1ad21cdc55f0f7866cf64559d7215ab2
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Jun 10 21:57:50 2015 +0000

    uniformly nullify std fds
    
    In various places throughout the code, we want to "nullify" the std fds,
    opening them to /dev/null or zero or so. Instead, let's unify this code and do
    it in such a way that Coverity (probably) won't complain.
    
    v2: use /dev/null for stdin as well
    v3: add a comment about use of C's short circuiting
    v4: axe comment, check errors on dup2, s/quiet/need_null_stdfds
    
    Reported-by: Coverity
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 445cc22..7708a8c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -722,12 +722,10 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 			return false;
 		}
 		lxc_check_inherited(conf, true, -1);
-		close(0);
-		close(1);
-		close(2);
-		open("/dev/zero", O_RDONLY);
-		open("/dev/null", O_RDWR);
-		open("/dev/null", O_RDWR);
+		if (null_stdfds() < 0) {
+			ERROR("failed to close fds");
+			return false;
+		}
 		setsid();
 	} else {
 		if (!am_single_threaded()) {
@@ -956,7 +954,7 @@ static char *lxcbasename(char *path)
 	return p;
 }
 
-static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet,
+static bool create_run_template(struct lxc_container *c, char *tpath, bool need_null_stdfds,
 				char *const argv[])
 {
 	pid_t pid;
@@ -978,13 +976,8 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		char **newargv;
 		struct lxc_conf *conf = c->lxc_conf;
 
-		if (quiet) {
-			close(0);
-			close(1);
-			close(2);
-			open("/dev/zero", O_RDONLY);
-			open("/dev/null", O_RDWR);
-			open("/dev/null", O_RDWR);
+		if (need_null_stdfds && null_stdfds() < 0) {
+			exit(1);
 		}
 
 		src = c->lxc_conf->rootfs.path;

commit a70a69e8a042d31e96258488f6d7228b8eac8d6b
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jun 3 17:20:19 2015 +0000

    don't dereference a NULL c->lxc_conf
    
    Commit 37cf711b added a destroy hook, but when it checks
    at destroy time whether that hook exists, it assumes that
    c->lxc_conf is good.  In fact lxc_conf can be NULL, so check
    for that.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 916c99c..445cc22 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2160,11 +2160,12 @@ static bool container_destroy(struct lxc_container *c)
 {
 	bool bret = false;
 	int ret;
-	struct lxc_conf *conf = c->lxc_conf;
+	struct lxc_conf *conf;
 
 	if (!c || !do_lxcapi_is_defined(c))
 		return false;
 
+	conf = c->lxc_conf;
 	if (container_disk_lock(c))
 		return false;
 
@@ -2174,7 +2175,7 @@ static bool container_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (!lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {
+	if (conf && !lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {
 		/* Start of environment variable setup for hooks */
 		if (setenv("LXC_NAME", c->name, 1)) {
 			SYSERROR("failed to set environment variable for container name");

commit 454ec0abc7f315fa4894c43488c981f369cacce9
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jun 2 22:33:34 2015 +0000

    api_start: always close fds 0-2 when daemonized
    
    commit 507cee3618237d3 moved the close and re-open of fds 0-2 into
    do_start.  But this means that the lxc monitor itself keeps the
    caller's fds 0-2 open, which is wrong for daemonized containers.
    
    Closes #548
    
    Reported-by: Mathieu Le Marec - Pasquet <kiorky@cryptelium.net>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fd56327..916c99c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -722,6 +722,12 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 			return false;
 		}
 		lxc_check_inherited(conf, true, -1);
+		close(0);
+		close(1);
+		close(2);
+		open("/dev/zero", O_RDONLY);
+		open("/dev/null", O_RDWR);
+		open("/dev/null", O_RDWR);
 		setsid();
 	} else {
 		if (!am_single_threaded()) {

commit 37cf711b2887dbce0921eb653b8bc7cb27a02fee
Author: Sungbae Yoo <sungbae.yoo@samsung.com>
Date:   Tue May 12 16:56:12 2015 +0900

    config : add lxc.hook.destroy option
    
    Signed-off-by: Sungbae Yoo <sungbae.yoo@samsung.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8999f44..fd56327 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2154,6 +2154,7 @@ static bool container_destroy(struct lxc_container *c)
 {
 	bool bret = false;
 	int ret;
+	struct lxc_conf *conf = c->lxc_conf;
 
 	if (!c || !do_lxcapi_is_defined(c))
 		return false;
@@ -2167,19 +2168,47 @@ static bool container_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (current_config && c->lxc_conf == current_config) {
+	if (!lxc_list_empty(&conf->hooks[LXCHOOK_DESTROY])) {
+		/* Start of environment variable setup for hooks */
+		if (setenv("LXC_NAME", c->name, 1)) {
+			SYSERROR("failed to set environment variable for container name");
+		}
+		if (setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
+			SYSERROR("failed to set environment variable for config path");
+		}
+		if (setenv("LXC_ROOTFS_MOUNT", conf->rootfs.mount, 1)) {
+			SYSERROR("failed to set environment variable for rootfs mount");
+		}
+		if (setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
+			SYSERROR("failed to set environment variable for rootfs mount");
+		}
+		if (conf->console.path && setenv("LXC_CONSOLE", conf->console.path, 1)) {
+			SYSERROR("failed to set environment variable for console path");
+		}
+		if (conf->console.log_path && setenv("LXC_CONSOLE_LOGPATH", conf->console.log_path, 1)) {
+			SYSERROR("failed to set environment variable for console log");
+		}
+		/* End of environment variable setup for hooks */
+
+		if (run_lxc_hooks(c->name, "destroy", conf, c->get_config_path(c), NULL)) {
+			ERROR("Error executing clone hook for %s", c->name);
+			goto out;
+		}
+	}
+
+	if (current_config && conf == current_config) {
 		current_config = NULL;
-		if (c->lxc_conf->logfd != -1) {
-			close(c->lxc_conf->logfd);
-			c->lxc_conf->logfd = -1;
+		if (conf->logfd != -1) {
+			close(conf->logfd);
+			conf->logfd = -1;
 		}
 	}
 
-	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
+	if (conf && conf->rootfs.path && conf->rootfs.mount) {
 		if (am_unpriv())
-			ret = userns_exec_1(c->lxc_conf, bdev_destroy_wrapper, c->lxc_conf);
+			ret = userns_exec_1(conf, bdev_destroy_wrapper, conf);
 		else
-			ret = do_bdev_destroy(c->lxc_conf);
+			ret = do_bdev_destroy(conf);
 		if (ret < 0) {
 			ERROR("Error destroying rootfs for %s", c->name);
 			goto out;
@@ -2192,7 +2221,7 @@ static bool container_destroy(struct lxc_container *c)
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
 	if (am_unpriv())
-		ret = userns_exec_1(c->lxc_conf, lxc_rmdir_onedev_wrapper, path);
+		ret = userns_exec_1(conf, lxc_rmdir_onedev_wrapper, path);
 	else
 		ret = lxc_rmdir_onedev(path, "snaps");
 	if (ret < 0) {

commit 85c50991da2a5b20756bdfbc5a147b14690855b7
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Apr 24 14:46:08 2015 -0600

    c/r: check for criu images in the checkpoint directory
    
    CRIU can get confused if there are two dumps that are written to the same
    directory, so we make some minimal effort to prevent people from doing this.
    This is a better alternative than forcing liblxc to create the directory, since
    it is mostly race free (and neither solution is bullet proof anyway if someone
    rsyncs some bad images over the top of the good ones).
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index dbcee99..8999f44 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3683,6 +3683,7 @@ static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool
 {
 	pid_t pid;
 	int status;
+	char path[PATH_MAX];
 
 	if (!criu_ok(c))
 		return false;
@@ -3690,6 +3691,15 @@ static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool
 	if (mkdir(directory, 0700) < 0 && errno != EEXIST)
 		return false;
 
+	status = snprintf(path, sizeof(path), "%s/inventory.img", directory);
+	if (status < 0 || status >= sizeof(path))
+		return false;
+
+	if (access(path, F_OK) == 0) {
+		ERROR("please use a fresh directory for the dump directory\n");
+		return false;
+	}
+
 	if (!dump_net_info(c, directory))
 		return false;
 

commit 858377e4d968c8a7254e22dc7167acf76ac91a48
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 21 09:20:32 2015 -0500

    logs: introduce a thread-local 'current' lxc_config (v2)
    
    The logging code uses a global log_fd and log_level to direct
    logging (ERROR(), etc).  While the container configuration file allows
    for lxc.loglevel and lxc.logfile, those are only used at configuration
    file read time to set the global variables.  This works ok in the
    lxc front-end programs, but becomes a problem with threaded API users.
    
    The simplest solution would be to not allow per-container configuration
    files, but it'd be nice to avoid that.
    
    Passing a logfd or lxc_conf into every ERROR/INFO/etc call is "possible",
    but would be a huge complication as there are many functions, including
    struct member functions and callbacks, which don't have that info and
    would need to get it from somewhere.
    
    So the approach I'm taking here is to say that all real container work
    is done inside api calls, and therefore the API calls themselves can
    set a thread-local variable indicating which log info to use.  If
    unset, then use the global values.  The lxc-* programs, when called
    with a '-o logfile' argument, set a global variable to indicate that
    the user-specified value should be used.
    
    In this patch:
    
    If the lxc container configuration specifies a loglevel/logfile, only
    set the lxc_config's logfd and loglevel according to those, not the
    global values.
    
    Each API call is wrapped to set/unset the current_config.  (The few
    exceptions are calls which do not result in any log actions)
    
    Update logfile appender to use the logfile specified in lxc_conf if (a)
    current_config is set and (b) the lxc-* command did not override it.
    
    Changelog (2015-04-21):
    	. always re-set current_config to NULL at end of an API
    	  call, rather than storing the previous value.  We don't
    	  nest API calls.
    	. remove the log_lock stuff which wasn't used
    	. lxc_conf_free: if the config is current_config, set
    	  current_config to NULL.  (It can't be another thread's
    	  current_config, or we wouldn't be freeing it)
    	. lxc_check_inherited: don't close fd if it is the
    	  current_config->logfd.  Note this is only called when
    	  starting a container, so we have no other threads at
    	  this point.
    
    Changelog (2015-04-22)
    	. Unset the per-container logfd on destroy
    	.
    	. Do so before we rm the containerdir.  Otherwise if the logfile is set
    	. to $lxcpath/$name/log, the containerdir won't be fully deleted.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d49426f..dbcee99 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -92,6 +92,15 @@ return -1;
 
 lxc_log_define(lxc_container, lxc);
 
+static bool do_lxcapi_destroy(struct lxc_container *c);
+static const char *lxcapi_get_config_path(struct lxc_container *c);
+#define do_lxcapi_get_config_path(c) lxcapi_get_config_path(c)
+static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
+static bool container_destroy(struct lxc_container *c);
+static bool get_snappath_dir(struct lxc_container *c, char *snappath);
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
+static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);
+
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
 	/* $lxcpath + '/' + $cname + '/config' + \0 */
@@ -308,7 +317,7 @@ int lxc_container_put(struct lxc_container *c)
 	return 0;
 }
 
-static bool lxcapi_is_defined(struct lxc_container *c)
+static bool do_lxcapi_is_defined(struct lxc_container *c)
 {
 	struct stat statbuf;
 	bool ret = false;
@@ -331,7 +340,49 @@ out:
 	return ret;
 }
 
-static const char *lxcapi_state(struct lxc_container *c)
+#define WRAP_API(rettype, fnname)					\
+static rettype fnname(struct lxc_container *c)				\
+{									\
+	rettype ret;							\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c);						\
+	current_config = NULL;						\
+	return ret;							\
+}
+
+#define WRAP_API_1(rettype, fnname, t1)					\
+static rettype fnname(struct lxc_container *c, t1 a1)			\
+{									\
+	rettype ret;							\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1);					\
+	current_config = NULL;						\
+	return ret;							\
+}
+
+#define WRAP_API_2(rettype, fnname, t1, t2)				\
+static rettype fnname(struct lxc_container *c, t1 a1, t2 a2)		\
+{									\
+	rettype ret;							\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1, a2);					\
+	current_config = NULL;						\
+	return ret;							\
+}
+
+#define WRAP_API_3(rettype, fnname, t1, t2, t3)				\
+static rettype fnname(struct lxc_container *c, t1 a1, t2 a2, t3 a3)	\
+{									\
+	rettype ret;							\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1, a2, a3);				\
+	current_config = NULL;						\
+	return ret;							\
+}
+
+WRAP_API(bool, lxcapi_is_defined)
+
+static const char *do_lxcapi_state(struct lxc_container *c)
 {
 	lxc_state_t s;
 
@@ -341,6 +392,8 @@ static const char *lxcapi_state(struct lxc_container *c)
 	return lxc_state2str(s);
 }
 
+WRAP_API(const char *, lxcapi_state)
+
 static bool is_stopped(struct lxc_container *c)
 {
 	lxc_state_t s;
@@ -348,19 +401,21 @@ static bool is_stopped(struct lxc_container *c)
 	return (s == STOPPED);
 }
 
-static bool lxcapi_is_running(struct lxc_container *c)
+static bool do_lxcapi_is_running(struct lxc_container *c)
 {
 	const char *s;
 
 	if (!c)
 		return false;
-	s = lxcapi_state(c);
+	s = do_lxcapi_state(c);
 	if (!s || strcmp(s, "STOPPED") == 0)
 		return false;
 	return true;
 }
 
-static bool lxcapi_freeze(struct lxc_container *c)
+WRAP_API(bool, lxcapi_is_running)
+
+static bool do_lxcapi_freeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -372,7 +427,9 @@ static bool lxcapi_freeze(struct lxc_container *c)
 	return true;
 }
 
-static bool lxcapi_unfreeze(struct lxc_container *c)
+WRAP_API(bool, lxcapi_freeze)
+
+static bool do_lxcapi_unfreeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -384,7 +441,9 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	return true;
 }
 
-static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
+WRAP_API(bool, lxcapi_unfreeze)
+
+static int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
 {
 	int ttyfd;
 	if (!c)
@@ -394,13 +453,23 @@ static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *maste
 	return ttyfd;
 }
 
+WRAP_API_2(int, lxcapi_console_getfd, int *, int *)
+
 static int lxcapi_console(struct lxc_container *c, int ttynum, int stdinfd,
 			  int stdoutfd, int stderrfd, int escape)
 {
-	return lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
+	int ret;
+
+	if (!c)
+		return -1;
+
+	current_config = c->lxc_conf;
+	ret = lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
+	current_config = NULL;
+	return ret;
 }
 
-static pid_t lxcapi_init_pid(struct lxc_container *c)
+static pid_t do_lxcapi_init_pid(struct lxc_container *c)
 {
 	if (!c)
 		return -1;
@@ -408,6 +477,8 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 	return lxc_cmd_get_init_pid(c->name, c->config_path);
 }
 
+WRAP_API(pid_t, lxcapi_init_pid)
+
 static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
@@ -419,7 +490,7 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 	return true;
 }
 
-static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
+static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 {
 	bool ret = false, need_disklock = false;
 	int lret;
@@ -456,7 +527,9 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
-static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
+WRAP_API_1(bool, lxcapi_load_config, const char *)
+
+static bool do_lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -469,7 +542,9 @@ static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 	return true;
 }
 
-static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
+WRAP_API_1(bool, lxcapi_want_daemonize, bool)
+
+static bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -482,7 +557,9 @@ static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 	return true;
 }
 
-static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
+WRAP_API_1(bool, lxcapi_want_close_all_fds, bool)
+
+static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 {
 	int ret;
 
@@ -493,8 +570,9 @@ static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 	return ret == 0;
 }
 
+WRAP_API_2(bool, lxcapi_wait, const char *, int)
 
-static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
+static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)
 {
 	/* we'll probably want to make this timeout configurable? */
 	int timeout = 5, ret, status;
@@ -506,9 +584,11 @@ static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
 	ret = waitpid(pid, &status, 0);
 	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
 		DEBUG("failed waiting for first dual-fork child");
-	return lxcapi_wait(c, "RUNNING", timeout);
+	return do_lxcapi_wait(c, "RUNNING", timeout);
 }
 
+WRAP_API_1(bool, wait_on_daemonized_start, int)
+
 static bool am_single_threaded(void)
 {
 	struct dirent dirent, *direntp;
@@ -541,7 +621,7 @@ static bool am_single_threaded(void)
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
  */
-static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
+static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
 	struct lxc_conf *conf;
@@ -566,7 +646,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	}
 	if (ret == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
-		c->destroy(c);
+		do_lxcapi_destroy(c);
 		return false;
 	} else if (ret == 1) {
 		ERROR("Error: creation of %s is ongoing", c->name);
@@ -703,6 +783,15 @@ out:
 		return (ret == 0 ? true : false);
 }
 
+static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
+{
+	bool ret;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_start(c, useinit, argv);
+	current_config = NULL;
+	return ret;
+}
+
 /*
  * note there MUST be an ending NULL
  */
@@ -716,6 +805,8 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	if (!c)
 		return false;
 
+	current_config = c->lxc_conf;
+
 	va_start(ap, useinit);
 	inargs = lxc_va_arg_list_to_argv(ap, 0, 1);
 	va_end(ap);
@@ -726,7 +817,7 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	}
 
 	/* pass NULL if no arguments were supplied */
-	bret = lxcapi_start(c, useinit, *inargs ? inargs : NULL);
+	bret = do_lxcapi_start(c, useinit, *inargs ? inargs : NULL);
 
 out:
 	if (inargs) {
@@ -736,10 +827,11 @@ out:
 		free(inargs);
 	}
 
+	current_config = NULL;
 	return bret;
 }
 
-static bool lxcapi_stop(struct lxc_container *c)
+static bool do_lxcapi_stop(struct lxc_container *c)
 {
 	int ret;
 
@@ -751,6 +843,8 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
+WRAP_API(bool, lxcapi_stop)
+
 static int do_create_container_dir(const char *path, struct lxc_conf *conf)
 {
 	int ret = -1, lasterr;
@@ -798,9 +892,6 @@ static bool create_container_dir(struct lxc_container *c)
 	return ret == 0;
 }
 
-static const char *lxcapi_get_config_path(struct lxc_container *c);
-static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
-
 /*
  * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
  * it returns a mounted bdev on success, NULL on error.
@@ -820,7 +911,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s", rpath);
 	} else {
-		const char *lxcpath = lxcapi_get_config_path(c);
+		const char *lxcpath = do_lxcapi_get_config_path(c);
 		len = strlen(c->name) + strlen(lxcpath) + 9;
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
@@ -834,7 +925,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		return NULL;
 	}
 
-	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+	do_lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
 
 	/* if we are not root, chown the rootfs dir to root in the
 	 * target uidmap */
@@ -1211,9 +1302,8 @@ static void lxcapi_clear_config(struct lxc_container *c)
 	}
 }
 
-static bool lxcapi_destroy(struct lxc_container *c);
-static bool container_destroy(struct lxc_container *c);
-static bool get_snappath_dir(struct lxc_container *c, char *snappath);
+#define do_lxcapi_clear_config(c) lxcapi_clear_config(c)
+
 /*
  * lxcapi_create:
  * create a container with the given parameters.
@@ -1228,7 +1318,7 @@ static bool get_snappath_dir(struct lxc_container *c, char *snappath);
  * @argv: the arguments to pass to the template, terminated by NULL.  If no
  * arguments, you can just pass NULL.
  */
-static bool lxcapi_create(struct lxc_container *c, const char *t,
+static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags,
 		char *const argv[])
 {
@@ -1254,14 +1344,14 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	 * an existing container.  Return an error, but do NOT delete the
 	 * container.
 	 */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
+	if (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
 			access(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {
 		ERROR("Container %s:%s already exists", c->config_path, c->name);
 		goto free_tpath;
 	}
 
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s", lxc_global_config_value("lxc.default_config"));
 			goto free_tpath;
 		}
@@ -1281,7 +1371,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
 		/* rootfs passed into configuration, but does not exist: error */
 		goto out;
-	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
+	if (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
 		/* Rootfs already existed, user just wanted to save the
 		 * loaded configuration */
 		ret = true;
@@ -1317,7 +1407,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		}
 
 		/* save config file again to store the new rootfs location */
-		if (!c->save_config(c, NULL)) {
+		if (!do_lxcapi_save_config(c, NULL)) {
 			ERROR("failed to save starting configuration for %s", c->name);
 			// parent task won't see bdev in config so we delete it
 			bdev->ops->umount(bdev);
@@ -1340,7 +1430,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 	// now clear out the lxc_conf we have, reload from the created
 	// container
-	lxcapi_clear_config(c);
+	do_lxcapi_clear_config(c);
 
 	if (t) {
 		if (!prepend_lxc_header(c->configfile, tpath, argv)) {
@@ -1361,16 +1451,27 @@ free_tpath:
 	return ret;
 }
 
-static bool lxcapi_reboot(struct lxc_container *c)
+static bool lxcapi_create(struct lxc_container *c, const char *t,
+		const char *bdevtype, struct bdev_specs *specs, int flags,
+		char *const argv[])
+{
+	bool ret;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_create(c, t, bdevtype, specs, flags, argv);
+	current_config = NULL;
+	return ret;
+}
+
+static bool do_lxcapi_reboot(struct lxc_container *c)
 {
 	pid_t pid;
 	int rebootsignal = SIGINT;
 
 	if (!c)
 		return false;
-	if (!c->is_running(c))
+	if (!do_lxcapi_is_running(c))
 		return false;
-	pid = c->init_pid(c);
+	pid = do_lxcapi_init_pid(c);
 	if (pid <= 0)
 		return false;
 	if (c->lxc_conf && c->lxc_conf->rebootsignal)
@@ -1381,7 +1482,9 @@ static bool lxcapi_reboot(struct lxc_container *c)
 
 }
 
-static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
+WRAP_API(bool, lxcapi_reboot)
+
+static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)
 {
 	bool retv;
 	pid_t pid;
@@ -1390,18 +1493,20 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	if (!c)
 		return false;
 
-	if (!c->is_running(c))
+	if (!do_lxcapi_is_running(c))
 		return true;
-	pid = c->init_pid(c);
+	pid = do_lxcapi_init_pid(c);
 	if (pid <= 0)
 		return true;
 	if (c->lxc_conf && c->lxc_conf->haltsignal)
 		haltsignal = c->lxc_conf->haltsignal;
 	kill(pid, haltsignal);
-	retv = c->wait(c, "STOPPED", timeout);
+	retv = do_lxcapi_wait(c, "STOPPED", timeout);
 	return retv;
 }
 
+WRAP_API_1(bool, lxcapi_shutdown, int)
+
 static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags, ...)
 {
@@ -1412,6 +1517,8 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	if (!c)
 		return false;
 
+	current_config = c->lxc_conf;
+
 	/*
 	 * since we're going to wait for create to finish, I don't think we
 	 * need to get a copy of the arguments.
@@ -1424,10 +1531,11 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		goto out;
 	}
 
-	bret = c->create(c, t, bdevtype, specs, flags, args);
+	bret = do_lxcapi_create(c, t, bdevtype, specs, flags, args);
 
 out:
 	free(args);
+	current_config = NULL;
 	return bret;
 }
 
@@ -1445,7 +1553,7 @@ static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)
 		WARN("Error clearing configuration for %s", key);
 }
 
-static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
+static bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 {
 	int ret;
 
@@ -1460,9 +1568,11 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
+WRAP_API_1(bool, lxcapi_clear_config_item, const char *)
+
 static inline bool enter_net_ns(struct lxc_container *c)
 {
-	pid_t pid = c->init_pid(c);
+	pid_t pid = do_lxcapi_init_pid(c);
 
 	if ((geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) && access("/proc/self/ns/user", F_OK) == 0) {
 		if (!switch_to_ns(pid, "user"))
@@ -1542,7 +1652,7 @@ static bool remove_from_array(char ***names, char *cname, int size)
 	return false;
 }
 
-static char** lxcapi_get_interfaces(struct lxc_container *c)
+static char ** do_lxcapi_get_interfaces(struct lxc_container *c)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1629,7 +1739,9 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 	return interfaces;
 }
 
-static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
+WRAP_API(char **, lxcapi_get_interfaces)
+
+static char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1746,7 +1858,9 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 	return addresses;
 }
 
-static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
+WRAP_API_3(char **, lxcapi_get_ips, const char *, const char *, int)
+
+static int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	int ret;
 
@@ -1759,7 +1873,9 @@ static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char
 	return ret;
 }
 
-static char* lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
+WRAP_API_3(int, lxcapi_get_config_item, const char *, char *, int)
+
+static char* do_lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
 {
 	char *ret;
 
@@ -1767,12 +1883,14 @@ static char* lxcapi_get_running_config_item(struct lxc_container *c, const char
 		return NULL;
 	if (container_mem_lock(c))
 		return NULL;
-	ret = lxc_cmd_get_config_item(c->name, key, c->get_config_path(c));
+	ret = lxc_cmd_get_config_item(c->name, key, do_lxcapi_get_config_path(c));
 	container_mem_unlock(c);
 	return ret;
 }
 
-static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
+WRAP_API_1(char *, lxcapi_get_running_config_item, const char *)
+
+static int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	if (!key)
 		return lxc_listconfigs(retv, inlen);
@@ -1792,7 +1910,9 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 	return ret;
 }
 
-static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
+WRAP_API_3(int, lxcapi_get_keys, const char *, char *, int)
+
+static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	FILE *fout;
 	bool ret = false, need_disklock = false;
@@ -1805,7 +1925,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s while saving %s", lxc_global_config_value("lxc.default_config"), c->name);
 			return false;
 		}
@@ -1845,6 +1965,8 @@ out:
 	return ret;
 }
 
+WRAP_API_1(bool, lxcapi_save_config, const char *)
+
 static bool mod_rdep(struct lxc_container *c, bool inc)
 {
 	char path[MAXPATHLEN];
@@ -2033,7 +2155,7 @@ static bool container_destroy(struct lxc_container *c)
 	bool bret = false;
 	int ret;
 
-	if (!c || !lxcapi_is_defined(c))
+	if (!c || !do_lxcapi_is_defined(c))
 		return false;
 
 	if (container_disk_lock(c))
@@ -2045,6 +2167,14 @@ static bool container_destroy(struct lxc_container *c)
 		goto out;
 	}
 
+	if (current_config && c->lxc_conf == current_config) {
+		current_config = NULL;
+		if (c->lxc_conf->logfd != -1) {
+			close(c->lxc_conf->logfd);
+			c->lxc_conf->logfd = -1;
+		}
+	}
+
 	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
 		if (am_unpriv())
 			ret = userns_exec_1(c->lxc_conf, bdev_destroy_wrapper, c->lxc_conf);
@@ -2058,7 +2188,7 @@ static bool container_destroy(struct lxc_container *c)
 
 	mod_all_rdeps(c, false);
 
-	const char *p1 = lxcapi_get_config_path(c);
+	const char *p1 = do_lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
 	if (am_unpriv())
@@ -2076,7 +2206,7 @@ out:
 	return bret;
 }
 
-static bool lxcapi_destroy(struct lxc_container *c)
+static bool do_lxcapi_destroy(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2093,9 +2223,9 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	return container_destroy(c);
 }
 
-static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
+WRAP_API(bool, lxcapi_destroy)
 
-static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
+static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2106,6 +2236,8 @@ static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
 	return lxcapi_destroy(c);
 }
 
+WRAP_API(bool, lxcapi_destroy_with_snapshots)
+
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
 {
 	struct lxc_config_t *config;
@@ -2122,7 +2254,7 @@ static bool set_config_item_locked(struct lxc_container *c, const char *key, con
 	return do_append_unexp_config_line(c->lxc_conf, key, v);
 }
 
-static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
+static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
 {
 	bool b = false;
 
@@ -2138,6 +2270,8 @@ static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, con
 	return b;
 }
 
+WRAP_API_2(bool, lxcapi_set_config_item, const char *, const char *)
+
 static char *lxcapi_config_file_name(struct lxc_container *c)
 {
 	if (!c || !c->configfile)
@@ -2185,7 +2319,7 @@ static bool set_config_filename(struct lxc_container *c)
 	return true;
 }
 
-static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
+static bool do_lxcapi_set_config_path(struct lxc_container *c, const char *path)
 {
 	char *p;
 	bool b = false;
@@ -2223,8 +2357,9 @@ err:
 	return b;
 }
 
+WRAP_API_1(bool, lxcapi_set_config_path, const char *)
 
-static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
+static bool do_lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
 {
 	int ret;
 
@@ -2243,7 +2378,9 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	return ret == 0;
 }
 
-static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
+WRAP_API_2(bool, lxcapi_set_cgroup_item, const char *, const char *)
+
+static int do_lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
 {
 	int ret;
 
@@ -2262,6 +2399,8 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	return ret;
 }
 
+WRAP_API_3(int, lxcapi_get_cgroup_item, const char *, char *, int)
+
 const char *lxc_get_global_config_item(const char *key)
 {
 	return lxc_global_config_value(key);
@@ -2378,7 +2517,7 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 		ERROR("Error saving new hooks in clone");
 		return -1;
 	}
-	c->save_config(c, NULL);
+	do_lxcapi_save_config(c, NULL);
 	return 0;
 }
 
@@ -2650,7 +2789,7 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	return ret;
 }
 
-static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, uint64_t newsize,
 		char **hookargs)
@@ -2663,7 +2802,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	FILE *fout;
 	pid_t pid;
 
-	if (!c || !c->is_defined(c))
+	if (!c || !do_lxcapi_is_defined(c))
 		return NULL;
 
 	if (container_mem_lock(c))
@@ -2678,7 +2817,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (!newname)
 		newname = c->name;
 	if (!lxcpath)
-		lxcpath = c->get_config_path(c);
+		lxcpath = do_lxcapi_get_config_path(c);
 	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", lxcpath, newname);
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		SYSERROR("clone: failed making config pathname");
@@ -2807,7 +2946,19 @@ out:
 	return NULL;
 }
 
-static bool lxcapi_rename(struct lxc_container *c, const char *newname)
+static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+		const char *lxcpath, int flags,
+		const char *bdevtype, const char *bdevdata, uint64_t newsize,
+		char **hookargs)
+{
+	struct lxc_container * ret;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);
+	current_config = NULL;
+	return ret;
+}
+
+static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)
 {
 	struct bdev *bdev;
 	struct lxc_container *newc;
@@ -2842,15 +2993,23 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	return true;
 }
 
+WRAP_API_1(bool, lxcapi_rename, const char *)
+
 static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process)
 {
+	int ret;
+
 	if (!c)
 		return -1;
 
-	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
+	current_config = c->lxc_conf;
+
+	ret = lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
+	current_config = NULL;
+	return ret;
 }
 
-static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+static int do_lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
 {
 	lxc_attach_command_t command;
 	pid_t pid;
@@ -2869,6 +3028,15 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	return lxc_wait_for_pid_status(pid);
 }
 
+static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+{
+	int ret;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_attach_run_wait(c, options, program, argv);
+	current_config = NULL;
+	return ret;
+}
+
 static int get_next_index(const char *lxcpath, char *cname)
 {
 	char *fname;
@@ -2912,7 +3080,7 @@ static bool get_snappath_dir(struct lxc_container *c, char *snappath)
 	return true;
 }
 
-static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
+static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
@@ -2954,7 +3122,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 		ERROR("and keep the original container pristine.");
 		flags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
 	}
-	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
+	c2 = do_lxcapi_clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
 		ERROR("clone of %s:%s failed", c->config_path, c->name);
 		return -1;
@@ -3002,6 +3170,8 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	return i;
 }
 
+WRAP_API_1(int, lxcapi_snapshot, const char *)
+
 static void lxcsnap_free(struct lxc_snapshot *s)
 {
 	free(s->name);
@@ -3056,7 +3226,7 @@ static char *get_timestamp(char* snappath, char *name)
 	return s;
 }
 
-static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
+static int do_lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
 	int count = 0, ret;
@@ -3132,7 +3302,9 @@ out_free:
 	return -1;
 }
 
-static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
+WRAP_API_1(int, lxcapi_snapshot_list, struct lxc_snapshot **)
+
+static bool do_lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
 	int flags = 0;
@@ -3193,6 +3365,8 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	return b;
 }
 
+WRAP_API_2(bool, lxcapi_snapshot_restore, const char *, const char *)
+
 static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 {
 	struct lxc_container *snap = NULL;
@@ -3204,7 +3378,7 @@ static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 		goto err;
 	}
 
-	if (!lxcapi_destroy(snap)) {
+	if (!do_lxcapi_destroy(snap)) {
 		ERROR("Could not destroy snapshot %s", snapname);
 		goto err;
 	}
@@ -3248,7 +3422,7 @@ static bool remove_all_snapshots(const char *path)
 	return bret;
 }
 
-static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
+static bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3261,7 +3435,9 @@ static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapnam
 	return do_snapshot_destroy(snapname, clonelxcpath);
 }
 
-static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
+WRAP_API_1(bool, lxcapi_snapshot_destroy, const char *)
+
+static bool do_lxcapi_snapshot_destroy_all(struct lxc_container *c)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3274,11 +3450,15 @@ static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
 	return remove_all_snapshots(clonelxcpath);
 }
 
-static bool lxcapi_may_control(struct lxc_container *c)
+WRAP_API(bool, lxcapi_snapshot_destroy_all)
+
+static bool do_lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
+WRAP_API(bool, lxcapi_may_control)
+
 static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,
 		struct stat *st)
 {
@@ -3342,7 +3522,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	const char *p;
 
 	/* make sure container is running */
-	if (!c->is_running(c)) {
+	if (!do_lxcapi_is_running(c)) {
 		ERROR("container is not running");
 		return false;
 	}
@@ -3366,17 +3546,17 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	if (ret < 0 || ret >= MAX_BUFFER)
 		return false;
 
-	if (!do_add_remove_node(c->init_pid(c), p, add, &st))
+	if (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))
 		return false;
 
 	/* add or remove device to/from cgroup access list */
 	if (add) {
-		if (!c->set_cgroup_item(c, "devices.allow", value)) {
+		if (!do_lxcapi_set_cgroup_item(c, "devices.allow", value)) {
 			ERROR("set_cgroup_item failed while adding the device node");
 			return false;
 		}
 	} else {
-		if (!c->set_cgroup_item(c, "devices.deny", value)) {
+		if (!do_lxcapi_set_cgroup_item(c, "devices.deny", value)) {
 			ERROR("set_cgroup_item failed while removing the device node");
 			return false;
 		}
@@ -3385,7 +3565,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	return true;
 }
 
-static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+static bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3394,7 +3574,9 @@ static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path
 	return add_remove_device_node(c, src_path, dest_path, true);
 }
 
-static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+WRAP_API_2(bool, lxcapi_add_device_node, const char *, const char *)
+
+static bool do_lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3403,7 +3585,9 @@ static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_p
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
-static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
+WRAP_API_2(bool, lxcapi_remove_device_node, const char *, const char *)
+
+static bool do_lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 				const char *dst_ifname)
 {
 	int ret = 0;
@@ -3426,7 +3610,7 @@ static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 			goto err;
 	}
 
-	ret = lxc_netdev_move_by_name(ifname, c->init_pid(c), dst_ifname);
+	ret = lxc_netdev_move_by_name(ifname, do_lxcapi_init_pid(c), dst_ifname);
 	if (ret)
 		goto err;
 
@@ -3436,7 +3620,9 @@ err:
 	return false;
 }
 
-static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
+WRAP_API_2(bool, lxcapi_attach_interface, const char *, const char *)
+
+static bool do_lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 					const char *dst_ifname)
 {
 	pid_t pid, pid_outside;
@@ -3491,7 +3677,9 @@ static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 	return true;
 }
 
-static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+WRAP_API_2(bool, lxcapi_detach_interface, const char *, const char *)
+
+static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
 {
 	pid_t pid;
 	int status;
@@ -3536,7 +3724,9 @@ static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool sto
 	}
 }
 
-static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+WRAP_API_3(bool, lxcapi_checkpoint, char *, bool, bool)
+
+static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
 	pid_t pid;
 	int status, nread;
@@ -3590,6 +3780,8 @@ err_wait:
 	return false;
 }
 
+WRAP_API_2(bool, lxcapi_restore, char *, bool)
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -3599,18 +3791,23 @@ static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
+	current_config = c->lxc_conf;
+
 	va_start(ap, arg);
 	argv = lxc_va_arg_list_to_argv_const(ap, 1);
 	va_end(ap);
 
 	if (!argv) {
 		ERROR("Memory allocation error.");
-		return -1;
+		ret = -1;
+		goto out;
 	}
 	argv[0] = arg;
 
-	ret = lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
+	ret = do_lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
 	free((void*)argv);
+out:
+	current_config = NULL;
 	return ret;
 }
 
@@ -3727,12 +3924,6 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 
-	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {
-		fprintf(stderr, "failed to open log\n");
-		goto err;
-	}
-
 	return c;
 
 err:
@@ -3806,7 +3997,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 					goto free_bad;
 			continue;
 		}
-		if (!lxcapi_is_defined(c)) {
+		if (!do_lxcapi_is_defined(c)) {
 			INFO("Container %s:%s has a config but is not defined",
 				lxcpath, direntp->d_name);
 			if (names)

commit 507cee3618237d3776441c882be57429795fee08
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Apr 20 17:34:31 2015 -0600

    c/r: re-open fds after clone()
    
    If we don't re-open these after clone, the init process has a pointer to the
    parent's /dev/{zero,null}. CRIU seese these and wants to dump the parent's
    mount namespace, which is unnecessary. Instead, we should just re-open
    stdin/out/err after we do the clone and pivot root, to ensure that we have
    pointers to the devcies in init's rootfs instead of the host's.
    
    v2: Only close fds if the container was daemonized. This didn't turn out as
        nicely as described on the list because lxc_start() doesn't actually have
        the struct lxc_container, so it cant see the flag. Instead, we just pass it
        down everywhere.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0ca5b9f..d49426f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -584,7 +584,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	container_mem_unlock(c);
 
 	if (useinit) {
-		ret = lxc_execute(c->name, argv, 1, conf, c->config_path);
+		ret = lxc_execute(c->name, argv, 1, conf, c->config_path, daemonize);
 		return ret == 0 ? true : false;
 	}
 
@@ -642,12 +642,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			return false;
 		}
 		lxc_check_inherited(conf, true, -1);
-		close(0);
-		close(1);
-		close(2);
-		open("/dev/zero", O_RDONLY);
-		open("/dev/null", O_RDWR);
-		open("/dev/null", O_RDWR);
 		setsid();
 	} else {
 		if (!am_single_threaded()) {
@@ -687,7 +681,7 @@ reboot:
 		goto out;
 	}
 
-	ret = lxc_start(c->name, argv, conf, c->config_path);
+	ret = lxc_start(c->name, argv, conf, c->config_path, daemonize);
 	c->error_num = ret;
 
 	if (conf->reboot) {

commit e29fe1dd21a58d1deddb3ca3bf3eaf260c525b10
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Apr 16 12:40:56 2015 -0600

    c/r: move criu code to its own file
    
    Trying to cage the beast that is lxccontainer.c.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d6826ab..0ca5b9f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -50,6 +50,7 @@
 #include "console.h"
 #include "cgroup.h"
 #include "commands.h"
+#include "criu.h"
 #include "log.h"
 #include "bdev.h"
 #include "utils.h"
@@ -3496,276 +3497,6 @@ static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 	return true;
 }
 
-struct criu_opts {
-	/* The type of criu invocation, one of "dump" or "restore" */
-	char *action;
-
-	/* The directory to pass to criu */
-	char *directory;
-
-	/* The container to dump */
-	struct lxc_container *c;
-
-	/* Enable criu verbose mode? */
-	bool verbose;
-
-	/* dump: stop the container or not after dumping? */
-	bool stop;
-
-	/* restore: the file to write the init process' pid into */
-	char *pidfile;
-	const char *cgroup_path;
-};
-
-static void exec_criu(struct criu_opts *opts)
-{
-	char **argv, log[PATH_MAX];
-	int static_args = 18, argc = 0, i, ret;
-	int netnr = 0;
-	struct lxc_list *it;
-
-	char buf[4096];
-	FILE *mnts = NULL;
-
-	/* The command line always looks like:
-	 * criu $(action) --tcp-established --file-locks --link-remap --force-irmap \
-	 * --manage-cgroups action-script foo.sh -D $(directory) \
-	 * -o $(directory)/$(action).log --ext-mount-map auto
-	 * --enable-external-sharing --enable-external-masters
-	 * +1 for final NULL */
-
-	if (strcmp(opts->action, "dump") == 0) {
-		/* -t pid */
-		static_args += 2;
-
-		/* --leave-running */
-		if (!opts->stop)
-			static_args++;
-	} else if (strcmp(opts->action, "restore") == 0) {
-		/* --root $(lxc_mount_point) --restore-detached
-		 * --restore-sibling --pidfile $foo --cgroup-root $foo */
-		static_args += 8;
-	} else {
-		return;
-	}
-
-	if (opts->verbose)
-		static_args++;
-
-	ret = snprintf(log, PATH_MAX, "%s/%s.log", opts->directory, opts->action);
-	if (ret < 0 || ret >= PATH_MAX) {
-		ERROR("logfile name too long\n");
-		return;
-	}
-
-	argv = malloc(static_args * sizeof(*argv));
-	if (!argv)
-		return;
-
-	memset(argv, 0, static_args * sizeof(*argv));
-
-#define DECLARE_ARG(arg) 					\
-	do {							\
-		if (arg == NULL) {				\
-			ERROR("Got NULL argument for criu");	\
-			goto err;				\
-		}						\
-		argv[argc++] = strdup(arg);			\
-		if (!argv[argc-1])				\
-			goto err;				\
-	} while (0)
-
-	argv[argc++] = on_path("criu", NULL);
-	if (!argv[argc-1]) {
-		ERROR("Couldn't find criu binary\n");
-		goto err;
-	}
-
-	DECLARE_ARG(opts->action);
-	DECLARE_ARG("--tcp-established");
-	DECLARE_ARG("--file-locks");
-	DECLARE_ARG("--link-remap");
-	DECLARE_ARG("--force-irmap");
-	DECLARE_ARG("--manage-cgroups");
-	DECLARE_ARG("--ext-mount-map");
-	DECLARE_ARG("auto");
-	DECLARE_ARG("--enable-external-sharing");
-	DECLARE_ARG("--enable-external-masters");
-	DECLARE_ARG("-D");
-	DECLARE_ARG(opts->directory);
-	DECLARE_ARG("-o");
-	DECLARE_ARG(log);
-
-	if (opts->verbose)
-		DECLARE_ARG("-vvvvvv");
-
-	if (strcmp(opts->action, "dump") == 0) {
-		char pid[32];
-
-		if (sprintf(pid, "%d", lxcapi_init_pid(opts->c)) < 0)
-			goto err;
-
-		DECLARE_ARG("-t");
-		DECLARE_ARG(pid);
-		if (!opts->stop)
-			DECLARE_ARG("--leave-running");
-	} else if (strcmp(opts->action, "restore") == 0) {
-		void *m;
-		int additional;
-
-		DECLARE_ARG("--root");
-		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
-		DECLARE_ARG("--restore-detached");
-		DECLARE_ARG("--restore-sibling");
-		DECLARE_ARG("--pidfile");
-		DECLARE_ARG(opts->pidfile);
-		DECLARE_ARG("--cgroup-root");
-		DECLARE_ARG(opts->cgroup_path);
-
-		additional = lxc_list_len(&opts->c->lxc_conf->network) * 2;
-
-		m = realloc(argv, (argc + additional + 1) * sizeof(*argv));	\
-		if (!m)								\
-			goto err;						\
-		argv = m;
-
-		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
-			char eth[128], *veth;
-			struct lxc_netdev *n = it->elem;
-
-			if (n->name) {
-				if (strlen(n->name) >= sizeof(eth))
-					goto err;
-				strncpy(eth, n->name, sizeof(eth));
-			} else
-				sprintf(eth, "eth%d", netnr);
-
-			veth = n->priv.veth_attr.pair;
-
-			ret = snprintf(buf, sizeof(buf), "%s=%s@%s", eth, veth, n->link);
-			if (ret < 0 || ret >= sizeof(buf))
-				goto err;
-
-			DECLARE_ARG("--veth-pair");
-			DECLARE_ARG(buf);
-		}
-
-	}
-
-	argv[argc] = NULL;
-
-#undef DECLARE_ARG
-	execv(argv[0], argv);
-err:
-	if (mnts)
-		fclose(mnts);
-	for (i = 0; argv[i]; i++)
-		free(argv[i]);
-	free(argv);
-}
-
-/* Check and make sure the container has a configuration that we know CRIU can
- * dump. */
-static bool criu_ok(struct lxc_container *c)
-{
-	struct lxc_list *it;
-	bool found_deny_rule = false;
-
-	if (geteuid()) {
-		ERROR("Must be root to checkpoint\n");
-		return false;
-	}
-
-	/* We only know how to restore containers with veth networks. */
-	lxc_list_for_each(it, &c->lxc_conf->network) {
-		struct lxc_netdev *n = it->elem;
-		if (n->type != LXC_NET_VETH && n->type != LXC_NET_NONE) {
-			ERROR("Found network that is not VETH or NONE\n");
-			return false;
-		}
-	}
-
-	// These requirements come from http://criu.org/LXC
-	if (c->lxc_conf->console.path &&
-			strcmp(c->lxc_conf->console.path, "none") != 0) {
-		ERROR("lxc.console must be none\n");
-		return false;
-	}
-
-	if (c->lxc_conf->tty != 0) {
-		ERROR("lxc.tty must be 0\n");
-		return false;
-	}
-
-	lxc_list_for_each(it, &c->lxc_conf->cgroup) {
-		struct lxc_cgroup *cg = it->elem;
-		if (strcmp(cg->subsystem, "devices.deny") == 0 &&
-				strcmp(cg->value, "c 5:1 rwm") == 0) {
-
-			found_deny_rule = true;
-			break;
-		}
-	}
-
-	if (!found_deny_rule) {
-		ERROR("couldn't find devices.deny = c 5:1 rwm");
-		return false;
-	}
-
-	return true;
-}
-
-static bool dump_net_info(struct lxc_container *c, char *directory)
-{
-	int netnr;
-	struct lxc_list *it;
-
-	netnr = 0;
-	lxc_list_for_each(it, &c->lxc_conf->network) {
-		char *veth = NULL, *bridge = NULL, veth_path[PATH_MAX], eth[128];
-		struct lxc_netdev *n = it->elem;
-		bool has_error = true;
-		int pret;
-
-		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.veth.pair", netnr);
-		if (pret < 0 || pret >= PATH_MAX)
-			goto out;
-
-		veth = lxcapi_get_running_config_item(c, veth_path);
-		if (!veth) {
-			/* criu_ok() checks that all interfaces are
-			 * LXC_NET{VETH,NONE}, and VETHs should have this
-			 * config */
-			assert(n->type == LXC_NET_NONE);
-			break;
-		}
-
-		bridge = lxcapi_get_running_config_item(c, veth_path);
-		if (!bridge)
-			goto out;
-
-		pret = snprintf(veth_path, PATH_MAX, "%s/veth%d", directory, netnr);
-		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, veth) < 0)
-			goto out;
-
-		if (n->name) {
-			if (strlen(n->name) >= 128)
-				goto out;
-			strncpy(eth, n->name, 128);
-		} else
-			sprintf(eth, "eth%d", netnr);
-
-		has_error = false;
-out:
-		free(veth);
-		free(bridge);
-		if (has_error)
-			return false;
-	}
-
-	return true;
-}
-
 static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
 {
 	pid_t pid;
@@ -3811,189 +3542,6 @@ static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool sto
 	}
 }
 
-static bool restore_net_info(struct lxc_container *c)
-{
-	struct lxc_list *it;
-	bool has_error = true;
-
-	if (container_mem_lock(c))
-		return false;
-
-	lxc_list_for_each(it, &c->lxc_conf->network) {
-		struct lxc_netdev *netdev = it->elem;
-		char template[IFNAMSIZ];
-		snprintf(template, sizeof(template), "vethXXXXXX");
-
-		if (!netdev->priv.veth_attr.pair)
-			netdev->priv.veth_attr.pair = lxc_mkifname(template);
-
-		if (!netdev->priv.veth_attr.pair)
-			goto out_unlock;
-	}
-
-	has_error = false;
-
-out_unlock:
-	container_mem_unlock(c);
-	return !has_error;
-}
-
-// do_restore never returns, the calling process is used as the
-// monitor process. do_restore calls exit() if it fails.
-static void do_restore(struct lxc_container *c, int pipe, char *directory, bool verbose)
-{
-	pid_t pid;
-	char pidfile[L_tmpnam];
-	struct lxc_handler *handler;
-	int status;
-
-	if (!tmpnam(pidfile))
-		goto out;
-
-	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
-	if (!handler)
-		goto out;
-
-	if (!cgroup_init(handler)) {
-		ERROR("failed initing cgroups");
-		goto out_fini_handler;
-	}
-
-	if (!cgroup_create(handler)) {
-		ERROR("failed creating groups");
-		goto out_fini_handler;
-	}
-
-	if (!restore_net_info(c)) {
-		ERROR("failed restoring network info");
-		goto out_fini_handler;
-	}
-
-	resolve_clone_flags(handler);
-
-	pid = fork();
-	if (pid < 0)
-		goto out_fini_handler;
-
-	if (pid == 0) {
-		struct criu_opts os;
-		struct lxc_rootfs *rootfs;
-
-		close(pipe);
-		pipe = -1;
-
-		if (unshare(CLONE_NEWNS))
-			goto out_fini_handler;
-
-		/* CRIU needs the lxc root bind mounted so that it is the root of some
-		 * mount. */
-		rootfs = &c->lxc_conf->rootfs;
-
-		if (rootfs_is_blockdev(c->lxc_conf)) {
-			if (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)
-				goto out_fini_handler;
-		} else {
-			if (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)
-				goto out_fini_handler;
-
-			if (mount(NULL, "/", NULL, MS_SLAVE | MS_REC, NULL) < 0) {
-				SYSERROR("remount / to private failed");
-				goto out_fini_handler;
-			}
-
-			if (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {
-				rmdir(rootfs->mount);
-				goto out_fini_handler;
-			}
-		}
-
-		os.action = "restore";
-		os.directory = directory;
-		os.c = c;
-		os.pidfile = pidfile;
-		os.verbose = verbose;
-		os.cgroup_path = cgroup_canonical_path(handler);
-
-		/* exec_criu() returning is an error */
-		exec_criu(&os);
-		umount(rootfs->mount);
-		rmdir(rootfs->mount);
-		goto out_fini_handler;
-	} else {
-		int ret;
-		char title[2048];
-
-		pid_t w = waitpid(pid, &status, 0);
-		if (w == -1) {
-			SYSERROR("waitpid");
-			goto out_fini_handler;
-		}
-
-		ret = write(pipe, &status, sizeof(status));
-		close(pipe);
-		pipe = -1;
-
-		if (sizeof(status) != ret) {
-			SYSERROR("failed to write all of status");
-			goto out_fini_handler;
-		}
-
-		if (WIFEXITED(status)) {
-			if (WEXITSTATUS(status)) {
-				goto out_fini_handler;
-			} else {
-				int ret;
-				FILE *f = fopen(pidfile, "r");
-				if (!f) {
-					SYSERROR("couldn't read restore's init pidfile %s\n", pidfile);
-					goto out_fini_handler;
-				}
-
-				ret = fscanf(f, "%d", (int*) &handler->pid);
-				fclose(f);
-				if (ret != 1) {
-					ERROR("reading restore pid failed");
-					goto out_fini_handler;
-				}
-
-				if (lxc_set_state(c->name, handler, RUNNING))
-					goto out_fini_handler;
-			}
-		} else {
-			ERROR("CRIU was killed with signal %d\n", WTERMSIG(status));
-			goto out_fini_handler;
-		}
-
-		/*
-		 * See comment in lxcapi_start; we don't care if these
-		 * fail because it's just a beauty thing. We just
-		 * assign the return here to silence potential.
-		 */
-		ret = snprintf(title, sizeof(title), "[lxc monitor] %s %s", c->config_path, c->name);
-		ret = setproctitle(title);
-
-		ret = lxc_poll(c->name, handler);
-		if (ret)
-			lxc_abort(c->name, handler);
-		lxc_fini(c->name, handler);
-		exit(ret);
-	}
-
-out_fini_handler:
-	lxc_fini(c->name, handler);
-
-out:
-	if (pipe >= 0) {
-		status = 1;
-		if (write(pipe, &status, sizeof(status)) != sizeof(status)) {
-			SYSERROR("writing status failed");
-		}
-		close(pipe);
-	}
-
-	exit(1);
-}
-
 static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
 	pid_t pid;

commit cba98d127bf490b018a016b792ae05fd2d29c5ee
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Apr 13 18:54:27 2015 +0000

    c/r: use criu option instead of lxc-restore-net
    
    As of criu 1.5, the --veth-pair argument supports an additional parameter that
    is the bridge name to attach to. This enables us to get rid of the goofy
    action-script hack that passed bridge names as environment variables.
    
    This patch is on top of the systemd/lxcfs mount rework patch, as we probably
    want to wait to use 1.5 options until it has been out for a while and is in
    distros.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4d73b4c..d6826ab 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3591,8 +3591,6 @@ static void exec_criu(struct criu_opts *opts)
 	DECLARE_ARG("auto");
 	DECLARE_ARG("--enable-external-sharing");
 	DECLARE_ARG("--enable-external-masters");
-	DECLARE_ARG("--action-script");
-	DECLARE_ARG(DATADIR "/lxc/lxc-restore-net");
 	DECLARE_ARG("-D");
 	DECLARE_ARG(opts->directory);
 	DECLARE_ARG("-o");
@@ -3644,7 +3642,7 @@ static void exec_criu(struct criu_opts *opts)
 
 			veth = n->priv.veth_attr.pair;
 
-			ret = snprintf(buf, sizeof(buf), "%s=%s", eth, veth);
+			ret = snprintf(buf, sizeof(buf), "%s=%s@%s", eth, veth, n->link);
 			if (ret < 0 || ret >= sizeof(buf))
 				goto err;
 
@@ -3656,39 +3654,6 @@ static void exec_criu(struct criu_opts *opts)
 
 	argv[argc] = NULL;
 
-	netnr = 0;
-	lxc_list_for_each(it, &opts->c->lxc_conf->network) {
-		struct lxc_netdev *n = it->elem;
-		char veth[128];
-
-		/*
-		 * Here, we set some parameters that lxc-restore-net
-		 * will examine to figure out the right network to
-		 * restore.
-		 */
-		snprintf(buf, sizeof(buf), "LXC_CRIU_BRIDGE%d", netnr);
-		if (setenv(buf, n->link, 1))
-			goto err;
-
-		if (strcmp("restore", opts->action) == 0)
-			strncpy(veth, n->priv.veth_attr.pair, sizeof(veth));
-		else {
-			char *tmp;
-			ret = snprintf(buf, sizeof(buf), "lxc.network.%d.veth.pair", netnr);
-			if (ret < 0 || ret >= sizeof(buf))
-				goto err;
-			tmp = lxcapi_get_running_config_item(opts->c, buf);
-			strncpy(veth, tmp, sizeof(veth));
-			free(tmp);
-		}
-
-		snprintf(buf, sizeof(buf), "LXC_CRIU_VETH%d", netnr);
-		if (setenv(buf, veth, 1))
-			goto err;
-
-		netnr++;
-	}
-
 #undef DECLARE_ARG
 	execv(argv[0], argv);
 err:

commit 40962b642d24f476e5ff59d97ba64cf5730ceb28
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Apr 15 13:43:28 2015 -0600

    c/r: rework external mountpoint handling v4
    
    CRIU now supports autodetection of external mounts via the --ext-mount-map auto
    --enable-external-sharing --enable-external-masters options, so we don't need
    to explicitly pass the cgmanager mount or any of the mounts from the config.
    This also means that lxcfs mounts (since they are bind mounts from outside the
    container) are autodetected, meaning that c/r of containers using lxcfs works.
    
    A further advantage of this patch is that it addresses some of the ugliness
    that was in the exec_criu() function. There are other criu options that will
    allow us to trim this even further, though.
    
    Finally, with --enable-external-masters, criu understands slave mounts in the
    container with shared mounts in the peer group that are outside the namespace.
    This allows containers on a systemd host to be dumped and restored correctly.
    
    However, these options have just landed in criu trunk today, and the next
    tagged release will be 1.6 on June 1, so we should avoid merging this into any
    stable releases until then.
    
    v2: remount / as private before bind mounting the container's directory for
        criu. The problem here is that if / is mounted as shared, even if we
        unshare() the /var/lib/lxc/rootfs mountpoint propagates outside of our
        mount namespace, which is bad, since we don't want to leak mounts. In
        particular, this leak confuses criu the second time it goes to checkpoint
        the container.
    
    v3: whoops, we really want / as MS_SLAVE | MS_REC here, to match what start
        does
    
    v4: rebase onto master for revert of logging patch
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e2586de..4d73b4c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3520,18 +3520,18 @@ struct criu_opts {
 static void exec_criu(struct criu_opts *opts)
 {
 	char **argv, log[PATH_MAX];
-	int static_args = 14, argc = 0, i, ret;
+	int static_args = 18, argc = 0, i, ret;
 	int netnr = 0;
 	struct lxc_list *it;
 
-	struct mntent mntent;
 	char buf[4096];
 	FILE *mnts = NULL;
 
 	/* The command line always looks like:
 	 * criu $(action) --tcp-established --file-locks --link-remap --force-irmap \
 	 * --manage-cgroups action-script foo.sh -D $(directory) \
-	 * -o $(directory)/$(action).log
+	 * -o $(directory)/$(action).log --ext-mount-map auto
+	 * --enable-external-sharing --enable-external-masters
 	 * +1 for final NULL */
 
 	if (strcmp(opts->action, "dump") == 0) {
@@ -3558,11 +3558,6 @@ static void exec_criu(struct criu_opts *opts)
 		return;
 	}
 
-	// We need to tell criu where cgmanager's socket is bind mounted from
-	// if it exists since it's external.
-	if (cgroup_driver() == CGMANAGER)
-		static_args+=2;
-
 	argv = malloc(static_args * sizeof(*argv));
 	if (!argv)
 		return;
@@ -3592,6 +3587,10 @@ static void exec_criu(struct criu_opts *opts)
 	DECLARE_ARG("--link-remap");
 	DECLARE_ARG("--force-irmap");
 	DECLARE_ARG("--manage-cgroups");
+	DECLARE_ARG("--ext-mount-map");
+	DECLARE_ARG("auto");
+	DECLARE_ARG("--enable-external-sharing");
+	DECLARE_ARG("--enable-external-masters");
 	DECLARE_ARG("--action-script");
 	DECLARE_ARG(DATADIR "/lxc/lxc-restore-net");
 	DECLARE_ARG("-D");
@@ -3602,35 +3601,9 @@ static void exec_criu(struct criu_opts *opts)
 	if (opts->verbose)
 		DECLARE_ARG("-vvvvvv");
 
-	/*
-	 * Note: this macro is not intended to be called unless argc is equal
-	 * to the length of the array; there is nothing that keeps track of the
-	 * length of the array besides the location in the code that this is
-	 * called. (Yes this is bad, and we should fix it.)
-	 */
-#define RESIZE_ARGS(additional) 						\
-	do {									\
-		void *m;							\
-		if (additional < 0) {						\
-			ERROR("resizing by negative amount");			\
-			goto err;						\
-		} else if (additional == 0)					\
-			continue;						\
-										\
-		m = realloc(argv, (argc + additional + 1) * sizeof(*argv));	\
-		if (!m)								\
-			goto err;						\
-		argv = m;							\
-	} while (0)
-
 	if (strcmp(opts->action, "dump") == 0) {
 		char pid[32];
 
-		if (cgroup_driver() == CGMANAGER) {
-			DECLARE_ARG("--ext-mount-map");
-			DECLARE_ARG("/sys/fs/cgroup/cgmanager:cgmanager");
-		}
-
 		if (sprintf(pid, "%d", lxcapi_init_pid(opts->c)) < 0)
 			goto err;
 
@@ -3639,11 +3612,8 @@ static void exec_criu(struct criu_opts *opts)
 		if (!opts->stop)
 			DECLARE_ARG("--leave-running");
 	} else if (strcmp(opts->action, "restore") == 0) {
-
-		if (cgroup_driver() == CGMANAGER) {
-			DECLARE_ARG("--ext-mount-map");
-			DECLARE_ARG("cgmanager:/sys/fs/cgroup/cgmanager");
-		}
+		void *m;
+		int additional;
 
 		DECLARE_ARG("--root");
 		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
@@ -3654,7 +3624,12 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG("--cgroup-root");
 		DECLARE_ARG(opts->cgroup_path);
 
-		RESIZE_ARGS(lxc_list_len(&opts->c->lxc_conf->network) * 2);
+		additional = lxc_list_len(&opts->c->lxc_conf->network) * 2;
+
+		m = realloc(argv, (argc + additional + 1) * sizeof(*argv));	\
+		if (!m)								\
+			goto err;						\
+		argv = m;
 
 		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
 			char eth[128], *veth;
@@ -3676,38 +3651,8 @@ static void exec_criu(struct criu_opts *opts)
 			DECLARE_ARG("--veth-pair");
 			DECLARE_ARG(buf);
 		}
-	}
-
-	// CRIU wants to know about any external bind mounts the
-	// container has.
-	mnts = write_mount_file(&opts->c->lxc_conf->mount_list);
-	if (!mnts)
-		goto err;
-
-	RESIZE_ARGS(lxc_list_len(&opts->c->lxc_conf->mount_list) * 2);
-
-	while (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {
-		char arg[2048], *key, *val;
-		int ret;
-
-		if (strcmp(opts->action, "dump") == 0) {
-			key = mntent.mnt_fsname;
-			val = mntent.mnt_dir;
-		} else {
-			key = mntent.mnt_dir;
-			val = mntent.mnt_fsname;
-		}
-
-		ret = snprintf(arg, sizeof(arg), "%s:%s", key, val);
-		if (ret < 0 || ret >= sizeof(arg)) {
-			goto err;
-		}
 
-		DECLARE_ARG("--ext-mount-map");
-		DECLARE_ARG(arg);
 	}
-	fclose(mnts);
-	mnts = NULL;
 
 	argv[argc] = NULL;
 
@@ -3745,7 +3690,6 @@ static void exec_criu(struct criu_opts *opts)
 	}
 
 #undef DECLARE_ARG
-#undef RESIZE_ARGS
 	execv(argv[0], argv);
 err:
 	if (mnts)
@@ -3987,6 +3931,11 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 			if (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)
 				goto out_fini_handler;
 
+			if (mount(NULL, "/", NULL, MS_SLAVE | MS_REC, NULL) < 0) {
+				SYSERROR("remount / to private failed");
+				goto out_fini_handler;
+			}
+
 			if (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {
 				rmdir(rootfs->mount);
 				goto out_fini_handler;

commit a16f71a1d10ba626eb87297b0391b03b54de76e9
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 14 15:47:02 2015 -0500

    Revert (by hand) "logs: introduce a thread-local 'current' lxc_config"
    
    This is hopefully temporary - it works great for lxc itself, but seems
    to be upsetting golang.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Tested-by: Tycho Andersen <tycho.andersen@canonical.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5b96b8c..e2586de 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -91,15 +91,6 @@ return -1;
 
 lxc_log_define(lxc_container, lxc);
 
-static bool do_lxcapi_destroy(struct lxc_container *c);
-static const char *lxcapi_get_config_path(struct lxc_container *c);
-#define do_lxcapi_get_config_path(c) lxcapi_get_config_path(c)
-static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
-static bool container_destroy(struct lxc_container *c);
-static bool get_snappath_dir(struct lxc_container *c, char *snappath);
-static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
-static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);
-
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
 	/* $lxcpath + '/' + $cname + '/config' + \0 */
@@ -316,7 +307,7 @@ int lxc_container_put(struct lxc_container *c)
 	return 0;
 }
 
-static bool do_lxcapi_is_defined(struct lxc_container *c)
+static bool lxcapi_is_defined(struct lxc_container *c)
 {
 	struct stat statbuf;
 	bool ret = false;
@@ -339,53 +330,7 @@ out:
 	return ret;
 }
 
-#define WRAP_API(rettype, fnname)					\
-static rettype fnname(struct lxc_container *c)				\
-{									\
-	rettype ret;							\
-	struct lxc_conf *old = current_config;				\
-	current_config = c ? c->lxc_conf : NULL;			\
-	ret = do_##fnname(c);						\
-	current_config = old;						\
-	return ret;							\
-}
-
-#define WRAP_API_1(rettype, fnname, t1)					\
-static rettype fnname(struct lxc_container *c, t1 a1)			\
-{									\
-	rettype ret;							\
-	struct lxc_conf *old = current_config;				\
-	current_config = c ? c->lxc_conf : NULL;			\
-	ret = do_##fnname(c, a1);					\
-	current_config = old;						\
-	return ret;							\
-}
-
-#define WRAP_API_2(rettype, fnname, t1, t2)				\
-static rettype fnname(struct lxc_container *c, t1 a1, t2 a2)		\
-{									\
-	rettype ret;							\
-	struct lxc_conf *old = current_config;				\
-	current_config = c ? c->lxc_conf : NULL;			\
-	ret = do_##fnname(c, a1, a2);					\
-	current_config = old;						\
-	return ret;							\
-}
-
-#define WRAP_API_3(rettype, fnname, t1, t2, t3)				\
-static rettype fnname(struct lxc_container *c, t1 a1, t2 a2, t3 a3)	\
-{									\
-	rettype ret;							\
-	struct lxc_conf *old = current_config;				\
-	current_config = c ? c->lxc_conf : NULL;			\
-	ret = do_##fnname(c, a1, a2, a3);				\
-	current_config = old;						\
-	return ret;							\
-}
-
-WRAP_API(bool, lxcapi_is_defined)
-
-static const char *do_lxcapi_state(struct lxc_container *c)
+static const char *lxcapi_state(struct lxc_container *c)
 {
 	lxc_state_t s;
 
@@ -395,8 +340,6 @@ static const char *do_lxcapi_state(struct lxc_container *c)
 	return lxc_state2str(s);
 }
 
-WRAP_API(const char *, lxcapi_state)
-
 static bool is_stopped(struct lxc_container *c)
 {
 	lxc_state_t s;
@@ -404,21 +347,19 @@ static bool is_stopped(struct lxc_container *c)
 	return (s == STOPPED);
 }
 
-static bool do_lxcapi_is_running(struct lxc_container *c)
+static bool lxcapi_is_running(struct lxc_container *c)
 {
 	const char *s;
 
 	if (!c)
 		return false;
-	s = do_lxcapi_state(c);
+	s = lxcapi_state(c);
 	if (!s || strcmp(s, "STOPPED") == 0)
 		return false;
 	return true;
 }
 
-WRAP_API(bool, lxcapi_is_running)
-
-static bool do_lxcapi_freeze(struct lxc_container *c)
+static bool lxcapi_freeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -430,9 +371,7 @@ static bool do_lxcapi_freeze(struct lxc_container *c)
 	return true;
 }
 
-WRAP_API(bool, lxcapi_freeze)
-
-static bool do_lxcapi_unfreeze(struct lxc_container *c)
+static bool lxcapi_unfreeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -444,9 +383,7 @@ static bool do_lxcapi_unfreeze(struct lxc_container *c)
 	return true;
 }
 
-WRAP_API(bool, lxcapi_unfreeze)
-
-static int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
+static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
 {
 	int ttyfd;
 	if (!c)
@@ -456,24 +393,13 @@ static int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *ma
 	return ttyfd;
 }
 
-WRAP_API_2(int, lxcapi_console_getfd, int *, int *)
-
 static int lxcapi_console(struct lxc_container *c, int ttynum, int stdinfd,
 			  int stdoutfd, int stderrfd, int escape)
 {
-	int ret;
-	struct lxc_conf *old = current_config;
-
-	if (!c)
-		return -1;
-
-	current_config = c->lxc_conf;
-	ret = lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
-	current_config = old;
-	return ret;
+	return lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
 }
 
-static pid_t do_lxcapi_init_pid(struct lxc_container *c)
+static pid_t lxcapi_init_pid(struct lxc_container *c)
 {
 	if (!c)
 		return -1;
@@ -481,8 +407,6 @@ static pid_t do_lxcapi_init_pid(struct lxc_container *c)
 	return lxc_cmd_get_init_pid(c->name, c->config_path);
 }
 
-WRAP_API(pid_t, lxcapi_init_pid)
-
 static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
@@ -494,7 +418,7 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 	return true;
 }
 
-static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)
+static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 {
 	bool ret = false, need_disklock = false;
 	int lret;
@@ -531,9 +455,7 @@ static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
-WRAP_API_1(bool, lxcapi_load_config, const char *)
-
-static bool do_lxcapi_want_daemonize(struct lxc_container *c, bool state)
+static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -546,9 +468,7 @@ static bool do_lxcapi_want_daemonize(struct lxc_container *c, bool state)
 	return true;
 }
 
-WRAP_API_1(bool, lxcapi_want_daemonize, bool)
-
-static bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
+static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -561,9 +481,7 @@ static bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 	return true;
 }
 
-WRAP_API_1(bool, lxcapi_want_close_all_fds, bool)
-
-static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
+static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 {
 	int ret;
 
@@ -574,9 +492,8 @@ static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeo
 	return ret == 0;
 }
 
-WRAP_API_2(bool, lxcapi_wait, const char *, int)
 
-static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)
+static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
 {
 	/* we'll probably want to make this timeout configurable? */
 	int timeout = 5, ret, status;
@@ -588,11 +505,9 @@ static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)
 	ret = waitpid(pid, &status, 0);
 	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
 		DEBUG("failed waiting for first dual-fork child");
-	return do_lxcapi_wait(c, "RUNNING", timeout);
+	return lxcapi_wait(c, "RUNNING", timeout);
 }
 
-WRAP_API_1(bool, wait_on_daemonized_start, int)
-
 static bool am_single_threaded(void)
 {
 	struct dirent dirent, *direntp;
@@ -625,7 +540,7 @@ static bool am_single_threaded(void)
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
  */
-static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
+static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
 	struct lxc_conf *conf;
@@ -650,7 +565,7 @@ static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const a
 	}
 	if (ret == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
-		do_lxcapi_destroy(c);
+		c->destroy(c);
 		return false;
 	} else if (ret == 1) {
 		ERROR("Error: creation of %s is ongoing", c->name);
@@ -793,16 +708,6 @@ out:
 		return (ret == 0 ? true : false);
 }
 
-static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
-{
-	bool ret;
-	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
-	ret = do_lxcapi_start(c, useinit, argv);
-	current_config = old;
-	return ret;
-}
-
 /*
  * note there MUST be an ending NULL
  */
@@ -816,9 +721,6 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	if (!c)
 		return false;
 
-	struct lxc_conf *old = current_config;
-	current_config = c->lxc_conf;
-
 	va_start(ap, useinit);
 	inargs = lxc_va_arg_list_to_argv(ap, 0, 1);
 	va_end(ap);
@@ -829,7 +731,7 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	}
 
 	/* pass NULL if no arguments were supplied */
-	bret = do_lxcapi_start(c, useinit, *inargs ? inargs : NULL);
+	bret = lxcapi_start(c, useinit, *inargs ? inargs : NULL);
 
 out:
 	if (inargs) {
@@ -839,11 +741,10 @@ out:
 		free(inargs);
 	}
 
-	current_config = old;
 	return bret;
 }
 
-static bool do_lxcapi_stop(struct lxc_container *c)
+static bool lxcapi_stop(struct lxc_container *c)
 {
 	int ret;
 
@@ -855,8 +756,6 @@ static bool do_lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
-WRAP_API(bool, lxcapi_stop)
-
 static int do_create_container_dir(const char *path, struct lxc_conf *conf)
 {
 	int ret = -1, lasterr;
@@ -904,6 +803,9 @@ static bool create_container_dir(struct lxc_container *c)
 	return ret == 0;
 }
 
+static const char *lxcapi_get_config_path(struct lxc_container *c);
+static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
+
 /*
  * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
  * it returns a mounted bdev on success, NULL on error.
@@ -923,7 +825,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s", rpath);
 	} else {
-		const char *lxcpath = do_lxcapi_get_config_path(c);
+		const char *lxcpath = lxcapi_get_config_path(c);
 		len = strlen(c->name) + strlen(lxcpath) + 9;
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
@@ -937,7 +839,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		return NULL;
 	}
 
-	do_lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
 
 	/* if we are not root, chown the rootfs dir to root in the
 	 * target uidmap */
@@ -1314,8 +1216,9 @@ static void lxcapi_clear_config(struct lxc_container *c)
 	}
 }
 
-#define do_lxcapi_clear_config(c) lxcapi_clear_config(c)
-
+static bool lxcapi_destroy(struct lxc_container *c);
+static bool container_destroy(struct lxc_container *c);
+static bool get_snappath_dir(struct lxc_container *c, char *snappath);
 /*
  * lxcapi_create:
  * create a container with the given parameters.
@@ -1330,7 +1233,7 @@ static void lxcapi_clear_config(struct lxc_container *c)
  * @argv: the arguments to pass to the template, terminated by NULL.  If no
  * arguments, you can just pass NULL.
  */
-static bool do_lxcapi_create(struct lxc_container *c, const char *t,
+static bool lxcapi_create(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags,
 		char *const argv[])
 {
@@ -1356,14 +1259,14 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 	 * an existing container.  Return an error, but do NOT delete the
 	 * container.
 	 */
-	if (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
 			access(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {
 		ERROR("Container %s:%s already exists", c->config_path, c->name);
 		goto free_tpath;
 	}
 
 	if (!c->lxc_conf) {
-		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s", lxc_global_config_value("lxc.default_config"));
 			goto free_tpath;
 		}
@@ -1383,7 +1286,7 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
 		/* rootfs passed into configuration, but does not exist: error */
 		goto out;
-	if (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
+	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
 		/* Rootfs already existed, user just wanted to save the
 		 * loaded configuration */
 		ret = true;
@@ -1419,7 +1322,7 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 		}
 
 		/* save config file again to store the new rootfs location */
-		if (!do_lxcapi_save_config(c, NULL)) {
+		if (!c->save_config(c, NULL)) {
 			ERROR("failed to save starting configuration for %s", c->name);
 			// parent task won't see bdev in config so we delete it
 			bdev->ops->umount(bdev);
@@ -1442,7 +1345,7 @@ static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 
 	// now clear out the lxc_conf we have, reload from the created
 	// container
-	do_lxcapi_clear_config(c);
+	lxcapi_clear_config(c);
 
 	if (t) {
 		if (!prepend_lxc_header(c->configfile, tpath, argv)) {
@@ -1463,28 +1366,16 @@ free_tpath:
 	return ret;
 }
 
-static bool lxcapi_create(struct lxc_container *c, const char *t,
-		const char *bdevtype, struct bdev_specs *specs, int flags,
-		char *const argv[])
-{
-	bool ret;
-	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
-	ret = do_lxcapi_create(c, t, bdevtype, specs, flags, argv);
-	current_config = old;
-	return ret;
-}
-
-static bool do_lxcapi_reboot(struct lxc_container *c)
+static bool lxcapi_reboot(struct lxc_container *c)
 {
 	pid_t pid;
 	int rebootsignal = SIGINT;
 
 	if (!c)
 		return false;
-	if (!do_lxcapi_is_running(c))
+	if (!c->is_running(c))
 		return false;
-	pid = do_lxcapi_init_pid(c);
+	pid = c->init_pid(c);
 	if (pid <= 0)
 		return false;
 	if (c->lxc_conf && c->lxc_conf->rebootsignal)
@@ -1495,9 +1386,7 @@ static bool do_lxcapi_reboot(struct lxc_container *c)
 
 }
 
-WRAP_API(bool, lxcapi_reboot)
-
-static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)
+static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 {
 	bool retv;
 	pid_t pid;
@@ -1506,20 +1395,18 @@ static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)
 	if (!c)
 		return false;
 
-	if (!do_lxcapi_is_running(c))
+	if (!c->is_running(c))
 		return true;
-	pid = do_lxcapi_init_pid(c);
+	pid = c->init_pid(c);
 	if (pid <= 0)
 		return true;
 	if (c->lxc_conf && c->lxc_conf->haltsignal)
 		haltsignal = c->lxc_conf->haltsignal;
 	kill(pid, haltsignal);
-	retv = do_lxcapi_wait(c, "STOPPED", timeout);
+	retv = c->wait(c, "STOPPED", timeout);
 	return retv;
 }
 
-WRAP_API_1(bool, lxcapi_shutdown, int)
-
 static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags, ...)
 {
@@ -1530,9 +1417,6 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	if (!c)
 		return false;
 
-	struct lxc_conf *old = current_config;
-	current_config = c->lxc_conf;
-
 	/*
 	 * since we're going to wait for create to finish, I don't think we
 	 * need to get a copy of the arguments.
@@ -1545,11 +1429,10 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		goto out;
 	}
 
-	bret = do_lxcapi_create(c, t, bdevtype, specs, flags, args);
+	bret = c->create(c, t, bdevtype, specs, flags, args);
 
 out:
 	free(args);
-	current_config = old;
 	return bret;
 }
 
@@ -1567,7 +1450,7 @@ static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)
 		WARN("Error clearing configuration for %s", key);
 }
 
-static bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key)
+static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 {
 	int ret;
 
@@ -1582,11 +1465,9 @@ static bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key
 	return ret == 0;
 }
 
-WRAP_API_1(bool, lxcapi_clear_config_item, const char *)
-
 static inline bool enter_net_ns(struct lxc_container *c)
 {
-	pid_t pid = do_lxcapi_init_pid(c);
+	pid_t pid = c->init_pid(c);
 
 	if ((geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) && access("/proc/self/ns/user", F_OK) == 0) {
 		if (!switch_to_ns(pid, "user"))
@@ -1666,7 +1547,7 @@ static bool remove_from_array(char ***names, char *cname, int size)
 	return false;
 }
 
-static char ** do_lxcapi_get_interfaces(struct lxc_container *c)
+static char** lxcapi_get_interfaces(struct lxc_container *c)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1753,9 +1634,7 @@ static char ** do_lxcapi_get_interfaces(struct lxc_container *c)
 	return interfaces;
 }
 
-WRAP_API(char **, lxcapi_get_interfaces)
-
-static char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
+static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1872,9 +1751,7 @@ static char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface,
 	return addresses;
 }
 
-WRAP_API_3(char **, lxcapi_get_ips, const char *, const char *, int)
-
-static int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
+static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	int ret;
 
@@ -1887,9 +1764,7 @@ static int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, c
 	return ret;
 }
 
-WRAP_API_3(int, lxcapi_get_config_item, const char *, char *, int)
-
-static char* do_lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
+static char* lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
 {
 	char *ret;
 
@@ -1897,14 +1772,12 @@ static char* do_lxcapi_get_running_config_item(struct lxc_container *c, const ch
 		return NULL;
 	if (container_mem_lock(c))
 		return NULL;
-	ret = lxc_cmd_get_config_item(c->name, key, do_lxcapi_get_config_path(c));
+	ret = lxc_cmd_get_config_item(c->name, key, c->get_config_path(c));
 	container_mem_unlock(c);
 	return ret;
 }
 
-WRAP_API_1(char *, lxcapi_get_running_config_item, const char *)
-
-static int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
+static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	if (!key)
 		return lxc_listconfigs(retv, inlen);
@@ -1924,9 +1797,7 @@ static int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *re
 	return ret;
 }
 
-WRAP_API_3(int, lxcapi_get_keys, const char *, char *, int)
-
-static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)
+static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	FILE *fout;
 	bool ret = false, need_disklock = false;
@@ -1939,7 +1810,7 @@ static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
-		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s while saving %s", lxc_global_config_value("lxc.default_config"), c->name);
 			return false;
 		}
@@ -1979,8 +1850,6 @@ out:
 	return ret;
 }
 
-WRAP_API_1(bool, lxcapi_save_config, const char *)
-
 static bool mod_rdep(struct lxc_container *c, bool inc)
 {
 	char path[MAXPATHLEN];
@@ -2169,7 +2038,7 @@ static bool container_destroy(struct lxc_container *c)
 	bool bret = false;
 	int ret;
 
-	if (!c || !do_lxcapi_is_defined(c))
+	if (!c || !lxcapi_is_defined(c))
 		return false;
 
 	if (container_disk_lock(c))
@@ -2194,7 +2063,7 @@ static bool container_destroy(struct lxc_container *c)
 
 	mod_all_rdeps(c, false);
 
-	const char *p1 = do_lxcapi_get_config_path(c);
+	const char *p1 = lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
 	if (am_unpriv())
@@ -2212,7 +2081,7 @@ out:
 	return bret;
 }
 
-static bool do_lxcapi_destroy(struct lxc_container *c)
+static bool lxcapi_destroy(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2229,9 +2098,9 @@ static bool do_lxcapi_destroy(struct lxc_container *c)
 	return container_destroy(c);
 }
 
-WRAP_API(bool, lxcapi_destroy)
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
 
-static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)
+static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2242,8 +2111,6 @@ static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)
 	return lxcapi_destroy(c);
 }
 
-WRAP_API(bool, lxcapi_destroy_with_snapshots)
-
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
 {
 	struct lxc_config_t *config;
@@ -2260,7 +2127,7 @@ static bool set_config_item_locked(struct lxc_container *c, const char *key, con
 	return do_append_unexp_config_line(c->lxc_conf, key, v);
 }
 
-static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
+static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
 {
 	bool b = false;
 
@@ -2276,8 +2143,6 @@ static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key,
 	return b;
 }
 
-WRAP_API_2(bool, lxcapi_set_config_item, const char *, const char *)
-
 static char *lxcapi_config_file_name(struct lxc_container *c)
 {
 	if (!c || !c->configfile)
@@ -2325,7 +2190,7 @@ static bool set_config_filename(struct lxc_container *c)
 	return true;
 }
 
-static bool do_lxcapi_set_config_path(struct lxc_container *c, const char *path)
+static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 {
 	char *p;
 	bool b = false;
@@ -2363,9 +2228,8 @@ err:
 	return b;
 }
 
-WRAP_API_1(bool, lxcapi_set_config_path, const char *)
 
-static bool do_lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
+static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
 {
 	int ret;
 
@@ -2384,9 +2248,7 @@ static bool do_lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsy
 	return ret == 0;
 }
 
-WRAP_API_2(bool, lxcapi_set_cgroup_item, const char *, const char *)
-
-static int do_lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
+static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
 {
 	int ret;
 
@@ -2405,8 +2267,6 @@ static int do_lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys
 	return ret;
 }
 
-WRAP_API_3(int, lxcapi_get_cgroup_item, const char *, char *, int)
-
 const char *lxc_get_global_config_item(const char *key)
 {
 	return lxc_global_config_value(key);
@@ -2523,7 +2383,7 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 		ERROR("Error saving new hooks in clone");
 		return -1;
 	}
-	do_lxcapi_save_config(c, NULL);
+	c->save_config(c, NULL);
 	return 0;
 }
 
@@ -2795,7 +2655,7 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	return ret;
 }
 
-static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,
+static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, uint64_t newsize,
 		char **hookargs)
@@ -2808,7 +2668,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	FILE *fout;
 	pid_t pid;
 
-	if (!c || !do_lxcapi_is_defined(c))
+	if (!c || !c->is_defined(c))
 		return NULL;
 
 	if (container_mem_lock(c))
@@ -2823,7 +2683,7 @@ static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char
 	if (!newname)
 		newname = c->name;
 	if (!lxcpath)
-		lxcpath = do_lxcapi_get_config_path(c);
+		lxcpath = c->get_config_path(c);
 	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", lxcpath, newname);
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		SYSERROR("clone: failed making config pathname");
@@ -2952,20 +2812,7 @@ out:
 	return NULL;
 }
 
-static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
-		const char *lxcpath, int flags,
-		const char *bdevtype, const char *bdevdata, uint64_t newsize,
-		char **hookargs)
-{
-	struct lxc_container * ret;
-	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
-	ret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);
-	current_config = old;
-	return ret;
-}
-
-static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)
+static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 {
 	struct bdev *bdev;
 	struct lxc_container *newc;
@@ -3000,24 +2847,15 @@ static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)
 	return true;
 }
 
-WRAP_API_1(bool, lxcapi_rename, const char *)
-
 static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process)
 {
-	struct lxc_conf *old = current_config;
-	int ret;
-
 	if (!c)
 		return -1;
 
-	current_config = c->lxc_conf;
-
-	ret = lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
-	current_config = old;
-	return ret;
+	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
 }
 
-static int do_lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
 {
 	lxc_attach_command_t command;
 	pid_t pid;
@@ -3036,16 +2874,6 @@ static int do_lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options
 	return lxc_wait_for_pid_status(pid);
 }
 
-static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
-{
-	int ret;
-	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
-	ret = do_lxcapi_attach_run_wait(c, options, program, argv);
-	current_config = old;
-	return ret;
-}
-
 static int get_next_index(const char *lxcpath, char *cname)
 {
 	char *fname;
@@ -3089,7 +2917,7 @@ static bool get_snappath_dir(struct lxc_container *c, char *snappath)
 	return true;
 }
 
-static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
+static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
@@ -3131,7 +2959,7 @@ static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 		ERROR("and keep the original container pristine.");
 		flags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
 	}
-	c2 = do_lxcapi_clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
+	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
 		ERROR("clone of %s:%s failed", c->config_path, c->name);
 		return -1;
@@ -3179,8 +3007,6 @@ static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	return i;
 }
 
-WRAP_API_1(int, lxcapi_snapshot, const char *)
-
 static void lxcsnap_free(struct lxc_snapshot *s)
 {
 	free(s->name);
@@ -3235,7 +3061,7 @@ static char *get_timestamp(char* snappath, char *name)
 	return s;
 }
 
-static int do_lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
+static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
 	int count = 0, ret;
@@ -3311,9 +3137,7 @@ out_free:
 	return -1;
 }
 
-WRAP_API_1(int, lxcapi_snapshot_list, struct lxc_snapshot **)
-
-static bool do_lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
+static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
 	int flags = 0;
@@ -3374,8 +3198,6 @@ static bool do_lxcapi_snapshot_restore(struct lxc_container *c, const char *snap
 	return b;
 }
 
-WRAP_API_2(bool, lxcapi_snapshot_restore, const char *, const char *)
-
 static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 {
 	struct lxc_container *snap = NULL;
@@ -3387,7 +3209,7 @@ static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 		goto err;
 	}
 
-	if (!do_lxcapi_destroy(snap)) {
+	if (!lxcapi_destroy(snap)) {
 		ERROR("Could not destroy snapshot %s", snapname);
 		goto err;
 	}
@@ -3431,7 +3253,7 @@ static bool remove_all_snapshots(const char *path)
 	return bret;
 }
 
-static bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
+static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3444,9 +3266,7 @@ static bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snap
 	return do_snapshot_destroy(snapname, clonelxcpath);
 }
 
-WRAP_API_1(bool, lxcapi_snapshot_destroy, const char *)
-
-static bool do_lxcapi_snapshot_destroy_all(struct lxc_container *c)
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3459,15 +3279,11 @@ static bool do_lxcapi_snapshot_destroy_all(struct lxc_container *c)
 	return remove_all_snapshots(clonelxcpath);
 }
 
-WRAP_API(bool, lxcapi_snapshot_destroy_all)
-
-static bool do_lxcapi_may_control(struct lxc_container *c)
+static bool lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
-WRAP_API(bool, lxcapi_may_control)
-
 static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,
 		struct stat *st)
 {
@@ -3531,7 +3347,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	const char *p;
 
 	/* make sure container is running */
-	if (!do_lxcapi_is_running(c)) {
+	if (!c->is_running(c)) {
 		ERROR("container is not running");
 		return false;
 	}
@@ -3555,17 +3371,17 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	if (ret < 0 || ret >= MAX_BUFFER)
 		return false;
 
-	if (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))
+	if (!do_add_remove_node(c->init_pid(c), p, add, &st))
 		return false;
 
 	/* add or remove device to/from cgroup access list */
 	if (add) {
-		if (!do_lxcapi_set_cgroup_item(c, "devices.allow", value)) {
+		if (!c->set_cgroup_item(c, "devices.allow", value)) {
 			ERROR("set_cgroup_item failed while adding the device node");
 			return false;
 		}
 	} else {
-		if (!do_lxcapi_set_cgroup_item(c, "devices.deny", value)) {
+		if (!c->set_cgroup_item(c, "devices.deny", value)) {
 			ERROR("set_cgroup_item failed while removing the device node");
 			return false;
 		}
@@ -3574,7 +3390,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	return true;
 }
 
-static bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3583,9 +3399,7 @@ static bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_p
 	return add_remove_device_node(c, src_path, dest_path, true);
 }
 
-WRAP_API_2(bool, lxcapi_add_device_node, const char *, const char *)
-
-static bool do_lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3594,9 +3408,7 @@ static bool do_lxcapi_remove_device_node(struct lxc_container *c, const char *sr
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
-WRAP_API_2(bool, lxcapi_remove_device_node, const char *, const char *)
-
-static bool do_lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
+static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 				const char *dst_ifname)
 {
 	int ret = 0;
@@ -3619,7 +3431,7 @@ static bool do_lxcapi_attach_interface(struct lxc_container *c, const char *ifna
 			goto err;
 	}
 
-	ret = lxc_netdev_move_by_name(ifname, do_lxcapi_init_pid(c), dst_ifname);
+	ret = lxc_netdev_move_by_name(ifname, c->init_pid(c), dst_ifname);
 	if (ret)
 		goto err;
 
@@ -3629,9 +3441,7 @@ err:
 	return false;
 }
 
-WRAP_API_2(bool, lxcapi_attach_interface, const char *, const char *)
-
-static bool do_lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
+static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 					const char *dst_ifname)
 {
 	pid_t pid, pid_outside;
@@ -3686,8 +3496,6 @@ static bool do_lxcapi_detach_interface(struct lxc_container *c, const char *ifna
 	return true;
 }
 
-WRAP_API_2(bool, lxcapi_detach_interface, const char *, const char *)
-
 struct criu_opts {
 	/* The type of criu invocation, one of "dump" or "restore" */
 	char *action;
@@ -4049,7 +3857,7 @@ out:
 	return true;
 }
 
-static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
 {
 	pid_t pid;
 	int status;
@@ -4094,8 +3902,6 @@ static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool
 	}
 }
 
-WRAP_API_3(bool, lxcapi_checkpoint, char *, bool, bool)
-
 static bool restore_net_info(struct lxc_container *c)
 {
 	struct lxc_list *it;
@@ -4274,7 +4080,7 @@ out:
 	exit(1);
 }
 
-static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
 	pid_t pid;
 	int status, nread;
@@ -4328,8 +4134,6 @@ err_wait:
 	return false;
 }
 
-WRAP_API_2(bool, lxcapi_restore, char *, bool)
-
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -4339,24 +4143,18 @@ static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
-	struct lxc_conf *old = current_config;
-	current_config = c->lxc_conf;
-
 	va_start(ap, arg);
 	argv = lxc_va_arg_list_to_argv_const(ap, 1);
 	va_end(ap);
 
 	if (!argv) {
 		ERROR("Memory allocation error.");
-		ret = -1;
-		goto out;
+		return -1;
 	}
 	argv[0] = arg;
 
-	ret = do_lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
+	ret = lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
 	free((void*)argv);
-out:
-	current_config = old;
 	return ret;
 }
 
@@ -4473,6 +4271,12 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 
+	/* we'll allow the caller to update these later */
+	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {
+		fprintf(stderr, "failed to open log\n");
+		goto err;
+	}
+
 	return c;
 
 err:
@@ -4546,7 +4350,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 					goto free_bad;
 			continue;
 		}
-		if (!do_lxcapi_is_defined(c)) {
+		if (!lxcapi_is_defined(c)) {
 			INFO("Container %s:%s has a config but is not defined",
 				lxcpath, direntp->d_name);
 			if (names)

commit d775f21bb14950614e31b1e101a85817d4988305
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 14 14:56:10 2015 -0500

    Revert "do_lxcap_stop: wait until container is stopped"
    
    This breaks lxc-test-concurrent.
    
    This reverts commit fef9aa89e99285609d51848623f84ecd3a3109df.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e86151c..5b96b8c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -852,10 +852,7 @@ static bool do_lxcapi_stop(struct lxc_container *c)
 
 	ret = lxc_cmd_stop(c->name, c->config_path);
 
-	if (ret == 0)
-		return do_lxcapi_wait(c, "STOPPED", 10);
-
-	return false;
+	return ret == 0;
 }
 
 WRAP_API(bool, lxcapi_stop)

commit fef9aa89e99285609d51848623f84ecd3a3109df
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 14 09:28:20 2015 -0500

    do_lxcap_stop: wait until container is stopped
    
    In the past, lxc-cmd-stop would wait until the command pipe was closed
    before returning, ensuring that the container monitor had exited.
    Now that we accept the actual success return value, lxcapi_stop can
    return success before the monitor has fully exited.
    
    So explicitly wait for the container to stop, when lxc-cmd-stop returned
    success.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5b96b8c..e86151c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -852,7 +852,10 @@ static bool do_lxcapi_stop(struct lxc_container *c)
 
 	ret = lxc_cmd_stop(c->name, c->config_path);
 
-	return ret == 0;
+	if (ret == 0)
+		return do_lxcapi_wait(c, "STOPPED", 10);
+
+	return false;
 }
 
 WRAP_API(bool, lxcapi_stop)

commit e438ef7c9a4cf256038d1f93c671ded60d09571e
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Apr 13 18:07:03 2015 +0000

    fix dead code
    
    We've already checked that c is not null above, so the false branch can never
    be taken here.
    
    Reported-by: Coverity
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0218e57..5b96b8c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1531,7 +1531,7 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		return false;
 
 	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
+	current_config = c->lxc_conf;
 
 	/*
 	 * since we're going to wait for create to finish, I don't think we

commit dcd1e262744cd37f054264254a7e1472255e6936
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Apr 13 18:07:02 2015 +0000

    fix NULL dereference
    
    lxc_console dereferences C, so we should check that it is not null and fail if
    it is.
    
    Reported-by: Coverity
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6a2b080..0218e57 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -463,7 +463,11 @@ static int lxcapi_console(struct lxc_container *c, int ttynum, int stdinfd,
 {
 	int ret;
 	struct lxc_conf *old = current_config;
-	current_config = c ? c->lxc_conf : NULL;
+
+	if (!c)
+		return -1;
+
+	current_config = c->lxc_conf;
 	ret = lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
 	current_config = old;
 	return ret;

commit 284c4b01ccc887c8cee6cf4b59d7e206a09535b9
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Mon Apr 13 18:07:01 2015 +0000

    c/r: no double fclose() of mnts
    
    Reported-by: Coverity
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3c3ff33..6a2b080 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3895,6 +3895,7 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG(arg);
 	}
 	fclose(mnts);
+	mnts = NULL;
 
 	argv[argc] = NULL;
 

commit f813849cee365da37341f3558689a908e7739b1b
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Apr 9 21:59:19 2015 +0000

    c/r: populate clone flags on restore
    
    Since attach asks the restore process what the clone flags were, if we forgot
    to set them then the attach command ran in the hosts namespaces instead of the
    containers, which is a Very Bad Thing :). Instead, we remember to set the clone
    flags in the restore process' handler, so that we report them correctly to any
    attach processes who ask.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0d81552..3c3ff33 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4149,6 +4149,8 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 		goto out_fini_handler;
 	}
 
+	resolve_clone_flags(handler);
+
 	pid = fork();
 	if (pid < 0)
 		goto out_fini_handler;

commit 5622425a427572df6d8896a24784eee15544675a
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Apr 6 19:02:40 2015 -0400

    Really fix Android...
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 726229f..0d81552 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -36,7 +36,6 @@
 #include <stdint.h>
 #include <grp.h>
 #include <stdio.h>
-#include <mntent.h>
 #include <sys/syscall.h>
 
 #include <lxc/lxccontainer.h>

commit 684f79a55a6909ac3669eb6126796853f85b28eb
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Apr 6 17:58:44 2015 -0400

    Fix Android build because of getmntent_r
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ee664f7..726229f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -67,6 +67,12 @@
 #include <../include/ifaddrs.h>
 #endif
 
+#if IS_BIONIC
+#include <../include/lxcmntent.h>
+#else
+#include <mntent.h>
+#endif
+
 #define MAX_BUFFER 4096
 
 #define NOT_SUPPORTED_ERROR "the requested function %s is not currently supported with unprivileged containers"
@@ -84,7 +90,6 @@ return -1;
 }
 #endif
 
-
 lxc_log_define(lxc_container, lxc);
 
 static bool do_lxcapi_destroy(struct lxc_container *c);

commit 9fc7f8c015b627a978784779ed94b9ac99a9800b
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Mar 26 15:36:53 2015 -0600

    c/r: tell CRIU about all external mounts in the config
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4762b13..ee664f7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -35,6 +35,8 @@
 #include <libgen.h>
 #include <stdint.h>
 #include <grp.h>
+#include <stdio.h>
+#include <mntent.h>
 #include <sys/syscall.h>
 
 #include <lxc/lxccontainer.h>
@@ -3701,11 +3703,15 @@ struct criu_opts {
 
 static void exec_criu(struct criu_opts *opts)
 {
-	char **argv, log[PATH_MAX], buf[257];
+	char **argv, log[PATH_MAX];
 	int static_args = 14, argc = 0, i, ret;
 	int netnr = 0;
 	struct lxc_list *it;
 
+	struct mntent mntent;
+	char buf[4096];
+	FILE *mnts = NULL;
+
 	/* The command line always looks like:
 	 * criu $(action) --tcp-established --file-locks --link-remap --force-irmap \
 	 * --manage-cgroups action-script foo.sh -D $(directory) \
@@ -3780,6 +3786,27 @@ static void exec_criu(struct criu_opts *opts)
 	if (opts->verbose)
 		DECLARE_ARG("-vvvvvv");
 
+	/*
+	 * Note: this macro is not intended to be called unless argc is equal
+	 * to the length of the array; there is nothing that keeps track of the
+	 * length of the array besides the location in the code that this is
+	 * called. (Yes this is bad, and we should fix it.)
+	 */
+#define RESIZE_ARGS(additional) 						\
+	do {									\
+		void *m;							\
+		if (additional < 0) {						\
+			ERROR("resizing by negative amount");			\
+			goto err;						\
+		} else if (additional == 0)					\
+			continue;						\
+										\
+		m = realloc(argv, (argc + additional + 1) * sizeof(*argv));	\
+		if (!m)								\
+			goto err;						\
+		argv = m;							\
+	} while (0)
+
 	if (strcmp(opts->action, "dump") == 0) {
 		char pid[32];
 
@@ -3811,9 +3838,10 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG("--cgroup-root");
 		DECLARE_ARG(opts->cgroup_path);
 
+		RESIZE_ARGS(lxc_list_len(&opts->c->lxc_conf->network) * 2);
+
 		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
 			char eth[128], *veth;
-			void *m;
 			struct lxc_netdev *n = it->elem;
 
 			if (n->name) {
@@ -3829,18 +3857,42 @@ static void exec_criu(struct criu_opts *opts)
 			if (ret < 0 || ret >= sizeof(buf))
 				goto err;
 
-			/* final NULL and --veth-pair eth0=vethASDF */
-			m = realloc(argv, (argc + 1 + 2) * sizeof(*argv));
-			if (!m)
-				goto err;
-			argv = m;
-
 			DECLARE_ARG("--veth-pair");
 			DECLARE_ARG(buf);
-			argv[argc] = NULL;
+		}
+	}
 
+	// CRIU wants to know about any external bind mounts the
+	// container has.
+	mnts = write_mount_file(&opts->c->lxc_conf->mount_list);
+	if (!mnts)
+		goto err;
+
+	RESIZE_ARGS(lxc_list_len(&opts->c->lxc_conf->mount_list) * 2);
+
+	while (getmntent_r(mnts, &mntent, buf, sizeof(buf))) {
+		char arg[2048], *key, *val;
+		int ret;
+
+		if (strcmp(opts->action, "dump") == 0) {
+			key = mntent.mnt_fsname;
+			val = mntent.mnt_dir;
+		} else {
+			key = mntent.mnt_dir;
+			val = mntent.mnt_fsname;
 		}
+
+		ret = snprintf(arg, sizeof(arg), "%s:%s", key, val);
+		if (ret < 0 || ret >= sizeof(arg)) {
+			goto err;
+		}
+
+		DECLARE_ARG("--ext-mount-map");
+		DECLARE_ARG(arg);
 	}
+	fclose(mnts);
+
+	argv[argc] = NULL;
 
 	netnr = 0;
 	lxc_list_for_each(it, &opts->c->lxc_conf->network) {
@@ -3876,8 +3928,11 @@ static void exec_criu(struct criu_opts *opts)
 	}
 
 #undef DECLARE_ARG
+#undef RESIZE_ARGS
 	execv(argv[0], argv);
 err:
+	if (mnts)
+		fclose(mnts);
 	for (i = 0; argv[i]; i++)
 		free(argv[i]);
 	free(argv);

commit 3fdf4a73a25b5311af8dd7b8812f68d312ce566a
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Apr 3 21:17:26 2015 +0000

    Use SYSERROR instead of perror
    
    It is impolite to print stuff to stderror owned by other people, and they might
    miss it anyway since it's not in the normal log location.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6ce5185..4762b13 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4018,7 +4018,7 @@ static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool
 	} else {
 		pid_t w = waitpid(pid, &status, 0);
 		if (w == -1) {
-			perror("waitpid");
+			SYSERROR("waitpid");
 			return false;
 		}
 
@@ -4139,7 +4139,7 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 
 		pid_t w = waitpid(pid, &status, 0);
 		if (w == -1) {
-			perror("waitpid");
+			SYSERROR("waitpid");
 			goto out_fini_handler;
 		}
 
@@ -4148,8 +4148,7 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 		pipe = -1;
 
 		if (sizeof(status) != ret) {
-			perror("write");
-			ERROR("failed to write all of status");
+			SYSERROR("failed to write all of status");
 			goto out_fini_handler;
 		}
 
@@ -4160,8 +4159,7 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 				int ret;
 				FILE *f = fopen(pidfile, "r");
 				if (!f) {
-					perror("reading pidfile");
-					ERROR("couldn't read restore's init pidfile %s\n", pidfile);
+					SYSERROR("couldn't read restore's init pidfile %s\n", pidfile);
 					goto out_fini_handler;
 				}
 

commit 5b3105f5e4f111c6e855a0aad18793dcc4e985f5
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Apr 3 21:17:25 2015 +0000

    don't hang on some errors in do_restore
    
    Instead, the parent always writes a status to the pipe.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6ac829a..6ce5185 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4066,13 +4066,14 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 	pid_t pid;
 	char pidfile[L_tmpnam];
 	struct lxc_handler *handler;
+	int status;
 
 	if (!tmpnam(pidfile))
-		exit(1);
+		goto out;
 
 	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
 	if (!handler)
-		exit(1);
+		goto out;
 
 	if (!cgroup_init(handler)) {
 		ERROR("failed initing cgroups");
@@ -4097,6 +4098,9 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 		struct criu_opts os;
 		struct lxc_rootfs *rootfs;
 
+		close(pipe);
+		pipe = -1;
+
 		if (unshare(CLONE_NEWNS))
 			goto out_fini_handler;
 
@@ -4130,7 +4134,7 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 		rmdir(rootfs->mount);
 		goto out_fini_handler;
 	} else {
-		int status, ret;
+		int ret;
 		char title[2048];
 
 		pid_t w = waitpid(pid, &status, 0);
@@ -4141,6 +4145,7 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 
 		ret = write(pipe, &status, sizeof(status));
 		close(pipe);
+		pipe = -1;
 
 		if (sizeof(status) != ret) {
 			perror("write");
@@ -4192,6 +4197,16 @@ static void do_restore(struct lxc_container *c, int pipe, char *directory, bool
 
 out_fini_handler:
 	lxc_fini(c->name, handler);
+
+out:
+	if (pipe >= 0) {
+		status = 1;
+		if (write(pipe, &status, sizeof(status)) != sizeof(status)) {
+			SYSERROR("writing status failed");
+		}
+		close(pipe);
+	}
+
 	exit(1);
 }
 

commit c9d8f2ee720b4fe1b3642be90dfe9418d2232de5
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Mar 20 10:17:31 2015 -0600

    lxcapi_restore shouldn't steal the calling process
    
    Previously, lxcapi_restore used the calling process as the lxc monitor process
    (and just never returned), requiring users to fork before calling it. This, of
    course, would cause problems for things like LXD, which can't fork.
    
    Now, restore() forks the monitor as a child of the process that calls it. Users
    who want to daemonize the restore process need to fork themselves.
    lxc-checkpoint has been updated to reflect this behavior change.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8d7fad4..6ac829a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4059,28 +4059,20 @@ out_unlock:
 	return !has_error;
 }
 
-static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+// do_restore never returns, the calling process is used as the
+// monitor process. do_restore calls exit() if it fails.
+static void do_restore(struct lxc_container *c, int pipe, char *directory, bool verbose)
 {
 	pid_t pid;
-	struct lxc_rootfs *rootfs;
 	char pidfile[L_tmpnam];
 	struct lxc_handler *handler;
-	bool has_error = true;
-
-	if (!criu_ok(c))
-		return false;
-
-	if (geteuid()) {
-		ERROR("Must be root to restore\n");
-		return false;
-	}
 
 	if (!tmpnam(pidfile))
-		return false;
+		exit(1);
 
 	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
 	if (!handler)
-		return false;
+		exit(1);
 
 	if (!cgroup_init(handler)) {
 		ERROR("failed initing cgroups");
@@ -4103,9 +4095,10 @@ static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool ver
 
 	if (pid == 0) {
 		struct criu_opts os;
+		struct lxc_rootfs *rootfs;
 
 		if (unshare(CLONE_NEWNS))
-			exit(1);
+			goto out_fini_handler;
 
 		/* CRIU needs the lxc root bind mounted so that it is the root of some
 		 * mount. */
@@ -4113,15 +4106,14 @@ static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool ver
 
 		if (rootfs_is_blockdev(c->lxc_conf)) {
 			if (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)
-				exit(1);
-		}
-		else {
+				goto out_fini_handler;
+		} else {
 			if (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)
-				exit(1);
+				goto out_fini_handler;
 
 			if (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {
 				rmdir(rootfs->mount);
-				exit(1);
+				goto out_fini_handler;
 			}
 		}
 
@@ -4136,22 +4128,30 @@ static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool ver
 		exec_criu(&os);
 		umount(rootfs->mount);
 		rmdir(rootfs->mount);
-		exit(1);
+		goto out_fini_handler;
 	} else {
-		int status;
+		int status, ret;
+		char title[2048];
 
 		pid_t w = waitpid(pid, &status, 0);
-
 		if (w == -1) {
 			perror("waitpid");
 			goto out_fini_handler;
 		}
 
+		ret = write(pipe, &status, sizeof(status));
+		close(pipe);
+
+		if (sizeof(status) != ret) {
+			perror("write");
+			ERROR("failed to write all of status");
+			goto out_fini_handler;
+		}
+
 		if (WIFEXITED(status)) {
 			if (WEXITSTATUS(status)) {
 				goto out_fini_handler;
-			}
-			else {
+			} else {
 				int ret;
 				FILE *f = fopen(pidfile, "r");
 				if (!f) {
@@ -4175,17 +4175,78 @@ static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool ver
 			goto out_fini_handler;
 		}
 
-		if (lxc_poll(c->name, handler)) {
+		/*
+		 * See comment in lxcapi_start; we don't care if these
+		 * fail because it's just a beauty thing. We just
+		 * assign the return here to silence potential.
+		 */
+		ret = snprintf(title, sizeof(title), "[lxc monitor] %s %s", c->config_path, c->name);
+		ret = setproctitle(title);
+
+		ret = lxc_poll(c->name, handler);
+		if (ret)
 			lxc_abort(c->name, handler);
-			goto out_fini_handler;
-		}
+		lxc_fini(c->name, handler);
+		exit(ret);
 	}
 
-	has_error = false;
-
 out_fini_handler:
 	lxc_fini(c->name, handler);
-	return !has_error;
+	exit(1);
+}
+
+static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+{
+	pid_t pid;
+	int status, nread;
+	int pipefd[2];
+
+	if (!criu_ok(c))
+		return false;
+
+	if (geteuid()) {
+		ERROR("Must be root to restore\n");
+		return false;
+	}
+
+	if (pipe(pipefd)) {
+		ERROR("failed to create pipe");
+		return false;
+	}
+
+	pid = fork();
+	if (pid < 0) {
+		close(pipefd[0]);
+		close(pipefd[1]);
+		return false;
+	}
+
+	if (pid == 0) {
+		close(pipefd[0]);
+		// this never returns
+		do_restore(c, pipefd[1], directory, verbose);
+	}
+
+	close(pipefd[1]);
+
+	nread = read(pipefd[0], &status, sizeof(status));
+	close(pipefd[0]);
+	if (sizeof(status) != nread) {
+		ERROR("reading status from pipe failed");
+		goto err_wait;
+	}
+
+	// If the criu process was killed or exited nonzero, wait() for the
+	// handler, since the restore process died. Otherwise, we don't need to
+	// wait, since the child becomes the monitor process.
+	if (!WIFEXITED(status) || WEXITSTATUS(status))
+		goto err_wait;
+	return true;
+
+err_wait:
+	if (wait_for_pid(pid))
+		ERROR("restore process died");
+	return false;
 }
 
 WRAP_API_2(bool, lxcapi_restore, char *, bool)

commit 23befb186298582fccd07eec6083678c35ea9736
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Mar 26 15:52:32 2015 +0000

    c/r: teach criu about cgmanager's socket
    
    CRIU needs to be told when something is bind mounted into the container from
    the outside as cgmanager's socket is.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1eadc63..8d7fad4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3736,6 +3736,11 @@ static void exec_criu(struct criu_opts *opts)
 		return;
 	}
 
+	// We need to tell criu where cgmanager's socket is bind mounted from
+	// if it exists since it's external.
+	if (cgroup_driver() == CGMANAGER)
+		static_args+=2;
+
 	argv = malloc(static_args * sizeof(*argv));
 	if (!argv)
 		return;
@@ -3778,6 +3783,11 @@ static void exec_criu(struct criu_opts *opts)
 	if (strcmp(opts->action, "dump") == 0) {
 		char pid[32];
 
+		if (cgroup_driver() == CGMANAGER) {
+			DECLARE_ARG("--ext-mount-map");
+			DECLARE_ARG("/sys/fs/cgroup/cgmanager:cgmanager");
+		}
+
 		if (sprintf(pid, "%d", lxcapi_init_pid(opts->c)) < 0)
 			goto err;
 
@@ -3786,6 +3796,12 @@ static void exec_criu(struct criu_opts *opts)
 		if (!opts->stop)
 			DECLARE_ARG("--leave-running");
 	} else if (strcmp(opts->action, "restore") == 0) {
+
+		if (cgroup_driver() == CGMANAGER) {
+			DECLARE_ARG("--ext-mount-map");
+			DECLARE_ARG("cgmanager:/sys/fs/cgroup/cgmanager");
+		}
+
 		DECLARE_ARG("--root");
 		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
 		DECLARE_ARG("--restore-detached");

commit 42e56013ea756be668e6c74d3f45c72ee450a527
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Mar 11 22:10:55 2015 +0000

    logs: introduce a thread-local 'current' lxc_config
    
    The logging code uses a global log_fd and log_level to direct
    logging (ERROR(), etc).  While the container configuration file allows
    for lxc.loglevel and lxc.logfile, those are only used at configuration
    file read time to set the global variables.  This works ok in the
    lxc front-end programs, but becomes a problem with threaded API users.
    
    The simplest solution would be to not allow per-container configuration
    files, but it'd be nice to avoid that.
    
    Passing a logfd or lxc_conf into every ERROR/INFO/etc call is "possible",
    but would be a huge complication as there are many functions, including
    struct member functions and callbacks, which don't have that info and
    would need to get it from somewhere.
    
    So the approach I'm taking here is to say that all real container work
    is done inside api calls, and therefore the API calls themselves can
    set a thread-local variable indicating which log info to use.  If
    unset, then use the global values.  The lxc-* programs, when called
    with a '-o logfile' argument, set a global variable to indicate that
    the user-specified value should be used.
    
    In this patch:
    
    If the lxc container configuration specifies a loglevel/logfile, only
    set the lxc_config's logfd and loglevel according to those, not the
    global values.
    
    Each API call is wrapped to set/unset the current_config.  (The few
    exceptions are calls which do not result in any log actions)
    
    Update logfile appender to use the logfile specified in lxc_conf if (a)
    current_config is set and (b) the lxc-* command did not override it.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4422f4a..1eadc63 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -85,6 +85,15 @@ return -1;
 
 lxc_log_define(lxc_container, lxc);
 
+static bool do_lxcapi_destroy(struct lxc_container *c);
+static const char *lxcapi_get_config_path(struct lxc_container *c);
+#define do_lxcapi_get_config_path(c) lxcapi_get_config_path(c)
+static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
+static bool container_destroy(struct lxc_container *c);
+static bool get_snappath_dir(struct lxc_container *c, char *snappath);
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
+static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file);
+
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
 	/* $lxcpath + '/' + $cname + '/config' + \0 */
@@ -301,7 +310,7 @@ int lxc_container_put(struct lxc_container *c)
 	return 0;
 }
 
-static bool lxcapi_is_defined(struct lxc_container *c)
+static bool do_lxcapi_is_defined(struct lxc_container *c)
 {
 	struct stat statbuf;
 	bool ret = false;
@@ -324,7 +333,53 @@ out:
 	return ret;
 }
 
-static const char *lxcapi_state(struct lxc_container *c)
+#define WRAP_API(rettype, fnname)					\
+static rettype fnname(struct lxc_container *c)				\
+{									\
+	rettype ret;							\
+	struct lxc_conf *old = current_config;				\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c);						\
+	current_config = old;						\
+	return ret;							\
+}
+
+#define WRAP_API_1(rettype, fnname, t1)					\
+static rettype fnname(struct lxc_container *c, t1 a1)			\
+{									\
+	rettype ret;							\
+	struct lxc_conf *old = current_config;				\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1);					\
+	current_config = old;						\
+	return ret;							\
+}
+
+#define WRAP_API_2(rettype, fnname, t1, t2)				\
+static rettype fnname(struct lxc_container *c, t1 a1, t2 a2)		\
+{									\
+	rettype ret;							\
+	struct lxc_conf *old = current_config;				\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1, a2);					\
+	current_config = old;						\
+	return ret;							\
+}
+
+#define WRAP_API_3(rettype, fnname, t1, t2, t3)				\
+static rettype fnname(struct lxc_container *c, t1 a1, t2 a2, t3 a3)	\
+{									\
+	rettype ret;							\
+	struct lxc_conf *old = current_config;				\
+	current_config = c ? c->lxc_conf : NULL;			\
+	ret = do_##fnname(c, a1, a2, a3);				\
+	current_config = old;						\
+	return ret;							\
+}
+
+WRAP_API(bool, lxcapi_is_defined)
+
+static const char *do_lxcapi_state(struct lxc_container *c)
 {
 	lxc_state_t s;
 
@@ -334,6 +389,8 @@ static const char *lxcapi_state(struct lxc_container *c)
 	return lxc_state2str(s);
 }
 
+WRAP_API(const char *, lxcapi_state)
+
 static bool is_stopped(struct lxc_container *c)
 {
 	lxc_state_t s;
@@ -341,19 +398,21 @@ static bool is_stopped(struct lxc_container *c)
 	return (s == STOPPED);
 }
 
-static bool lxcapi_is_running(struct lxc_container *c)
+static bool do_lxcapi_is_running(struct lxc_container *c)
 {
 	const char *s;
 
 	if (!c)
 		return false;
-	s = lxcapi_state(c);
+	s = do_lxcapi_state(c);
 	if (!s || strcmp(s, "STOPPED") == 0)
 		return false;
 	return true;
 }
 
-static bool lxcapi_freeze(struct lxc_container *c)
+WRAP_API(bool, lxcapi_is_running)
+
+static bool do_lxcapi_freeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -365,7 +424,9 @@ static bool lxcapi_freeze(struct lxc_container *c)
 	return true;
 }
 
-static bool lxcapi_unfreeze(struct lxc_container *c)
+WRAP_API(bool, lxcapi_freeze)
+
+static bool do_lxcapi_unfreeze(struct lxc_container *c)
 {
 	int ret;
 	if (!c)
@@ -377,7 +438,9 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	return true;
 }
 
-static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
+WRAP_API(bool, lxcapi_unfreeze)
+
+static int do_lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
 {
 	int ttyfd;
 	if (!c)
@@ -387,13 +450,20 @@ static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *maste
 	return ttyfd;
 }
 
+WRAP_API_2(int, lxcapi_console_getfd, int *, int *)
+
 static int lxcapi_console(struct lxc_container *c, int ttynum, int stdinfd,
 			  int stdoutfd, int stderrfd, int escape)
 {
-	return lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
+	int ret;
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
+	current_config = old;
+	return ret;
 }
 
-static pid_t lxcapi_init_pid(struct lxc_container *c)
+static pid_t do_lxcapi_init_pid(struct lxc_container *c)
 {
 	if (!c)
 		return -1;
@@ -401,6 +471,8 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 	return lxc_cmd_get_init_pid(c->name, c->config_path);
 }
 
+WRAP_API(pid_t, lxcapi_init_pid)
+
 static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
@@ -412,7 +484,7 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 	return true;
 }
 
-static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
+static bool do_lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 {
 	bool ret = false, need_disklock = false;
 	int lret;
@@ -449,7 +521,9 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
-static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
+WRAP_API_1(bool, lxcapi_load_config, const char *)
+
+static bool do_lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -462,7 +536,9 @@ static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 	return true;
 }
 
-static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
+WRAP_API_1(bool, lxcapi_want_daemonize, bool)
+
+static bool do_lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -475,7 +551,9 @@ static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 	return true;
 }
 
-static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
+WRAP_API_1(bool, lxcapi_want_close_all_fds, bool)
+
+static bool do_lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 {
 	int ret;
 
@@ -486,8 +564,9 @@ static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 	return ret == 0;
 }
 
+WRAP_API_2(bool, lxcapi_wait, const char *, int)
 
-static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
+static bool do_wait_on_daemonized_start(struct lxc_container *c, int pid)
 {
 	/* we'll probably want to make this timeout configurable? */
 	int timeout = 5, ret, status;
@@ -499,9 +578,11 @@ static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
 	ret = waitpid(pid, &status, 0);
 	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
 		DEBUG("failed waiting for first dual-fork child");
-	return lxcapi_wait(c, "RUNNING", timeout);
+	return do_lxcapi_wait(c, "RUNNING", timeout);
 }
 
+WRAP_API_1(bool, wait_on_daemonized_start, int)
+
 static bool am_single_threaded(void)
 {
 	struct dirent dirent, *direntp;
@@ -534,7 +615,7 @@ static bool am_single_threaded(void)
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
  */
-static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
+static bool do_lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
 	struct lxc_conf *conf;
@@ -559,7 +640,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	}
 	if (ret == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
-		c->destroy(c);
+		do_lxcapi_destroy(c);
 		return false;
 	} else if (ret == 1) {
 		ERROR("Error: creation of %s is ongoing", c->name);
@@ -702,6 +783,16 @@ out:
 		return (ret == 0 ? true : false);
 }
 
+static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
+{
+	bool ret;
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_start(c, useinit, argv);
+	current_config = old;
+	return ret;
+}
+
 /*
  * note there MUST be an ending NULL
  */
@@ -715,6 +806,9 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	if (!c)
 		return false;
 
+	struct lxc_conf *old = current_config;
+	current_config = c->lxc_conf;
+
 	va_start(ap, useinit);
 	inargs = lxc_va_arg_list_to_argv(ap, 0, 1);
 	va_end(ap);
@@ -725,7 +819,7 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 	}
 
 	/* pass NULL if no arguments were supplied */
-	bret = lxcapi_start(c, useinit, *inargs ? inargs : NULL);
+	bret = do_lxcapi_start(c, useinit, *inargs ? inargs : NULL);
 
 out:
 	if (inargs) {
@@ -735,10 +829,11 @@ out:
 		free(inargs);
 	}
 
+	current_config = old;
 	return bret;
 }
 
-static bool lxcapi_stop(struct lxc_container *c)
+static bool do_lxcapi_stop(struct lxc_container *c)
 {
 	int ret;
 
@@ -750,6 +845,8 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
+WRAP_API(bool, lxcapi_stop)
+
 static int do_create_container_dir(const char *path, struct lxc_conf *conf)
 {
 	int ret = -1, lasterr;
@@ -797,9 +894,6 @@ static bool create_container_dir(struct lxc_container *c)
 	return ret == 0;
 }
 
-static const char *lxcapi_get_config_path(struct lxc_container *c);
-static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
-
 /*
  * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
  * it returns a mounted bdev on success, NULL on error.
@@ -819,7 +913,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s", rpath);
 	} else {
-		const char *lxcpath = lxcapi_get_config_path(c);
+		const char *lxcpath = do_lxcapi_get_config_path(c);
 		len = strlen(c->name) + strlen(lxcpath) + 9;
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
@@ -833,7 +927,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		return NULL;
 	}
 
-	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+	do_lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
 
 	/* if we are not root, chown the rootfs dir to root in the
 	 * target uidmap */
@@ -1210,9 +1304,8 @@ static void lxcapi_clear_config(struct lxc_container *c)
 	}
 }
 
-static bool lxcapi_destroy(struct lxc_container *c);
-static bool container_destroy(struct lxc_container *c);
-static bool get_snappath_dir(struct lxc_container *c, char *snappath);
+#define do_lxcapi_clear_config(c) lxcapi_clear_config(c)
+
 /*
  * lxcapi_create:
  * create a container with the given parameters.
@@ -1227,7 +1320,7 @@ static bool get_snappath_dir(struct lxc_container *c, char *snappath);
  * @argv: the arguments to pass to the template, terminated by NULL.  If no
  * arguments, you can just pass NULL.
  */
-static bool lxcapi_create(struct lxc_container *c, const char *t,
+static bool do_lxcapi_create(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags,
 		char *const argv[])
 {
@@ -1253,14 +1346,14 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	 * an existing container.  Return an error, but do NOT delete the
 	 * container.
 	 */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
+	if (do_lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
 			access(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {
 		ERROR("Container %s:%s already exists", c->config_path, c->name);
 		goto free_tpath;
 	}
 
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s", lxc_global_config_value("lxc.default_config"));
 			goto free_tpath;
 		}
@@ -1280,7 +1373,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
 		/* rootfs passed into configuration, but does not exist: error */
 		goto out;
-	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
+	if (do_lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
 		/* Rootfs already existed, user just wanted to save the
 		 * loaded configuration */
 		ret = true;
@@ -1316,7 +1409,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		}
 
 		/* save config file again to store the new rootfs location */
-		if (!c->save_config(c, NULL)) {
+		if (!do_lxcapi_save_config(c, NULL)) {
 			ERROR("failed to save starting configuration for %s", c->name);
 			// parent task won't see bdev in config so we delete it
 			bdev->ops->umount(bdev);
@@ -1339,7 +1432,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 	// now clear out the lxc_conf we have, reload from the created
 	// container
-	lxcapi_clear_config(c);
+	do_lxcapi_clear_config(c);
 
 	if (t) {
 		if (!prepend_lxc_header(c->configfile, tpath, argv)) {
@@ -1360,16 +1453,28 @@ free_tpath:
 	return ret;
 }
 
-static bool lxcapi_reboot(struct lxc_container *c)
+static bool lxcapi_create(struct lxc_container *c, const char *t,
+		const char *bdevtype, struct bdev_specs *specs, int flags,
+		char *const argv[])
+{
+	bool ret;
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_create(c, t, bdevtype, specs, flags, argv);
+	current_config = old;
+	return ret;
+}
+
+static bool do_lxcapi_reboot(struct lxc_container *c)
 {
 	pid_t pid;
 	int rebootsignal = SIGINT;
 
 	if (!c)
 		return false;
-	if (!c->is_running(c))
+	if (!do_lxcapi_is_running(c))
 		return false;
-	pid = c->init_pid(c);
+	pid = do_lxcapi_init_pid(c);
 	if (pid <= 0)
 		return false;
 	if (c->lxc_conf && c->lxc_conf->rebootsignal)
@@ -1380,7 +1485,9 @@ static bool lxcapi_reboot(struct lxc_container *c)
 
 }
 
-static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
+WRAP_API(bool, lxcapi_reboot)
+
+static bool do_lxcapi_shutdown(struct lxc_container *c, int timeout)
 {
 	bool retv;
 	pid_t pid;
@@ -1389,18 +1496,20 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	if (!c)
 		return false;
 
-	if (!c->is_running(c))
+	if (!do_lxcapi_is_running(c))
 		return true;
-	pid = c->init_pid(c);
+	pid = do_lxcapi_init_pid(c);
 	if (pid <= 0)
 		return true;
 	if (c->lxc_conf && c->lxc_conf->haltsignal)
 		haltsignal = c->lxc_conf->haltsignal;
 	kill(pid, haltsignal);
-	retv = c->wait(c, "STOPPED", timeout);
+	retv = do_lxcapi_wait(c, "STOPPED", timeout);
 	return retv;
 }
 
+WRAP_API_1(bool, lxcapi_shutdown, int)
+
 static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags, ...)
 {
@@ -1411,6 +1520,9 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	if (!c)
 		return false;
 
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+
 	/*
 	 * since we're going to wait for create to finish, I don't think we
 	 * need to get a copy of the arguments.
@@ -1423,10 +1535,11 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		goto out;
 	}
 
-	bret = c->create(c, t, bdevtype, specs, flags, args);
+	bret = do_lxcapi_create(c, t, bdevtype, specs, flags, args);
 
 out:
 	free(args);
+	current_config = old;
 	return bret;
 }
 
@@ -1444,7 +1557,7 @@ static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)
 		WARN("Error clearing configuration for %s", key);
 }
 
-static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
+static bool do_lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 {
 	int ret;
 
@@ -1459,9 +1572,11 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
+WRAP_API_1(bool, lxcapi_clear_config_item, const char *)
+
 static inline bool enter_net_ns(struct lxc_container *c)
 {
-	pid_t pid = c->init_pid(c);
+	pid_t pid = do_lxcapi_init_pid(c);
 
 	if ((geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) && access("/proc/self/ns/user", F_OK) == 0) {
 		if (!switch_to_ns(pid, "user"))
@@ -1541,7 +1656,7 @@ static bool remove_from_array(char ***names, char *cname, int size)
 	return false;
 }
 
-static char** lxcapi_get_interfaces(struct lxc_container *c)
+static char ** do_lxcapi_get_interfaces(struct lxc_container *c)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1628,7 +1743,9 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 	return interfaces;
 }
 
-static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
+WRAP_API(char **, lxcapi_get_interfaces)
+
+static char** do_lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
 {
 	pid_t pid;
 	int i, count = 0, pipefd[2];
@@ -1745,7 +1862,9 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 	return addresses;
 }
 
-static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
+WRAP_API_3(char **, lxcapi_get_ips, const char *, const char *, int)
+
+static int do_lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	int ret;
 
@@ -1758,7 +1877,9 @@ static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char
 	return ret;
 }
 
-static char* lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
+WRAP_API_3(int, lxcapi_get_config_item, const char *, char *, int)
+
+static char* do_lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
 {
 	char *ret;
 
@@ -1766,12 +1887,14 @@ static char* lxcapi_get_running_config_item(struct lxc_container *c, const char
 		return NULL;
 	if (container_mem_lock(c))
 		return NULL;
-	ret = lxc_cmd_get_config_item(c->name, key, c->get_config_path(c));
+	ret = lxc_cmd_get_config_item(c->name, key, do_lxcapi_get_config_path(c));
 	container_mem_unlock(c);
 	return ret;
 }
 
-static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
+WRAP_API_1(char *, lxcapi_get_running_config_item, const char *)
+
+static int do_lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	if (!key)
 		return lxc_listconfigs(retv, inlen);
@@ -1791,7 +1914,9 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 	return ret;
 }
 
-static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
+WRAP_API_3(int, lxcapi_get_keys, const char *, char *, int)
+
+static bool do_lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	FILE *fout;
 	bool ret = false, need_disklock = false;
@@ -1804,7 +1929,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+		if (!do_lxcapi_load_config(c, lxc_global_config_value("lxc.default_config"))) {
 			ERROR("Error loading default configuration file %s while saving %s", lxc_global_config_value("lxc.default_config"), c->name);
 			return false;
 		}
@@ -1844,6 +1969,8 @@ out:
 	return ret;
 }
 
+WRAP_API_1(bool, lxcapi_save_config, const char *)
+
 static bool mod_rdep(struct lxc_container *c, bool inc)
 {
 	char path[MAXPATHLEN];
@@ -2032,7 +2159,7 @@ static bool container_destroy(struct lxc_container *c)
 	bool bret = false;
 	int ret;
 
-	if (!c || !lxcapi_is_defined(c))
+	if (!c || !do_lxcapi_is_defined(c))
 		return false;
 
 	if (container_disk_lock(c))
@@ -2057,7 +2184,7 @@ static bool container_destroy(struct lxc_container *c)
 
 	mod_all_rdeps(c, false);
 
-	const char *p1 = lxcapi_get_config_path(c);
+	const char *p1 = do_lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
 	if (am_unpriv())
@@ -2075,7 +2202,7 @@ out:
 	return bret;
 }
 
-static bool lxcapi_destroy(struct lxc_container *c)
+static bool do_lxcapi_destroy(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2092,9 +2219,9 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	return container_destroy(c);
 }
 
-static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
+WRAP_API(bool, lxcapi_destroy)
 
-static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
+static bool do_lxcapi_destroy_with_snapshots(struct lxc_container *c)
 {
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -2105,6 +2232,8 @@ static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
 	return lxcapi_destroy(c);
 }
 
+WRAP_API(bool, lxcapi_destroy_with_snapshots)
+
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
 {
 	struct lxc_config_t *config;
@@ -2121,7 +2250,7 @@ static bool set_config_item_locked(struct lxc_container *c, const char *key, con
 	return do_append_unexp_config_line(c->lxc_conf, key, v);
 }
 
-static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
+static bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
 {
 	bool b = false;
 
@@ -2137,6 +2266,8 @@ static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, con
 	return b;
 }
 
+WRAP_API_2(bool, lxcapi_set_config_item, const char *, const char *)
+
 static char *lxcapi_config_file_name(struct lxc_container *c)
 {
 	if (!c || !c->configfile)
@@ -2184,7 +2315,7 @@ static bool set_config_filename(struct lxc_container *c)
 	return true;
 }
 
-static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
+static bool do_lxcapi_set_config_path(struct lxc_container *c, const char *path)
 {
 	char *p;
 	bool b = false;
@@ -2222,8 +2353,9 @@ err:
 	return b;
 }
 
+WRAP_API_1(bool, lxcapi_set_config_path, const char *)
 
-static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
+static bool do_lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
 {
 	int ret;
 
@@ -2242,7 +2374,9 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	return ret == 0;
 }
 
-static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
+WRAP_API_2(bool, lxcapi_set_cgroup_item, const char *, const char *)
+
+static int do_lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
 {
 	int ret;
 
@@ -2261,6 +2395,8 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	return ret;
 }
 
+WRAP_API_3(int, lxcapi_get_cgroup_item, const char *, char *, int)
+
 const char *lxc_get_global_config_item(const char *key)
 {
 	return lxc_global_config_value(key);
@@ -2377,7 +2513,7 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 		ERROR("Error saving new hooks in clone");
 		return -1;
 	}
-	c->save_config(c, NULL);
+	do_lxcapi_save_config(c, NULL);
 	return 0;
 }
 
@@ -2649,7 +2785,7 @@ static int create_file_dirname(char *path, struct lxc_conf *conf)
 	return ret;
 }
 
-static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+static struct lxc_container *do_lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, uint64_t newsize,
 		char **hookargs)
@@ -2662,7 +2798,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	FILE *fout;
 	pid_t pid;
 
-	if (!c || !c->is_defined(c))
+	if (!c || !do_lxcapi_is_defined(c))
 		return NULL;
 
 	if (container_mem_lock(c))
@@ -2677,7 +2813,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (!newname)
 		newname = c->name;
 	if (!lxcpath)
-		lxcpath = c->get_config_path(c);
+		lxcpath = do_lxcapi_get_config_path(c);
 	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", lxcpath, newname);
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		SYSERROR("clone: failed making config pathname");
@@ -2806,7 +2942,20 @@ out:
 	return NULL;
 }
 
-static bool lxcapi_rename(struct lxc_container *c, const char *newname)
+static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+		const char *lxcpath, int flags,
+		const char *bdevtype, const char *bdevdata, uint64_t newsize,
+		char **hookargs)
+{
+	struct lxc_container * ret;
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_clone(c, newname, lxcpath, flags, bdevtype, bdevdata, newsize, hookargs);
+	current_config = old;
+	return ret;
+}
+
+static bool do_lxcapi_rename(struct lxc_container *c, const char *newname)
 {
 	struct bdev *bdev;
 	struct lxc_container *newc;
@@ -2841,15 +2990,24 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	return true;
 }
 
+WRAP_API_1(bool, lxcapi_rename, const char *)
+
 static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process)
 {
+	struct lxc_conf *old = current_config;
+	int ret;
+
 	if (!c)
 		return -1;
 
-	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
+	current_config = c->lxc_conf;
+
+	ret = lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
+	current_config = old;
+	return ret;
 }
 
-static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+static int do_lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
 {
 	lxc_attach_command_t command;
 	pid_t pid;
@@ -2868,6 +3026,16 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	return lxc_wait_for_pid_status(pid);
 }
 
+static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+{
+	int ret;
+	struct lxc_conf *old = current_config;
+	current_config = c ? c->lxc_conf : NULL;
+	ret = do_lxcapi_attach_run_wait(c, options, program, argv);
+	current_config = old;
+	return ret;
+}
+
 static int get_next_index(const char *lxcpath, char *cname)
 {
 	char *fname;
@@ -2911,7 +3079,7 @@ static bool get_snappath_dir(struct lxc_container *c, char *snappath)
 	return true;
 }
 
-static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
+static int do_lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
@@ -2953,7 +3121,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 		ERROR("and keep the original container pristine.");
 		flags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
 	}
-	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
+	c2 = do_lxcapi_clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
 		ERROR("clone of %s:%s failed", c->config_path, c->name);
 		return -1;
@@ -3001,6 +3169,8 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	return i;
 }
 
+WRAP_API_1(int, lxcapi_snapshot, const char *)
+
 static void lxcsnap_free(struct lxc_snapshot *s)
 {
 	free(s->name);
@@ -3055,7 +3225,7 @@ static char *get_timestamp(char* snappath, char *name)
 	return s;
 }
 
-static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
+static int do_lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
 	int count = 0, ret;
@@ -3131,7 +3301,9 @@ out_free:
 	return -1;
 }
 
-static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
+WRAP_API_1(int, lxcapi_snapshot_list, struct lxc_snapshot **)
+
+static bool do_lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
 	int flags = 0;
@@ -3192,6 +3364,8 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	return b;
 }
 
+WRAP_API_2(bool, lxcapi_snapshot_restore, const char *, const char *)
+
 static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 {
 	struct lxc_container *snap = NULL;
@@ -3203,7 +3377,7 @@ static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 		goto err;
 	}
 
-	if (!lxcapi_destroy(snap)) {
+	if (!do_lxcapi_destroy(snap)) {
 		ERROR("Could not destroy snapshot %s", snapname);
 		goto err;
 	}
@@ -3247,7 +3421,7 @@ static bool remove_all_snapshots(const char *path)
 	return bret;
 }
 
-static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
+static bool do_lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3260,7 +3434,9 @@ static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapnam
 	return do_snapshot_destroy(snapname, clonelxcpath);
 }
 
-static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
+WRAP_API_1(bool, lxcapi_snapshot_destroy, const char *)
+
+static bool do_lxcapi_snapshot_destroy_all(struct lxc_container *c)
 {
 	char clonelxcpath[MAXPATHLEN];
 
@@ -3273,11 +3449,15 @@ static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
 	return remove_all_snapshots(clonelxcpath);
 }
 
-static bool lxcapi_may_control(struct lxc_container *c)
+WRAP_API(bool, lxcapi_snapshot_destroy_all)
+
+static bool do_lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
+WRAP_API(bool, lxcapi_may_control)
+
 static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,
 		struct stat *st)
 {
@@ -3341,7 +3521,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	const char *p;
 
 	/* make sure container is running */
-	if (!c->is_running(c)) {
+	if (!do_lxcapi_is_running(c)) {
 		ERROR("container is not running");
 		return false;
 	}
@@ -3365,17 +3545,17 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	if (ret < 0 || ret >= MAX_BUFFER)
 		return false;
 
-	if (!do_add_remove_node(c->init_pid(c), p, add, &st))
+	if (!do_add_remove_node(do_lxcapi_init_pid(c), p, add, &st))
 		return false;
 
 	/* add or remove device to/from cgroup access list */
 	if (add) {
-		if (!c->set_cgroup_item(c, "devices.allow", value)) {
+		if (!do_lxcapi_set_cgroup_item(c, "devices.allow", value)) {
 			ERROR("set_cgroup_item failed while adding the device node");
 			return false;
 		}
 	} else {
-		if (!c->set_cgroup_item(c, "devices.deny", value)) {
+		if (!do_lxcapi_set_cgroup_item(c, "devices.deny", value)) {
 			ERROR("set_cgroup_item failed while removing the device node");
 			return false;
 		}
@@ -3384,7 +3564,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	return true;
 }
 
-static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+static bool do_lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3393,7 +3573,9 @@ static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path
 	return add_remove_device_node(c, src_path, dest_path, true);
 }
 
-static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
+WRAP_API_2(bool, lxcapi_add_device_node, const char *, const char *)
+
+static bool do_lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	if (am_unpriv()) {
 		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
@@ -3402,7 +3584,9 @@ static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_p
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
-static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
+WRAP_API_2(bool, lxcapi_remove_device_node, const char *, const char *)
+
+static bool do_lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 				const char *dst_ifname)
 {
 	int ret = 0;
@@ -3425,7 +3609,7 @@ static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 			goto err;
 	}
 
-	ret = lxc_netdev_move_by_name(ifname, c->init_pid(c), dst_ifname);
+	ret = lxc_netdev_move_by_name(ifname, do_lxcapi_init_pid(c), dst_ifname);
 	if (ret)
 		goto err;
 
@@ -3435,7 +3619,9 @@ err:
 	return false;
 }
 
-static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
+WRAP_API_2(bool, lxcapi_attach_interface, const char *, const char *)
+
+static bool do_lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 					const char *dst_ifname)
 {
 	pid_t pid, pid_outside;
@@ -3490,6 +3676,8 @@ static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 	return true;
 }
 
+WRAP_API_2(bool, lxcapi_detach_interface, const char *, const char *)
+
 struct criu_opts {
 	/* The type of criu invocation, one of "dump" or "restore" */
 	char *action;
@@ -3781,7 +3969,7 @@ out:
 	return true;
 }
 
-static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+static bool do_lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
 {
 	pid_t pid;
 	int status;
@@ -3826,6 +4014,8 @@ static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool sto
 	}
 }
 
+WRAP_API_3(bool, lxcapi_checkpoint, char *, bool, bool)
+
 static bool restore_net_info(struct lxc_container *c)
 {
 	struct lxc_list *it;
@@ -3853,7 +4043,7 @@ out_unlock:
 	return !has_error;
 }
 
-static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+static bool do_lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
 	pid_t pid;
 	struct lxc_rootfs *rootfs;
@@ -3982,6 +4172,8 @@ out_fini_handler:
 	return !has_error;
 }
 
+WRAP_API_2(bool, lxcapi_restore, char *, bool)
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -3991,18 +4183,24 @@ static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
+	struct lxc_conf *old = current_config;
+	current_config = c->lxc_conf;
+
 	va_start(ap, arg);
 	argv = lxc_va_arg_list_to_argv_const(ap, 1);
 	va_end(ap);
 
 	if (!argv) {
 		ERROR("Memory allocation error.");
-		return -1;
+		ret = -1;
+		goto out;
 	}
 	argv[0] = arg;
 
-	ret = lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
+	ret = do_lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
 	free((void*)argv);
+out:
+	current_config = old;
 	return ret;
 }
 
@@ -4119,12 +4317,6 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 
-	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {
-		fprintf(stderr, "failed to open log\n");
-		goto err;
-	}
-
 	return c;
 
 err:
@@ -4198,7 +4390,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 					goto free_bad;
 			continue;
 		}
-		if (!lxcapi_is_defined(c)) {
+		if (!do_lxcapi_is_defined(c)) {
 			INFO("Container %s:%s has a config but is not defined",
 				lxcpath, direntp->d_name);
 			if (names)

commit dd267776ee265737520c2c661a51c2d29cf43cb0
Author: Bogdan Purcareata <bogdan.purcareata@freescale.com>
Date:   Mon Feb 16 09:38:34 2015 +0000

    add lxc.rebootsignal
    
    Following the model of f0f1d8c076ae93d8ecf735c2eeae471e27ca6abd, add a reboot
    signal for special init processes that work on something other than SIGINT.
    
    Signed-off-by: Bogdan Purcareata <bogdan.purcareata@freescale.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e02ee93..4422f4a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1363,6 +1363,7 @@ free_tpath:
 static bool lxcapi_reboot(struct lxc_container *c)
 {
 	pid_t pid;
+	int rebootsignal = SIGINT;
 
 	if (!c)
 		return false;
@@ -1371,7 +1372,9 @@ static bool lxcapi_reboot(struct lxc_container *c)
 	pid = c->init_pid(c);
 	if (pid <= 0)
 		return false;
-	if (kill(pid, SIGINT) < 0)
+	if (c->lxc_conf && c->lxc_conf->rebootsignal)
+		rebootsignal = c->lxc_conf->rebootsignal;
+	if (kill(pid, rebootsignal) < 0)
 		return false;
 	return true;
 

commit 0a4be28d8cf24b529211ebc529136835645d76dd
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Jan 30 14:59:13 2015 +0100

    set the monitor process title to something useful
    
    Instead of having a parent process that's called whatever the caller of the
    library is called, we instead set it to "[lxc monitor] <lxcpath> <container>"
    
    Closes #180
    
    v2: check for null in tok for loop, only truncate environment when necessary
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4da1627..e02ee93 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -598,6 +598,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	* while container is running...
 	*/
 	if (daemonize) {
+		char title[2048];
 		lxc_monitord_spawn(c->config_path);
 
 		pid_t pid = fork();
@@ -612,6 +613,14 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			return wait_on_daemonized_start(c, pid);
 		}
 
+		/* We don't really care if this doesn't print all the
+		 * characters; all that it means is that the proctitle will be
+		 * ugly. Similarly, we also don't care if setproctitle()
+		 * fails. */
+		snprintf(title, sizeof(title), "[lxc monitor] %s %s", c->config_path, c->name);
+		INFO("Attempting to set proc title to %s", title);
+		setproctitle(title);
+
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {

commit 6010a416227149adabc5aa8e018e2333adb2a922
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Jan 28 09:28:22 2015 +0100

    Fix lxc-create -h with absolute template path
    
    Close #421
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2b3e28c..4da1627 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -841,40 +841,6 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	return bdev;
 }
 
-/*
- * Given the '-t' template option to lxc-create, figure out what to
- * do.  If the template is a full executable path, use that.  If it
- * is something like 'sshd', then return $templatepath/lxc-sshd.
- * On success return the template, on error return NULL.
- */
-static char *get_template_path(const char *t)
-{
-	int ret, len;
-	char *tpath;
-
-	if (t[0] == '/' && access(t, X_OK) == 0) {
-		tpath = strdup(t);
-		return tpath;
-	}
-
-	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
-	tpath = malloc(len);
-	if (!tpath)
-		return NULL;
-	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
-	if (ret < 0 || ret >= len) {
-		free(tpath);
-		return NULL;
-	}
-	if (access(tpath, X_OK) < 0) {
-		SYSERROR("bad template: %s", t);
-		free(tpath);
-		return NULL;
-	}
-
-	return tpath;
-}
-
 static char *lxcbasename(char *path)
 {
 	char *p = path + strlen(path) - 1;

commit 46cd28455f8eedabcccf8fc1955b7199a7467807
Author: Patrick O'Leary <patrick.oleary@gmail.com>
Date:   Tue Dec 16 19:47:21 2014 -0600

    replace deprecated `index` with `strchr`
    
    The `index` libc function was removed in POSIX 2008, and `strchr` is a direct
    replacement. The bionic (Android) libc has removed `index` when you are
    compiling for a 64-bit architecture, such as AArch64.
    
    Signed-off-by: Patrick O'Leary <patrick.oleary@gmail.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c7c4cf8..2b3e28c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4303,7 +4303,7 @@ int list_active_containers(const char *lxcpath, char ***nret,
 			p++;
 
 		// Now p is the start of lxc_name
-		p2 = index(p, '/');
+		p2 = strchr(p, '/');
 		if (!p2 || strncmp(p2, "/command", 8) != 0)
 			continue;
 		*p2 = '\0';

commit c55d4505e354c203473f1532f785842ea16a16a6
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 24 20:38:49 2015 +0100

    Bug #158: Deletion of unnecessary checks before a few calls of LXC functions
    
    The following functions return immediately if a null pointer was passed.
    * container_destroy
    * lxc_cgroup_process_info_free_and_remove
    * lxc_cgroup_put_meta
    * toss_list
    
    It is therefore not needed that a function caller repeats a corresponding check.
    
    This issue was fixed by using the software Coccinelle 1.0.0-rc23.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ee73b64..c7c4cf8 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1378,7 +1378,7 @@ out_unlock:
 	if (partial_fd >= 0)
 		remove_partial(c, partial_fd);
 out:
-	if (!ret && c)
+	if (!ret)
 		container_destroy(c);
 free_tpath:
 	free(tpath);

commit f10fad2f53e3f4f2f862bacf218a5aa7feceb505
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 24 19:55:36 2015 +0100

    Bug #158: Deletion of unnecessary checks before calls of the function "free"
    
    The function "free" is documented in the way that no action shall occur for
    a passed null pointer. It is therefore not needed that a function caller
    repeats a corresponding check.
    http://stackoverflow.com/questions/18775608/free-a-null-pointer-anyway-or-check-first
    
    This issue was fixed by using the software Coccinelle 1.0.0-rc23.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7ed8717..ee73b64 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -217,14 +217,10 @@ static void lxc_container_free(struct lxc_container *c)
 	if (!c)
 		return;
 
-	if (c->configfile) {
-		free(c->configfile);
-		c->configfile = NULL;
-	}
-	if (c->error_string) {
-		free(c->error_string);
-		c->error_string = NULL;
-	}
+	free(c->configfile);
+	c->configfile = NULL;
+	free(c->error_string);
+	c->error_string = NULL;
 	if (c->slock) {
 		lxc_putlock(c->slock);
 		c->slock = NULL;
@@ -233,18 +229,14 @@ static void lxc_container_free(struct lxc_container *c)
 		lxc_putlock(c->privlock);
 		c->privlock = NULL;
 	}
-	if (c->name) {
-		free(c->name);
-		c->name = NULL;
-	}
+	free(c->name);
+	c->name = NULL;
 	if (c->lxc_conf) {
 		lxc_conf_free(c->lxc_conf);
 		c->lxc_conf = NULL;
 	}
-	if (c->config_path) {
-		free(c->config_path);
-		c->config_path = NULL;
-	}
+	free(c->config_path);
+	c->config_path = NULL;
 
 	free(c);
 }
@@ -961,8 +953,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 				exit(1);
 			}
 		} else { // TODO come up with a better way here!
-			if (bdev->dest)
-				free(bdev->dest);
+			free(bdev->dest);
 			bdev->dest = strdup(bdev->src);
 		}
 
@@ -1390,8 +1381,7 @@ out:
 	if (!ret && c)
 		container_destroy(c);
 free_tpath:
-	if (tpath)
-		free(tpath);
+	free(tpath);
 	return ret;
 }
 
@@ -1964,8 +1954,8 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 		lxc_container_put(p);
 	}
 out:
-	if (lxcpath) free(lxcpath);
-	if (lxcname) free(lxcname);
+	free(lxcpath);
+	free(lxcname);
 	fclose(f);
 }
 
@@ -2210,8 +2200,7 @@ static bool set_config_filename(struct lxc_container *c)
 		return false;
 	}
 
-	if (c->configfile)
-		free(c->configfile);
+	free(c->configfile);
 	c->configfile = newpath;
 
 	return true;
@@ -2250,8 +2239,7 @@ static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 		oldpath = NULL;
 	}
 err:
-	if (oldpath)
-		free(oldpath);
+	free(oldpath);
 	container_mem_unlock(c);
 	return b;
 }
@@ -2598,8 +2586,7 @@ static int clone_update_rootfs(struct clone_update_data *data)
 			return -1;
 		}
 	} else { // TODO come up with a better way
-		if (bdev->dest)
-			free(bdev->dest);
+		free(bdev->dest);
 		bdev->dest = strdup(bdev->src);
 	}
 
@@ -3038,14 +3025,10 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 
 static void lxcsnap_free(struct lxc_snapshot *s)
 {
-	if (s->name)
-		free(s->name);
-	if (s->comment_pathname)
-		free(s->comment_pathname);
-	if (s->timestamp)
-		free(s->timestamp);
-	if (s->lxcpath)
-		free(s->lxcpath);
+	free(s->name);
+	free(s->comment_pathname);
+	free(s->timestamp);
+	free(s->lxcpath);
 }
 
 static char *get_snapcomment_path(char* snappath, char *name)
@@ -3811,10 +3794,8 @@ static bool dump_net_info(struct lxc_container *c, char *directory)
 
 		has_error = false;
 out:
-		if (veth)
-			free(veth);
-		if (bridge)
-			free(bridge);
+		free(veth);
+		free(bridge);
 		if (has_error)
 			return false;
 	}
@@ -4388,8 +4369,7 @@ free_ct_name:
 	}
 
 out:
-	if (line)
-		free(line);
+	free(line);
 
 	fclose(f);
 	return ret;
@@ -4461,16 +4441,13 @@ free_ct_list:
 	for (i = 0; i < ct_list_cnt; i++) {
 		lxc_container_put(ct_list[i]);
 	}
-	if (ct_list)
-		free(ct_list);
+	free(ct_list);
 
 free_active_name:
 	for (i = 0; i < active_cnt; i++) {
-		if (active_name[i])
-			free(active_name[i]);
+		free(active_name[i]);
 	}
-	if (active_name)
-		free(active_name);
+	free(active_name);
 
 free_ct_name:
 	for (i = 0; i < ct_cnt; i++) {

commit d2cf4c378588cc1d497fe8b2ba3f835d6b03fe38
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jan 13 06:02:26 2015 +0000

    close-all-fds: fix behavior
    
    We want to close all inherited fds in three cases - one, if a container
    is daemonized.  Two, if the user specifies -C on the lxc-start command
    line.  Three, in src/lxc/monitor.c.  The presence of -C is passed in the
    lxc_conf may not always exist.
    
    One call to lxc_check_inherited was being done from lxc_start(), which
    doesn't know whether we are daemonized.  Move that call to its caller,
    lxcapi_start(), which does know.
    
    Pass an explicit closeall boolean as second argument to lxc_check_inherited.
    If it is true, then all fds are closed.  If it is false, then we check
    the lxc_conf->close_all_fds.
    
    With this, all tests pass, and the logic appears correct.
    
    Note that when -C is not true, then we only warn about inherited fds,
    but we do not abort the container start.  This appears to have ben the case
    since commit 92c7f6295518 in 2011.  Unfortunately the referenced URL with
    the justification is no longer valid.  We may want to consider becoming
    stricter about this again.  (Note that the commit did say "for now")
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0d36687..7ed8717 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -606,7 +606,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	* while container is running...
 	*/
 	if (daemonize) {
-		conf->close_all_fds = 1;
 		lxc_monitord_spawn(c->config_path);
 
 		pid_t pid = fork();
@@ -634,7 +633,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			SYSERROR("Error chdir()ing to /.");
 			return false;
 		}
-		lxc_check_inherited(conf, -1);
+		lxc_check_inherited(conf, true, -1);
 		close(0);
 		close(1);
 		close(2);
@@ -673,6 +672,13 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 
 reboot:
 	conf->reboot = 0;
+
+	if (lxc_check_inherited(conf, daemonize, -1)) {
+		ERROR("Inherited fds found");
+		ret = 1;
+		goto out;
+	}
+
 	ret = lxc_start(c->name, argv, conf, c->config_path);
 	c->error_num = ret;
 
@@ -682,6 +688,7 @@ reboot:
 		goto reboot;
 	}
 
+out:
 	if (c->pidfile) {
 		unlink(c->pidfile);
 		free(c->pidfile);

commit db2930e17441d39caaa61b52ecf4116504107a26
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jan 12 23:07:28 2015 -0600

    decide whether daemonize implies close_all_fds at start
    
    This isn't the perfect fix.  In fact close_all_fds shouldn't be stored
    in the lxc_conf.  But this will fix the tests short-term.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 406cead..0d36687 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -466,9 +466,6 @@ static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 		return false;
 	}
 	c->daemonize = state;
-	/* daemonize implies close_all_fds so set it */
-	if (state == 1)
-		c->lxc_conf->close_all_fds = 1;
 	container_mem_unlock(c);
 	return true;
 }
@@ -609,6 +606,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	* while container is running...
 	*/
 	if (daemonize) {
+		conf->close_all_fds = 1;
 		lxc_monitord_spawn(c->config_path);
 
 		pid_t pid = fork();

commit a2739df5e4da120daa7443f4de882a1a054b5316
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jan 12 23:06:01 2015 -0600

    Revert "set close-all-fds by default"
    
    it has unfortunate reprecussions elsewhere, and the needed fix
    can be done another way
    
    This reverts commit 1f76453a74f555e30384591567d87b5b4dac7e21.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5bb6152..406cead 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -457,14 +457,6 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
-static void do_set_daemonize(struct lxc_container *c, bool state)
-{
-	c->daemonize = state;
-	/* daemonize implies close_all_fds so set it */
-	if (state)
-		c->lxc_conf->close_all_fds = 1;
-}
-
 static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
@@ -473,7 +465,10 @@ static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 		ERROR("Error getting mem lock");
 		return false;
 	}
-	do_set_daemonize(c, state);
+	c->daemonize = state;
+	/* daemonize implies close_all_fds so set it */
+	if (state == 1)
+		c->lxc_conf->close_all_fds = 1;
 	container_mem_unlock(c);
 	return true;
 }
@@ -4103,9 +4098,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		container_destroy(c);
 		lxcapi_clear_config(c);
 	}
-	if (!c->lxc_conf)
-		c->lxc_conf = lxc_conf_init();
-	do_set_daemonize(c, true);
+	c->daemonize = true;
 	c->pidfile = NULL;
 
 	// assign the member functions

commit 1f76453a74f555e30384591567d87b5b4dac7e21
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jan 9 16:33:42 2015 +0000

    set close-all-fds by default
    
    When containers request to be daemonized, close-all-fd is
    set to true.  But when we switched ot daemonize-by-default we didn't
    set close-all-fd by default.
    
    Fix that.  In order to do that we have to always have a lxc_conf
    object.  As a consequence, after this patch we can drop a bunch
    of checks for c->lxc_conf existing.  We should consider removing
    those.  This patch does not do that.
    
    This should close https://github.com/lxc/lxc/issues/354
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 406cead..5bb6152 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -457,6 +457,14 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
+static void do_set_daemonize(struct lxc_container *c, bool state)
+{
+	c->daemonize = state;
+	/* daemonize implies close_all_fds so set it */
+	if (state)
+		c->lxc_conf->close_all_fds = 1;
+}
+
 static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
@@ -465,10 +473,7 @@ static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 		ERROR("Error getting mem lock");
 		return false;
 	}
-	c->daemonize = state;
-	/* daemonize implies close_all_fds so set it */
-	if (state == 1)
-		c->lxc_conf->close_all_fds = 1;
+	do_set_daemonize(c, state);
 	container_mem_unlock(c);
 	return true;
 }
@@ -4098,7 +4103,9 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		container_destroy(c);
 		lxcapi_clear_config(c);
 	}
-	c->daemonize = true;
+	if (!c->lxc_conf)
+		c->lxc_conf = lxc_conf_init();
+	do_set_daemonize(c, true);
 	c->pidfile = NULL;
 
 	// assign the member functions

commit 67c660d0aaff5f2854a55da936fe6cd82510494f
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Nov 26 14:33:27 2014 -0500

    Define a new lxc.init_cmd config option
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2372b19..406cead 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -555,6 +555,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		"/sbin/init",
 		NULL,
 	};
+	char *init_cmd[2];
 
 	/* container exists */
 	if (!c)
@@ -591,8 +592,15 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		return ret == 0 ? true : false;
 	}
 
-	if (!argv)
-		argv = default_args;
+	if (!argv) {
+		if (conf->init_cmd) {
+			init_cmd[0] = conf->init_cmd;
+			init_cmd[1] = NULL;
+			argv = init_cmd;
+		}
+		else
+			argv = default_args;
+	}
 
 	/*
 	* say, I'm not sure - what locks do we want here?  Any?

commit 0080bebf3195a4a4f4868d89224e07658a1fccca
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Oct 22 22:25:02 2014 +0000

    c/r: put lxc-restore-net in /usr/share
    
    On restore, we pass criu a script to manage the network interfaces (i.e. the
    full path to lxc-restore-net), which we previously installed into
    /var/lib/<tuple>/lxc. However, this is also the directory that is the default
    for use in mounting the rootfs locally before pivot_root()ing. So, we mounted
    the rootfs and then happliy called criu, pointing it to this directory which
    didn't have lxc-restore-net any more, it just had the container's rootfs.
    Instead, we should put lxc-restore-net somewhere else, so that criu can still
    see it after the rootfs is mounted.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d5ac378..2372b19 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3604,7 +3604,7 @@ static void exec_criu(struct criu_opts *opts)
 	DECLARE_ARG("--force-irmap");
 	DECLARE_ARG("--manage-cgroups");
 	DECLARE_ARG("--action-script");
-	DECLARE_ARG(LIBEXECDIR "/lxc/lxc-restore-net");
+	DECLARE_ARG(DATADIR "/lxc/lxc-restore-net");
 	DECLARE_ARG("-D");
 	DECLARE_ARG(opts->directory);
 	DECLARE_ARG("-o");

commit cc4ae28dd6f9e4d2f95f0aba5248f15e791430c4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Oct 17 16:43:48 2014 +0200

    fix typo (spurious ';')
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d3b6046..d5ac378 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3800,7 +3800,7 @@ static bool dump_net_info(struct lxc_container *c, char *directory)
 out:
 		if (veth)
 			free(veth);
-		if (bridge);
+		if (bridge)
 			free(bridge);
 		if (has_error)
 			return false;

commit e311a562356f18e960fef5a1b711673a85d240b4
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Oct 16 13:14:00 2014 +0000

    c/r: use sizeof instead of magic numbers
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d1f41c7..d3b6046 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3639,16 +3639,16 @@ static void exec_criu(struct criu_opts *opts)
 			struct lxc_netdev *n = it->elem;
 
 			if (n->name) {
-				if (strlen(n->name) >= 128)
+				if (strlen(n->name) >= sizeof(eth))
 					goto err;
-				strncpy(eth, n->name, 128);
+				strncpy(eth, n->name, sizeof(eth));
 			} else
 				sprintf(eth, "eth%d", netnr);
 
 			veth = n->priv.veth_attr.pair;
 
-			ret = snprintf(buf, 257, "%s=%s", eth, veth);
-			if (ret < 0 || ret >= 257)
+			ret = snprintf(buf, sizeof(buf), "%s=%s", eth, veth);
+			if (ret < 0 || ret >= sizeof(buf))
 				goto err;
 
 			/* final NULL and --veth-pair eth0=vethASDF */

commit fed29fad60a06389f10f91fe8c15c8ca0ff50aa1
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Thu Oct 16 13:13:59 2014 +0000

    c/r: refactor the way we pass data to criu/scripts
    
    We previously wrote a bunch of files (eth*, veth*, and bridge*) as hard coded
    files which we used as the names of interfaces to restore via criu's
    --veth-pair. This meant that if people, e.g. gave a different bridge on their
    new host, we would use our saved bridge in bridge* and try to restore to the
    wrong bridge. Instead, we can just generate a new veth id (if the user hasn't
    provided one), and use whatever the user configured values for the interface
    name and bridge are.
    
    This allows people to switch the bridge that they restore onto simply by
    migrating the rootfs and config, and then changing the bridge name in the
    container's configuration before running lxc-checkpoint.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c4cb0ab..d1f41c7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -55,6 +55,7 @@
 #include "attach.h"
 #include "monitor.h"
 #include "namespace.h"
+#include "network.h"
 #include "lxclock.h"
 #include "sync.h"
 
@@ -3536,37 +3537,12 @@ struct criu_opts {
 	const char *cgroup_path;
 };
 
-/*
- * @out must be 128 bytes long
- */
-static int read_criu_file(const char *directory, const char *file, int netnr, char *out)
-{
-	char path[PATH_MAX];
-	int ret;
-	FILE *f;
-
-	ret = snprintf(path, PATH_MAX,  "%s/%s%d", directory, file, netnr);
-	if (ret < 0 || ret >= PATH_MAX) {
-		ERROR("%s: path too long", __func__);
-		return -1;
-	}
-
-	f = fopen(path, "r");
-	if (!f)
-		return -1;
-
-	ret = fscanf(f, "%127s", out);
-	fclose(f);
-	if (ret <= 0)
-		return -1;
-
-	return 0;
-}
-
 static void exec_criu(struct criu_opts *opts)
 {
-	char **argv, log[PATH_MAX];
+	char **argv, log[PATH_MAX], buf[257];
 	int static_args = 14, argc = 0, i, ret;
+	int netnr = 0;
+	struct lxc_list *it;
 
 	/* The command line always looks like:
 	 * criu $(action) --tcp-established --file-locks --link-remap --force-irmap \
@@ -3648,9 +3624,6 @@ static void exec_criu(struct criu_opts *opts)
 		if (!opts->stop)
 			DECLARE_ARG("--leave-running");
 	} else if (strcmp(opts->action, "restore") == 0) {
-		int netnr = 0;
-		struct lxc_list *it;
-
 		DECLARE_ARG("--root");
 		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
 		DECLARE_ARG("--restore-detached");
@@ -3661,18 +3634,24 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG(opts->cgroup_path);
 
 		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
-			char eth[128], veth[128], buf[257];
+			char eth[128], *veth;
 			void *m;
+			struct lxc_netdev *n = it->elem;
+
+			if (n->name) {
+				if (strlen(n->name) >= 128)
+					goto err;
+				strncpy(eth, n->name, 128);
+			} else
+				sprintf(eth, "eth%d", netnr);
+
+			veth = n->priv.veth_attr.pair;
 
-			if (read_criu_file(opts->directory, "veth", netnr, veth))
-				goto err;
-			if (read_criu_file(opts->directory, "eth", netnr, eth))
-				goto err;
 			ret = snprintf(buf, 257, "%s=%s", eth, veth);
 			if (ret < 0 || ret >= 257)
 				goto err;
 
-			/* final NULL and --veth-pair eth0:vethASDF */
+			/* final NULL and --veth-pair eth0=vethASDF */
 			m = realloc(argv, (argc + 1 + 2) * sizeof(*argv));
 			if (!m)
 				goto err;
@@ -3682,12 +3661,43 @@ static void exec_criu(struct criu_opts *opts)
 			DECLARE_ARG(buf);
 			argv[argc] = NULL;
 
-			netnr++;
 		}
 	}
 
-#undef DECLARE_ARG
+	netnr = 0;
+	lxc_list_for_each(it, &opts->c->lxc_conf->network) {
+		struct lxc_netdev *n = it->elem;
+		char veth[128];
+
+		/*
+		 * Here, we set some parameters that lxc-restore-net
+		 * will examine to figure out the right network to
+		 * restore.
+		 */
+		snprintf(buf, sizeof(buf), "LXC_CRIU_BRIDGE%d", netnr);
+		if (setenv(buf, n->link, 1))
+			goto err;
+
+		if (strcmp("restore", opts->action) == 0)
+			strncpy(veth, n->priv.veth_attr.pair, sizeof(veth));
+		else {
+			char *tmp;
+			ret = snprintf(buf, sizeof(buf), "lxc.network.%d.veth.pair", netnr);
+			if (ret < 0 || ret >= sizeof(buf))
+				goto err;
+			tmp = lxcapi_get_running_config_item(opts->c, buf);
+			strncpy(veth, tmp, sizeof(veth));
+			free(tmp);
+		}
+
+		snprintf(buf, sizeof(buf), "LXC_CRIU_VETH%d", netnr);
+		if (setenv(buf, veth, 1))
+			goto err;
 
+		netnr++;
+	}
+
+#undef DECLARE_ARG
 	execv(argv[0], argv);
 err:
 	for (i = 0; argv[i]; i++)
@@ -3771,10 +3781,6 @@ static bool dump_net_info(struct lxc_container *c, char *directory)
 			break;
 		}
 
-		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.link", netnr);
-		if (pret < 0 || pret >= PATH_MAX)
-			goto out;
-
 		bridge = lxcapi_get_running_config_item(c, veth_path);
 		if (!bridge)
 			goto out;
@@ -3783,10 +3789,6 @@ static bool dump_net_info(struct lxc_container *c, char *directory)
 		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, veth) < 0)
 			goto out;
 
-		pret = snprintf(veth_path, PATH_MAX, "%s/bridge%d", directory, netnr);
-		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, bridge) < 0)
-			goto out;
-
 		if (n->name) {
 			if (strlen(n->name) >= 128)
 				goto out;
@@ -3794,10 +3796,6 @@ static bool dump_net_info(struct lxc_container *c, char *directory)
 		} else
 			sprintf(eth, "eth%d", netnr);
 
-		pret = snprintf(veth_path, PATH_MAX, "%s/eth%d", directory, netnr);
-		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, eth) < 0)
-			goto out;
-
 		has_error = false;
 out:
 		if (veth)
@@ -3856,30 +3854,24 @@ static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool sto
 	}
 }
 
-static bool restore_net_info(struct lxc_container *c, char *directory)
+static bool restore_net_info(struct lxc_container *c)
 {
 	struct lxc_list *it;
 	bool has_error = true;
-	int netnr = 0;
 
 	if (container_mem_lock(c))
 		return false;
 
 	lxc_list_for_each(it, &c->lxc_conf->network) {
-		char eth[128], veth[128];
 		struct lxc_netdev *netdev = it->elem;
+		char template[IFNAMSIZ];
+		snprintf(template, sizeof(template), "vethXXXXXX");
 
-		if (read_criu_file(directory, "veth", netnr, veth))
-			goto out_unlock;
-
-		if (read_criu_file(directory, "eth", netnr, eth))
-			goto out_unlock;
+		if (!netdev->priv.veth_attr.pair)
+			netdev->priv.veth_attr.pair = lxc_mkifname(template);
 
-		netdev->priv.veth_attr.pair = strdup(veth);
 		if (!netdev->priv.veth_attr.pair)
 			goto out_unlock;
-
-		netnr++;
 	}
 
 	has_error = false;
@@ -3922,6 +3914,11 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		goto out_fini_handler;
 	}
 
+	if (!restore_net_info(c)) {
+		ERROR("failed restoring network info");
+		goto out_fini_handler;
+	}
+
 	pid = fork();
 	if (pid < 0)
 		goto out_fini_handler;
@@ -3992,11 +3989,6 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 					goto out_fini_handler;
 				}
 
-				if (!restore_net_info(c, directory)) {
-					ERROR("failed restoring network info");
-					goto out_fini_handler;
-				}
-
 				if (lxc_set_state(c->name, handler, RUNNING))
 					goto out_fini_handler;
 			}

commit bbd4e13ea5c23480968bad1934a44db50d674d76
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Oct 10 14:55:37 2014 +0000

    c/r: factor out network dump/restore code
    
    Break the monolithic ->checkpoint and ->restore functions into smaller ones.
    This is in preparation for the checkpoint/restore tty work, which has a similar
    need to dump information outside of criu.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1f1f9ea..c4cb0ab 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3746,30 +3746,21 @@ static bool criu_ok(struct lxc_container *c)
 	return true;
 }
 
-static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+static bool dump_net_info(struct lxc_container *c, char *directory)
 {
-	int netnr, status;
+	int netnr;
 	struct lxc_list *it;
-	bool error = false;
-	pid_t pid;
-
-	if (!criu_ok(c))
-		return false;
-
-	if (mkdir(directory, 0700) < 0 && errno != EEXIST)
-		return false;
 
 	netnr = 0;
 	lxc_list_for_each(it, &c->lxc_conf->network) {
 		char *veth = NULL, *bridge = NULL, veth_path[PATH_MAX], eth[128];
 		struct lxc_netdev *n = it->elem;
+		bool has_error = true;
 		int pret;
 
 		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.veth.pair", netnr);
-		if (pret < 0 || pret >= PATH_MAX) {
-			error = true;
+		if (pret < 0 || pret >= PATH_MAX)
 			goto out;
-		}
 
 		veth = lxcapi_get_running_config_item(c, veth_path);
 		if (!veth) {
@@ -3781,49 +3772,59 @@ static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool sto
 		}
 
 		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.link", netnr);
-		if (pret < 0 || pret >= PATH_MAX) {
-			error = true;
+		if (pret < 0 || pret >= PATH_MAX)
 			goto out;
-		}
 
 		bridge = lxcapi_get_running_config_item(c, veth_path);
-		if (!bridge) {
-			error = true;
+		if (!bridge)
 			goto out;
-		}
 
 		pret = snprintf(veth_path, PATH_MAX, "%s/veth%d", directory, netnr);
-		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, veth) < 0) {
-			error = true;
+		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, veth) < 0)
 			goto out;
-		}
 
 		pret = snprintf(veth_path, PATH_MAX, "%s/bridge%d", directory, netnr);
-		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, bridge) < 0) {
-			error = true;
+		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, bridge) < 0)
 			goto out;
-		}
 
 		if (n->name) {
-			if (strlen(n->name) >= 128) {
-				error = true;
+			if (strlen(n->name) >= 128)
 				goto out;
-			}
 			strncpy(eth, n->name, 128);
 		} else
 			sprintf(eth, "eth%d", netnr);
 
 		pret = snprintf(veth_path, PATH_MAX, "%s/eth%d", directory, netnr);
 		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, eth) < 0)
-			error = true;
+			goto out;
 
+		has_error = false;
 out:
-		free(veth);
-		free(bridge);
-		if (error)
+		if (veth)
+			free(veth);
+		if (bridge);
+			free(bridge);
+		if (has_error)
 			return false;
 	}
 
+	return true;
+}
+
+static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+{
+	pid_t pid;
+	int status;
+
+	if (!criu_ok(c))
+		return false;
+
+	if (mkdir(directory, 0700) < 0 && errno != EEXIST)
+		return false;
+
+	if (!dump_net_info(c, directory))
+		return false;
+
 	pid = fork();
 	if (pid < 0)
 		return false;
@@ -3855,10 +3856,42 @@ out:
 	}
 }
 
+static bool restore_net_info(struct lxc_container *c, char *directory)
+{
+	struct lxc_list *it;
+	bool has_error = true;
+	int netnr = 0;
+
+	if (container_mem_lock(c))
+		return false;
+
+	lxc_list_for_each(it, &c->lxc_conf->network) {
+		char eth[128], veth[128];
+		struct lxc_netdev *netdev = it->elem;
+
+		if (read_criu_file(directory, "veth", netnr, veth))
+			goto out_unlock;
+
+		if (read_criu_file(directory, "eth", netnr, eth))
+			goto out_unlock;
+
+		netdev->priv.veth_attr.pair = strdup(veth);
+		if (!netdev->priv.veth_attr.pair)
+			goto out_unlock;
+
+		netnr++;
+	}
+
+	has_error = false;
+
+out_unlock:
+	container_mem_unlock(c);
+	return !has_error;
+}
+
 static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
 {
 	pid_t pid;
-	struct lxc_list *it;
 	struct lxc_rootfs *rootfs;
 	char pidfile[L_tmpnam];
 	struct lxc_handler *handler;
@@ -3944,7 +3977,7 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 				goto out_fini_handler;
 			}
 			else {
-				int netnr = 0, ret;
+				int ret;
 				FILE *f = fopen(pidfile, "r");
 				if (!f) {
 					perror("reading pidfile");
@@ -3959,34 +3992,11 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 					goto out_fini_handler;
 				}
 
-				if (container_mem_lock(c))
+				if (!restore_net_info(c, directory)) {
+					ERROR("failed restoring network info");
 					goto out_fini_handler;
-
-				lxc_list_for_each(it, &c->lxc_conf->network) {
-					char eth[128], veth[128];
-					struct lxc_netdev *netdev = it->elem;
-
-					if (read_criu_file(directory, "veth", netnr, veth)) {
-						container_mem_unlock(c);
-						goto out_fini_handler;
-					}
-
-					if (read_criu_file(directory, "eth", netnr, eth)) {
-						container_mem_unlock(c);
-						goto out_fini_handler;
-					}
-
-					netdev->priv.veth_attr.pair = strdup(veth);
-					if (!netdev->priv.veth_attr.pair) {
-						container_mem_unlock(c);
-						goto out_fini_handler;
-					}
-
-					netnr++;
 				}
 
-				container_mem_unlock(c);
-
 				if (lxc_set_state(c->name, handler, RUNNING))
 					goto out_fini_handler;
 			}

commit e5848d395cb4d1c09ec27457a63b56c1f1f88408
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 15 16:20:45 2014 +0200

    netdev_move_by_index: support wlan
    
    The python lxc-device supported adding wlan devices, so add that
    support as well.  Since the python one did not support 'del',
    I didn't try adding that support, though it should be trivial to
    add.
    
    We should be able to do the wlan adding using netlink, but I
    went ahead and used 'iw' as the netlink path looked more
    complicated than it does for other nics.  Patches to switch that
    over would be very welcome.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8cafdae..1f1f9ea 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3442,11 +3442,9 @@ static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 	}
 
 	ret = lxc_netdev_isup(ifname);
-	if (ret < 0)
-		goto err;
 
-	/* netdev of ifname is up. */
-	if (ret) {
+	if (ret > 0) {
+		/* netdev of ifname is up. */
 		ret = lxc_netdev_down(ifname);
 		if (ret)
 			goto err;
@@ -3457,11 +3455,8 @@ static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
 		goto err;
 
 	return true;
+
 err:
-	/* -EINVAL means there is no netdev named as ifanme. */
-	if (ret == -EINVAL) {
-		ERROR("No network device named as %s.", ifname);
-	}
 	return false;
 }
 

commit e0f591898458167ac110aab5b4cabb892e673083
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 15 11:55:51 2014 +0200

    lxccontainer.c: rename enter_to_ns to enter_net_ns
    
    because that's what it does
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6b85433..8cafdae 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1477,7 +1477,7 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
-static inline bool enter_to_ns(struct lxc_container *c)
+static inline bool enter_net_ns(struct lxc_container *c)
 {
 	pid_t pid = c->init_pid(c);
 
@@ -1586,7 +1586,7 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 		/* close the read-end of the pipe */
 		close(pipefd[0]);
 
-		if (!enter_to_ns(c)) {
+		if (!enter_net_ns(c)) {
 			SYSERROR("failed to enter namespace");
 			goto out;
 		}
@@ -1676,7 +1676,7 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 		/* close the read-end of the pipe */
 		close(pipefd[0]);
 
-		if (!enter_to_ns(c)) {
+		if (!enter_net_ns(c)) {
 			SYSERROR("failed to enter namespace");
 			goto out;
 		}
@@ -3489,7 +3489,7 @@ static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
 
 	if (pid == 0) { // child
 		int ret = 0;
-		if (!enter_to_ns(c)) {
+		if (!enter_net_ns(c)) {
 			ERROR("failed to enter namespace");
 			exit(-1);
 		}

commit e58fae8f29b171bb0fd164c2f566b2475a2b6928
Author: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
Date:   Fri Oct 10 10:57:13 2014 +0800

    container: introduce two functions named as {at/de}tach_interface().
    
    Currently, we depends on ip command to attach interface to container.
    It means we only implemented it by python.
    
    This patch implement adding and removing interface by c and added
    them in struct container.
    
    Changelog: 10/15/2014 (serge): return error if ifname is NULL.
    
    Signed-off-by: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 47f60d9..6b85433 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -39,6 +39,7 @@
 
 #include <lxc/lxccontainer.h>
 #include <lxc/version.h>
+#include <lxc/network.h>
 
 #include "config.h"
 #include "lxc.h"
@@ -3426,6 +3427,99 @@ static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_p
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
+static bool lxcapi_attach_interface(struct lxc_container *c, const char *ifname,
+				const char *dst_ifname)
+{
+	int ret = 0;
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
+
+	if (!ifname) {
+		ERROR("No source interface name given");
+		return false;
+	}
+
+	ret = lxc_netdev_isup(ifname);
+	if (ret < 0)
+		goto err;
+
+	/* netdev of ifname is up. */
+	if (ret) {
+		ret = lxc_netdev_down(ifname);
+		if (ret)
+			goto err;
+	}
+
+	ret = lxc_netdev_move_by_name(ifname, c->init_pid(c), dst_ifname);
+	if (ret)
+		goto err;
+
+	return true;
+err:
+	/* -EINVAL means there is no netdev named as ifanme. */
+	if (ret == -EINVAL) {
+		ERROR("No network device named as %s.", ifname);
+	}
+	return false;
+}
+
+static bool lxcapi_detach_interface(struct lxc_container *c, const char *ifname,
+					const char *dst_ifname)
+{
+	pid_t pid, pid_outside;
+
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
+
+	if (!ifname) {
+		ERROR("No source interface name given");
+		return false;
+	}
+
+	pid_outside = getpid();
+	pid = fork();
+	if (pid < 0) {
+		ERROR("failed to fork task to get interfaces information");
+		return false;
+	}
+
+	if (pid == 0) { // child
+		int ret = 0;
+		if (!enter_to_ns(c)) {
+			ERROR("failed to enter namespace");
+			exit(-1);
+		}
+
+		ret = lxc_netdev_isup(ifname);
+		if (ret < 0)
+			exit(ret);
+
+		/* netdev of ifname is up. */
+		if (ret) {
+			ret = lxc_netdev_down(ifname);
+			if (ret)
+				exit(ret);
+		}
+
+		ret = lxc_netdev_move_by_name(ifname, pid_outside, dst_ifname);
+
+		/* -EINVAL means there is no netdev named as ifanme. */
+		if (ret == -EINVAL) {
+			ERROR("No network device named as %s.", ifname);
+		}
+		exit(ret);
+	}
+
+	if (wait_for_pid(pid) != 0)
+		return false;
+
+	return true;
+}
+
 struct criu_opts {
 	/* The type of criu invocation, one of "dump" or "restore" */
 	char *action;
@@ -4051,6 +4145,8 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->may_control = lxcapi_may_control;
 	c->add_device_node = lxcapi_add_device_node;
 	c->remove_device_node = lxcapi_remove_device_node;
+	c->attach_interface = lxcapi_attach_interface;
+	c->detach_interface = lxcapi_detach_interface;
 	c->checkpoint = lxcapi_checkpoint;
 	c->restore = lxcapi_restore;
 

commit 51d0854cd6360b953c37e3bf1b9a85ce031b2075
Author: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
Date:   Tue Sep 16 16:54:42 2014 +0800

    utils: move useful helper functions from lxccontainer to utils.
    
    Function of enter_to_ns() is useful but currently is static for
    lxccontainer.c.
    
    This patch split it into two parts named as switch_to_newuser()
    and switch_to_newnet() into utils.c.
    
    Signed-off-by: Dongsheng Yang <yangds.fnst@cn.fujitsu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4c3d4d5..47f60d9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1476,56 +1476,15 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
-static inline bool enter_to_ns(struct lxc_container *c) {
-	int netns, userns, ret = 0, init_pid = 0;;
-	char new_netns_path[MAXPATHLEN];
-	char new_userns_path[MAXPATHLEN];
-
-	if (!c->is_running(c))
-		goto out;
-
-	init_pid = c->init_pid(c);
+static inline bool enter_to_ns(struct lxc_container *c)
+{
+	pid_t pid = c->init_pid(c);
 
-	/* Switch to new userns */
 	if ((geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) && access("/proc/self/ns/user", F_OK) == 0) {
-		ret = snprintf(new_userns_path, MAXPATHLEN, "/proc/%d/ns/user", init_pid);
-		if (ret < 0 || ret >= MAXPATHLEN)
-			goto out;
-
-		userns = open(new_userns_path, O_RDONLY);
-		if (userns < 0) {
-			SYSERROR("failed to open %s", new_userns_path);
-			goto out;
-		}
-
-		if (setns(userns, CLONE_NEWUSER)) {
-			SYSERROR("failed to setns for CLONE_NEWUSER");
-			close(userns);
-			goto out;
-		}
-		close(userns);
-	}
-
-	/* Switch to new netns */
-	ret = snprintf(new_netns_path, MAXPATHLEN, "/proc/%d/ns/net", init_pid);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		goto out;
-
-	netns = open(new_netns_path, O_RDONLY);
-	if (netns < 0) {
-		SYSERROR("failed to open %s", new_netns_path);
-		goto out;
-	}
-
-	if (setns(netns, CLONE_NEWNET)) {
-		SYSERROR("failed to setns for CLONE_NEWNET");
-		close(netns);
-		goto out;
+		if (!switch_to_ns(pid, "user"))
+			return false;
 	}
-	close(netns);
-	return true;
-out:
-	return false;
+	return switch_to_ns(pid, "net");
 }
 
 // used by qsort and bsearch functions for comparing names

commit 2ba7a4298964e618e3a81a42187174b9b7921764
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Oct 7 19:33:08 2014 +0000

    restore: create cgroups for criu
    
    Previously, we let criu create the cgroups for a container as it was restoring
    things. In some cases (i.e. migration across hosts), if the container being
    migrated was in /lxc/u1-3, it would be migrated to the target host in
    /lxc/u1-3, even if there was no /lxc/u1-2 (or worse, if there was already an
    alive container in u1-3).
    
    Instead, we use lxc's cgroup_create, and then tell criu where to restore to.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4b31f5c..4c3d4d5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3485,6 +3485,7 @@ struct criu_opts {
 
 	/* restore: the file to write the init process' pid into */
 	char *pidfile;
+	const char *cgroup_path;
 };
 
 /*
@@ -3533,8 +3534,9 @@ static void exec_criu(struct criu_opts *opts)
 		if (!opts->stop)
 			static_args++;
 	} else if (strcmp(opts->action, "restore") == 0) {
-		/* --root $(lxc_mount_point) --restore-detached --restore-sibling --pidfile $foo */
-		static_args += 6;
+		/* --root $(lxc_mount_point) --restore-detached
+		 * --restore-sibling --pidfile $foo --cgroup-root $foo */
+		static_args += 8;
 	} else {
 		return;
 	}
@@ -3607,6 +3609,8 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG("--restore-sibling");
 		DECLARE_ARG("--pidfile");
 		DECLARE_ARG(opts->pidfile);
+		DECLARE_ARG("--cgroup-root");
+		DECLARE_ARG(opts->cgroup_path);
 
 		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
 			char eth[128], veth[128], buf[257];
@@ -3832,6 +3836,11 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		goto out_fini_handler;
 	}
 
+	if (!cgroup_create(handler)) {
+		ERROR("failed creating groups");
+		goto out_fini_handler;
+	}
+
 	pid = fork();
 	if (pid < 0)
 		goto out_fini_handler;
@@ -3865,6 +3874,7 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		os.c = c;
 		os.pidfile = pidfile;
 		os.verbose = verbose;
+		os.cgroup_path = cgroup_canonical_path(handler);
 
 		/* exec_criu() returning is an error */
 		exec_criu(&os);
@@ -3901,11 +3911,6 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 					goto out_fini_handler;
 				}
 
-				if (!cgroup_parse_existing_cgroups(handler)) {
-					ERROR("failed creating cgroups");
-					goto out_fini_handler;
-				}
-
 				if (container_mem_lock(c))
 					goto out_fini_handler;
 

commit dbb51a4361d08a9b68b2dbfea2405b10c05823f9
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Oct 8 12:11:50 2014 -0500

    restore: Hoist handler to function level
    
    On Tue, Oct 07, 2014 at 07:33:07PM +0000, Tycho Andersen wrote:
    > This commit is in preparation for the cgroups create work, since we will need
    > the handler in both the parent and the child. This commit also re-works how
    > errors are propagated to be less verbose.
    
    Here is an updated version:
    
    From 941623498a49551411ccf185146061f3f37d3a67 Mon Sep 17 00:00:00 2001
    From: Tycho Andersen <tycho.andersen@canonical.com>
    Date: Tue, 7 Oct 2014 19:13:51 +0000
    Subject: [PATCH 1/2] restore: Hoist handler to function level
    
    This commit is in preparation for the cgroups create work, since we will need
    the handler in both the parent and the child. This commit also re-works how
    errors are propagated to be less verbose.
    
    v2: rename error to has_error, handle it correctly, and remove some diff noise
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fee758d..4b31f5c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3809,6 +3809,8 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 	struct lxc_list *it;
 	struct lxc_rootfs *rootfs;
 	char pidfile[L_tmpnam];
+	struct lxc_handler *handler;
+	bool has_error = true;
 
 	if (!criu_ok(c))
 		return false;
@@ -3821,9 +3823,18 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 	if (!tmpnam(pidfile))
 		return false;
 
+	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
+	if (!handler)
+		return false;
+
+	if (!cgroup_init(handler)) {
+		ERROR("failed initing cgroups");
+		goto out_fini_handler;
+	}
+
 	pid = fork();
 	if (pid < 0)
-		return false;
+		goto out_fini_handler;
 
 	if (pid == 0) {
 		struct criu_opts os;
@@ -3862,30 +3873,22 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		exit(1);
 	} else {
 		int status;
-		struct lxc_handler *handler;
-		bool error = false;
 
 		pid_t w = waitpid(pid, &status, 0);
 
 		if (w == -1) {
 			perror("waitpid");
-			return false;
+			goto out_fini_handler;
 		}
 
-		handler = lxc_init(c->name, c->lxc_conf, c->config_path);
-		if (!handler)
-			return false;
-
 		if (WIFEXITED(status)) {
 			if (WEXITSTATUS(status)) {
-				error = true;
 				goto out_fini_handler;
 			}
 			else {
 				int netnr = 0, ret;
 				FILE *f = fopen(pidfile, "r");
 				if (!f) {
-					error = true;
 					perror("reading pidfile");
 					ERROR("couldn't read restore's init pidfile %s\n", pidfile);
 					goto out_fini_handler;
@@ -3894,71 +3897,62 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 				ret = fscanf(f, "%d", (int*) &handler->pid);
 				fclose(f);
 				if (ret != 1) {
-					error = true;
 					ERROR("reading restore pid failed");
 					goto out_fini_handler;
 				}
 
-				if (!cgroup_init(handler)) {
-					error = true;
-					ERROR("failed initing cgroups");
-					goto out_fini_handler;
-				}
-
 				if (!cgroup_parse_existing_cgroups(handler)) {
 					ERROR("failed creating cgroups");
 					goto out_fini_handler;
 				}
 
-				if (container_mem_lock(c)) {
-					error = true;
+				if (container_mem_lock(c))
 					goto out_fini_handler;
-				}
 
 				lxc_list_for_each(it, &c->lxc_conf->network) {
 					char eth[128], veth[128];
 					struct lxc_netdev *netdev = it->elem;
 
 					if (read_criu_file(directory, "veth", netnr, veth)) {
-						error = true;
-						goto out_unlock;
+						container_mem_unlock(c);
+						goto out_fini_handler;
 					}
+
 					if (read_criu_file(directory, "eth", netnr, eth)) {
-						error = true;
-						goto out_unlock;
+						container_mem_unlock(c);
+						goto out_fini_handler;
 					}
+
 					netdev->priv.veth_attr.pair = strdup(veth);
 					if (!netdev->priv.veth_attr.pair) {
-						error = true;
-						goto out_unlock;
+						container_mem_unlock(c);
+						goto out_fini_handler;
 					}
+
 					netnr++;
 				}
-out_unlock:
+
 				container_mem_unlock(c);
-				if (error)
-					goto out_fini_handler;
 
-				if (lxc_set_state(c->name, handler, RUNNING)) {
-					error = true;
+				if (lxc_set_state(c->name, handler, RUNNING))
 					goto out_fini_handler;
-				}
 			}
 		} else {
 			ERROR("CRIU was killed with signal %d\n", WTERMSIG(status));
-			error = true;
 			goto out_fini_handler;
 		}
 
 		if (lxc_poll(c->name, handler)) {
 			lxc_abort(c->name, handler);
-			return false;
+			goto out_fini_handler;
 		}
+	}
+
+	has_error = false;
 
 out_fini_handler:
-		lxc_fini(c->name, handler);
-		return !error;
-	}
+	lxc_fini(c->name, handler);
+	return !has_error;
 }
 
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)

commit 2566a145174d0e5e0cd5f0488e559945e791ed7d
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Oct 8 17:12:04 2014 +0000

    criu: DECLARE_ARG should check for null arguments
    
    This is in preparation for the cgroups creation work, but also probably just a
    good idea in general. The ERROR message is handy since we print line nos. it
    will to give people an indication of what arg was null.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4f90f35..fee758d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3554,11 +3554,15 @@ static void exec_criu(struct criu_opts *opts)
 
 	memset(argv, 0, static_args * sizeof(*argv));
 
-#define DECLARE_ARG(arg) 			\
-	do {					\
-		argv[argc++] = strdup(arg);	\
-		if (!argv[argc-1])		\
-			goto err;		\
+#define DECLARE_ARG(arg) 					\
+	do {							\
+		if (arg == NULL) {				\
+			ERROR("Got NULL argument for criu");	\
+			goto err;				\
+		}						\
+		argv[argc++] = strdup(arg);			\
+		if (!argv[argc-1])				\
+			goto err;				\
 	} while (0)
 
 	argv[argc++] = on_path("criu", NULL);

commit a3289423ebeb949c1f37e8fd1016d0531fad5d81
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Sep 24 08:38:41 2014 -0500

    Initialize cgroups on lxc-checkpoint -r
    
    With cgmanager, the cgroups are polled on demand, so these steps aren't needed.
    However, with cgfs, lxc doesn't know about the cgroups for a container and so
    it can't report any of the statistics about e.g. how much memory or CPU a
    container is using.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 94ecc68..4f90f35 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3895,6 +3895,17 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 					goto out_fini_handler;
 				}
 
+				if (!cgroup_init(handler)) {
+					error = true;
+					ERROR("failed initing cgroups");
+					goto out_fini_handler;
+				}
+
+				if (!cgroup_parse_existing_cgroups(handler)) {
+					ERROR("failed creating cgroups");
+					goto out_fini_handler;
+				}
+
 				if (container_mem_lock(c)) {
 					error = true;
 					goto out_fini_handler;

commit c49ecd787d2bf39d0445852115f66f29526151c6
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Wed Sep 24 08:38:40 2014 -0500

    lxc-checkpoint should fail if criu gets signal
    
    The ->checkpoint() API call didn't exit correctly if criu was killed by a
    signal instead of exiting, so lxc-checkpoint didn't fail correctly as a result.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a737191..94ecc68 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3929,6 +3929,10 @@ out_unlock:
 					goto out_fini_handler;
 				}
 			}
+		} else {
+			ERROR("CRIU was killed with signal %d\n", WTERMSIG(status));
+			error = true;
+			goto out_fini_handler;
 		}
 
 		if (lxc_poll(c->name, handler)) {

commit 74bcefea48f73569ec6e91adb410e84efe46d3b8
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Sep 12 20:05:54 2014 -0500

    c/r: use --restore-sibling option in CRIU
    
    After looking through some logs, it is a little cleaner to do it as
    below, instead of what I originally posted.
    
    Tycho
    
    In order for LXC to be the parent of the restored process, CRIU needs to
    restore init as its sibling, not as its child. This was previously accomplished
    essentially via luck :). CRIU now has a --restore-sibling option which forces
    this behavior that LXC expects. See more discussion in this thread:
    http://lists.openvz.org/pipermail/criu/2014-September/thread.html#16330
    
    v2: don't pass --restore-sibling to dump. This is mostly cosmetic, but will
        look less confusing in the logs if people ever look at them.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b8b367d..a737191 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3533,8 +3533,8 @@ static void exec_criu(struct criu_opts *opts)
 		if (!opts->stop)
 			static_args++;
 	} else if (strcmp(opts->action, "restore") == 0) {
-		/* --root $(lxc_mount_point) --restore-detached --pidfile $foo */
-		static_args += 5;
+		/* --root $(lxc_mount_point) --restore-detached --restore-sibling --pidfile $foo */
+		static_args += 6;
 	} else {
 		return;
 	}
@@ -3600,6 +3600,7 @@ static void exec_criu(struct criu_opts *opts)
 		DECLARE_ARG("--root");
 		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
 		DECLARE_ARG("--restore-detached");
+		DECLARE_ARG("--restore-sibling");
 		DECLARE_ARG("--pidfile");
 		DECLARE_ARG(opts->pidfile);
 

commit 3b72c4a0ee2a6ea89aa6478b4db1d53a56e11971
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Sep 2 18:37:05 2014 -0500

    finalize handler in lxcapi_restore
    
    We can also narrow the scope of this, since we only need it in the process that
    is actually going to use it.
    
    Reported-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index cbe58ee..b8b367d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3816,12 +3816,6 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 	if (!tmpnam(pidfile))
 		return false;
 
-	struct lxc_handler *handler;
-
-	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
-	if (!handler)
-		return false;
-
 	pid = fork();
 	if (pid < 0)
 		return false;
@@ -3863,6 +3857,9 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		exit(1);
 	} else {
 		int status;
+		struct lxc_handler *handler;
+		bool error = false;
+
 		pid_t w = waitpid(pid, &status, 0);
 
 		if (w == -1) {
@@ -3870,29 +3867,37 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 			return false;
 		}
 
+		handler = lxc_init(c->name, c->lxc_conf, c->config_path);
+		if (!handler)
+			return false;
+
 		if (WIFEXITED(status)) {
 			if (WEXITSTATUS(status)) {
-				return false;
+				error = true;
+				goto out_fini_handler;
 			}
 			else {
 				int netnr = 0, ret;
-				bool error = false;
 				FILE *f = fopen(pidfile, "r");
 				if (!f) {
+					error = true;
 					perror("reading pidfile");
 					ERROR("couldn't read restore's init pidfile %s\n", pidfile);
-					return false;
+					goto out_fini_handler;
 				}
 
 				ret = fscanf(f, "%d", (int*) &handler->pid);
 				fclose(f);
 				if (ret != 1) {
+					error = true;
 					ERROR("reading restore pid failed");
-					return false;
+					goto out_fini_handler;
 				}
 
-				if (container_mem_lock(c))
-					return false;
+				if (container_mem_lock(c)) {
+					error = true;
+					goto out_fini_handler;
+				}
 
 				lxc_list_for_each(it, &c->lxc_conf->network) {
 					char eth[128], veth[128];
@@ -3916,10 +3921,12 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 out_unlock:
 				container_mem_unlock(c);
 				if (error)
-					return false;
+					goto out_fini_handler;
 
-				if (lxc_set_state(c->name, handler, RUNNING))
-					return false;
+				if (lxc_set_state(c->name, handler, RUNNING)) {
+					error = true;
+					goto out_fini_handler;
+				}
 			}
 		}
 
@@ -3927,9 +3934,11 @@ out_unlock:
 			lxc_abort(c->name, handler);
 			return false;
 		}
-	}
 
-	return true;
+out_fini_handler:
+		lxc_fini(c->name, handler);
+		return !error;
+	}
 }
 
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)

commit 6d5b330dc05f5cd84197057be111ad4fd0939a85
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Sep 2 18:37:04 2014 -0500

    Exit on errors in restore()'s worker
    
    If we just return here, we end up with two processes executing the caller's
    code, which is not good.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index dca0c5d..cbe58ee 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3830,7 +3830,7 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 		struct criu_opts os;
 
 		if (unshare(CLONE_NEWNS))
-			return false;
+			exit(1);
 
 		/* CRIU needs the lxc root bind mounted so that it is the root of some
 		 * mount. */
@@ -3838,15 +3838,15 @@ static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbos
 
 		if (rootfs_is_blockdev(c->lxc_conf)) {
 			if (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)
-				return false;
+				exit(1);
 		}
 		else {
 			if (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)
-				return false;
+				exit(1);
 
 			if (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {
 				rmdir(rootfs->mount);
-				return false;
+				exit(1);
 			}
 		}
 

commit 7c8f5230847bf8ce51b378f9d6271f56574a324b
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Fri Sep 5 08:44:15 2014 -0500

    lxc-checkpoint: use --force-irmap criu option
    
    This option is required when migrating containers across hosts; it is used to
    restore inotify via file paths instead of file handles, which aren't preserved
    across hosts.
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 07a63e7..dca0c5d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3517,11 +3517,12 @@ static int read_criu_file(const char *directory, const char *file, int netnr, ch
 static void exec_criu(struct criu_opts *opts)
 {
 	char **argv, log[PATH_MAX];
-	int static_args = 13, argc = 0, i, ret;
+	int static_args = 14, argc = 0, i, ret;
 
 	/* The command line always looks like:
-	 * criu $(action) --tcp-established --file-locks --link-remap --manage-cgroups \
-	 *     --action-script foo.sh -D $(directory) -o $(directory)/$(action).log
+	 * criu $(action) --tcp-established --file-locks --link-remap --force-irmap \
+	 * --manage-cgroups action-script foo.sh -D $(directory) \
+	 * -o $(directory)/$(action).log
 	 * +1 for final NULL */
 
 	if (strcmp(opts->action, "dump") == 0) {
@@ -3570,6 +3571,7 @@ static void exec_criu(struct criu_opts *opts)
 	DECLARE_ARG("--tcp-established");
 	DECLARE_ARG("--file-locks");
 	DECLARE_ARG("--link-remap");
+	DECLARE_ARG("--force-irmap");
 	DECLARE_ARG("--manage-cgroups");
 	DECLARE_ARG("--action-script");
 	DECLARE_ARG(LIBEXECDIR "/lxc/lxc-restore-net");

commit 67702c2129c462b5e8124020a496fbf6b7ae5540
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Sep 1 20:01:20 2014 +0000

    config: fix the handling of lxc.hook and hwaddrs in unexpanded config
    
    And add a testcase.
    
    The code to update hwaddrs in a clone was walking through the container
    configuration and re-printing all network entries.  However network
    entries from an include file which should not be printed out were being
    added to the unexpanded config.  With this patch, at clone we simply
    update the hwaddr in-place in the unexpanded configuration file, making
    sure to make the same update to the expanded network configuration.
    
    The code to update out lxc.hook statements had the same problem.
    We also update it in-place in the unexpanded configuration, though
    we mirror the logic we use when updating the expanded configuration.
    (Perhaps that should be changed, to simplify future updates)
    
    This code isn't particularly easy to review, so testcases are added
    to make sure that (1) extra lxc.network entries are not added (or
    removed), even if they are present in an included file, (2) lxc.hook
    entries are not added, (3) hwaddr entries are updated, and (4)
    the lxc.hook entries are properly updated (only when they should be).
    
    Reported-by: Stphane Graber <stgraber@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ee8f491..07a63e7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -415,8 +415,6 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 		return false;
 	if (lxc_config_read(fname, c->lxc_conf, false) != 0)
 		return false;
-	if (!clone_update_unexp_network(c->lxc_conf))
-		return false;
 	return true;
 }
 
@@ -2434,7 +2432,8 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 		}
 	}
 
-	if (!clone_update_unexp_hooks(c->lxc_conf)) {
+	if (!clone_update_unexp_hooks(c->lxc_conf, oldc->config_path,
+			c->config_path, oldc->name, c->name)) {
 		ERROR("Error saving new hooks in clone");
 		return -1;
 	}
@@ -2442,33 +2441,6 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 	return 0;
 }
 
-static void new_hwaddr(char *hwaddr)
-{
-	FILE *f;
-	f = fopen("/dev/urandom", "r");
-	if (f) {
-		unsigned int seed;
-		int ret = fread(&seed, sizeof(seed), 1, f);
-		if (ret != 1)
-			seed = time(NULL);
-		fclose(f);
-		srand(seed);
-	} else
-		srand(time(NULL));
-	snprintf(hwaddr, 18, "00:16:3e:%02x:%02x:%02x",
-			rand() % 255, rand() % 255, rand() % 255);
-}
-
-static void network_new_hwaddrs(struct lxc_container *c)
-{
-	struct lxc_list *it;
-
-	lxc_list_for_each(it, &c->lxc_conf->network) {
-		struct lxc_netdev *n = it->elem;
-		if (n->hwaddr)
-			new_hwaddr(n->hwaddr);
-	}
-}
 
 static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
 {
@@ -2844,9 +2816,8 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 
 	// update macaddrs
 	if (!(flags & LXC_CLONE_KEEPMACADDR)) {
-		network_new_hwaddrs(c2);
-		if (!clone_update_unexp_network(c2->lxc_conf)) {
-			ERROR("Error updating network for clone");
+		if (!network_new_hwaddrs(c2->lxc_conf)) {
+			ERROR("Error updating mac addresses");
 			goto out;
 		}
 	}

commit 88556fd7560e3811f92108cb7eb51d41eb558724
Author: S.alar Onur <caglar@10ur.org>
Date:   Mon Aug 25 19:54:51 2014 -0400

    handle hashed command socket names (v2)
    
    With the new hashed command socket names (e85898415c), it's possible to
    have something like below;
    
    [caglar@qop:~/go/src/github.com/lxc/go-lxc(master)] cat /proc/net/unix | grep lxc
    0000000000000000: 00000002 00000000 00010000 0001 01 53465 @lxc/d086e835c86f4b8d/command
    [...]
    
    list_active_containers reads /proc/net/unix to find all running
    containers but this new format no longer includes the container name or
    its lxcpath.
    
    This patch introduces two new commands (LXC_CMD_GET_NAME and
    LXC_CMD_GET_LXCPATH) and starts to use those in list_active_containers
    call.
    
    changes since v1:
     - added sanity check proposed by Serge
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ed6f8de..ee8f491 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -4217,6 +4217,7 @@ int list_active_containers(const char *lxcpath, char ***nret,
 	char **ct_name = NULL;
 	size_t len = 0;
 	struct lxc_container *c;
+	bool is_hashed;
 
 	if (!lxcpath)
 		lxcpath = lxc_global_config_value("lxc.lxcpath");
@@ -4232,6 +4233,7 @@ int list_active_containers(const char *lxcpath, char ***nret,
 		return -1;
 
 	while (getline(&line, &len, f) != -1) {
+
 		char *p = strrchr(line, ' '), *p2;
 		if (!p)
 			continue;
@@ -4239,9 +4241,17 @@ int list_active_containers(const char *lxcpath, char ***nret,
 		if (*p != 0x40)
 			continue;
 		p++;
-		if (strncmp(p, lxcpath, lxcpath_len) != 0)
+
+		is_hashed = false;
+		if (strncmp(p, lxcpath, lxcpath_len) == 0) {
+			p += lxcpath_len;
+		} else if (strncmp(p, "lxc/", 4) == 0) {
+			p += 4;
+			is_hashed = true;
+		} else {
 			continue;
-		p += lxcpath_len;
+		}
+
 		while (*p == '/')
 			p++;
 
@@ -4251,6 +4261,12 @@ int list_active_containers(const char *lxcpath, char ***nret,
 			continue;
 		*p2 = '\0';
 
+		if (is_hashed) {
+			if (strncmp(lxcpath, lxc_cmd_get_lxcpath(p), lxcpath_len) != 0)
+				continue;
+			p = lxc_cmd_get_name(p);
+		}
+
 		if (array_contains(&ct_name, p, ct_name_cnt))
 			continue;
 

commit 735f2c6e504a541cbb2592a3f94858bf337a24ff
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Aug 26 09:09:36 2014 -0500

    Add support for checkpoint and restore via CRIU
    
    This patch adds support for checkpointing and restoring containers via CRIU.
    It adds two api calls, ->checkpoint and ->restore, which are wrappers around
    the CRIU CLI. CRIU has an RPC API, but reasons for preferring exec() are
    discussed in [1].
    
    To checkpoint, users specify a directory to dump the container metadata (CRIU
    dump files, plus some additional information about veth pairs and which
    bridges they are attached to) into this directory. On restore, this
    information is read out of the directory, a CRIU command line is constructed,
    and CRIU is exec()d. CRIU uses the lxc-restore-net callback (which in turn
    inspects the image directory with the NIC data) to properly restore the
    network.
    
    This will only work with the current git master of CRIU; anything as of
    a152c843 should work. There is a known bug where containers which have been
    restored cannot be checkpointed [2].
    
    [1]: http://lists.openvz.org/pipermail/criu/2014-July/015117.html
    [2]: http://lists.openvz.org/pipermail/criu/2014-August/015876.html
    
    v2: fixed some problems with the s/int/bool return code form api function
    v3: added a testcase, fixed up the man page synopsis
    v4: fix a small typo in lxc-test-checkpoint-restore
    v5: remove a reference to the old CRIU_PATH, and a bad error about the same
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 172e667..ed6f8de 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -55,6 +55,7 @@
 #include "monitor.h"
 #include "namespace.h"
 #include "lxclock.h"
+#include "sync.h"
 
 #if HAVE_IFADDRS_H
 #include <ifaddrs.h>
@@ -3495,6 +3496,469 @@ static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_p
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
+struct criu_opts {
+	/* The type of criu invocation, one of "dump" or "restore" */
+	char *action;
+
+	/* The directory to pass to criu */
+	char *directory;
+
+	/* The container to dump */
+	struct lxc_container *c;
+
+	/* Enable criu verbose mode? */
+	bool verbose;
+
+	/* dump: stop the container or not after dumping? */
+	bool stop;
+
+	/* restore: the file to write the init process' pid into */
+	char *pidfile;
+};
+
+/*
+ * @out must be 128 bytes long
+ */
+static int read_criu_file(const char *directory, const char *file, int netnr, char *out)
+{
+	char path[PATH_MAX];
+	int ret;
+	FILE *f;
+
+	ret = snprintf(path, PATH_MAX,  "%s/%s%d", directory, file, netnr);
+	if (ret < 0 || ret >= PATH_MAX) {
+		ERROR("%s: path too long", __func__);
+		return -1;
+	}
+
+	f = fopen(path, "r");
+	if (!f)
+		return -1;
+
+	ret = fscanf(f, "%127s", out);
+	fclose(f);
+	if (ret <= 0)
+		return -1;
+
+	return 0;
+}
+
+static void exec_criu(struct criu_opts *opts)
+{
+	char **argv, log[PATH_MAX];
+	int static_args = 13, argc = 0, i, ret;
+
+	/* The command line always looks like:
+	 * criu $(action) --tcp-established --file-locks --link-remap --manage-cgroups \
+	 *     --action-script foo.sh -D $(directory) -o $(directory)/$(action).log
+	 * +1 for final NULL */
+
+	if (strcmp(opts->action, "dump") == 0) {
+		/* -t pid */
+		static_args += 2;
+
+		/* --leave-running */
+		if (!opts->stop)
+			static_args++;
+	} else if (strcmp(opts->action, "restore") == 0) {
+		/* --root $(lxc_mount_point) --restore-detached --pidfile $foo */
+		static_args += 5;
+	} else {
+		return;
+	}
+
+	if (opts->verbose)
+		static_args++;
+
+	ret = snprintf(log, PATH_MAX, "%s/%s.log", opts->directory, opts->action);
+	if (ret < 0 || ret >= PATH_MAX) {
+		ERROR("logfile name too long\n");
+		return;
+	}
+
+	argv = malloc(static_args * sizeof(*argv));
+	if (!argv)
+		return;
+
+	memset(argv, 0, static_args * sizeof(*argv));
+
+#define DECLARE_ARG(arg) 			\
+	do {					\
+		argv[argc++] = strdup(arg);	\
+		if (!argv[argc-1])		\
+			goto err;		\
+	} while (0)
+
+	argv[argc++] = on_path("criu", NULL);
+	if (!argv[argc-1]) {
+		ERROR("Couldn't find criu binary\n");
+		goto err;
+	}
+
+	DECLARE_ARG(opts->action);
+	DECLARE_ARG("--tcp-established");
+	DECLARE_ARG("--file-locks");
+	DECLARE_ARG("--link-remap");
+	DECLARE_ARG("--manage-cgroups");
+	DECLARE_ARG("--action-script");
+	DECLARE_ARG(LIBEXECDIR "/lxc/lxc-restore-net");
+	DECLARE_ARG("-D");
+	DECLARE_ARG(opts->directory);
+	DECLARE_ARG("-o");
+	DECLARE_ARG(log);
+
+	if (opts->verbose)
+		DECLARE_ARG("-vvvvvv");
+
+	if (strcmp(opts->action, "dump") == 0) {
+		char pid[32];
+
+		if (sprintf(pid, "%d", lxcapi_init_pid(opts->c)) < 0)
+			goto err;
+
+		DECLARE_ARG("-t");
+		DECLARE_ARG(pid);
+		if (!opts->stop)
+			DECLARE_ARG("--leave-running");
+	} else if (strcmp(opts->action, "restore") == 0) {
+		int netnr = 0;
+		struct lxc_list *it;
+
+		DECLARE_ARG("--root");
+		DECLARE_ARG(opts->c->lxc_conf->rootfs.mount);
+		DECLARE_ARG("--restore-detached");
+		DECLARE_ARG("--pidfile");
+		DECLARE_ARG(opts->pidfile);
+
+		lxc_list_for_each(it, &opts->c->lxc_conf->network) {
+			char eth[128], veth[128], buf[257];
+			void *m;
+
+			if (read_criu_file(opts->directory, "veth", netnr, veth))
+				goto err;
+			if (read_criu_file(opts->directory, "eth", netnr, eth))
+				goto err;
+			ret = snprintf(buf, 257, "%s=%s", eth, veth);
+			if (ret < 0 || ret >= 257)
+				goto err;
+
+			/* final NULL and --veth-pair eth0:vethASDF */
+			m = realloc(argv, (argc + 1 + 2) * sizeof(*argv));
+			if (!m)
+				goto err;
+			argv = m;
+
+			DECLARE_ARG("--veth-pair");
+			DECLARE_ARG(buf);
+			argv[argc] = NULL;
+
+			netnr++;
+		}
+	}
+
+#undef DECLARE_ARG
+
+	execv(argv[0], argv);
+err:
+	for (i = 0; argv[i]; i++)
+		free(argv[i]);
+	free(argv);
+}
+
+/* Check and make sure the container has a configuration that we know CRIU can
+ * dump. */
+static bool criu_ok(struct lxc_container *c)
+{
+	struct lxc_list *it;
+	bool found_deny_rule = false;
+
+	if (geteuid()) {
+		ERROR("Must be root to checkpoint\n");
+		return false;
+	}
+
+	/* We only know how to restore containers with veth networks. */
+	lxc_list_for_each(it, &c->lxc_conf->network) {
+		struct lxc_netdev *n = it->elem;
+		if (n->type != LXC_NET_VETH && n->type != LXC_NET_NONE) {
+			ERROR("Found network that is not VETH or NONE\n");
+			return false;
+		}
+	}
+
+	// These requirements come from http://criu.org/LXC
+	if (c->lxc_conf->console.path &&
+			strcmp(c->lxc_conf->console.path, "none") != 0) {
+		ERROR("lxc.console must be none\n");
+		return false;
+	}
+
+	if (c->lxc_conf->tty != 0) {
+		ERROR("lxc.tty must be 0\n");
+		return false;
+	}
+
+	lxc_list_for_each(it, &c->lxc_conf->cgroup) {
+		struct lxc_cgroup *cg = it->elem;
+		if (strcmp(cg->subsystem, "devices.deny") == 0 &&
+				strcmp(cg->value, "c 5:1 rwm") == 0) {
+
+			found_deny_rule = true;
+			break;
+		}
+	}
+
+	if (!found_deny_rule) {
+		ERROR("couldn't find devices.deny = c 5:1 rwm");
+		return false;
+	}
+
+	return true;
+}
+
+static bool lxcapi_checkpoint(struct lxc_container *c, char *directory, bool stop, bool verbose)
+{
+	int netnr, status;
+	struct lxc_list *it;
+	bool error = false;
+	pid_t pid;
+
+	if (!criu_ok(c))
+		return false;
+
+	if (mkdir(directory, 0700) < 0 && errno != EEXIST)
+		return false;
+
+	netnr = 0;
+	lxc_list_for_each(it, &c->lxc_conf->network) {
+		char *veth = NULL, *bridge = NULL, veth_path[PATH_MAX], eth[128];
+		struct lxc_netdev *n = it->elem;
+		int pret;
+
+		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.veth.pair", netnr);
+		if (pret < 0 || pret >= PATH_MAX) {
+			error = true;
+			goto out;
+		}
+
+		veth = lxcapi_get_running_config_item(c, veth_path);
+		if (!veth) {
+			/* criu_ok() checks that all interfaces are
+			 * LXC_NET{VETH,NONE}, and VETHs should have this
+			 * config */
+			assert(n->type == LXC_NET_NONE);
+			break;
+		}
+
+		pret = snprintf(veth_path, PATH_MAX, "lxc.network.%d.link", netnr);
+		if (pret < 0 || pret >= PATH_MAX) {
+			error = true;
+			goto out;
+		}
+
+		bridge = lxcapi_get_running_config_item(c, veth_path);
+		if (!bridge) {
+			error = true;
+			goto out;
+		}
+
+		pret = snprintf(veth_path, PATH_MAX, "%s/veth%d", directory, netnr);
+		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, veth) < 0) {
+			error = true;
+			goto out;
+		}
+
+		pret = snprintf(veth_path, PATH_MAX, "%s/bridge%d", directory, netnr);
+		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, bridge) < 0) {
+			error = true;
+			goto out;
+		}
+
+		if (n->name) {
+			if (strlen(n->name) >= 128) {
+				error = true;
+				goto out;
+			}
+			strncpy(eth, n->name, 128);
+		} else
+			sprintf(eth, "eth%d", netnr);
+
+		pret = snprintf(veth_path, PATH_MAX, "%s/eth%d", directory, netnr);
+		if (pret < 0 || pret >= PATH_MAX || print_to_file(veth_path, eth) < 0)
+			error = true;
+
+out:
+		free(veth);
+		free(bridge);
+		if (error)
+			return false;
+	}
+
+	pid = fork();
+	if (pid < 0)
+		return false;
+
+	if (pid == 0) {
+		struct criu_opts os;
+
+		os.action = "dump";
+		os.directory = directory;
+		os.c = c;
+		os.stop = stop;
+		os.verbose = verbose;
+
+		/* exec_criu() returning is an error */
+		exec_criu(&os);
+		exit(1);
+	} else {
+		pid_t w = waitpid(pid, &status, 0);
+		if (w == -1) {
+			perror("waitpid");
+			return false;
+		}
+
+		if (WIFEXITED(status)) {
+			return !WEXITSTATUS(status);
+		}
+
+		return false;
+	}
+}
+
+static bool lxcapi_restore(struct lxc_container *c, char *directory, bool verbose)
+{
+	pid_t pid;
+	struct lxc_list *it;
+	struct lxc_rootfs *rootfs;
+	char pidfile[L_tmpnam];
+
+	if (!criu_ok(c))
+		return false;
+
+	if (geteuid()) {
+		ERROR("Must be root to restore\n");
+		return false;
+	}
+
+	if (!tmpnam(pidfile))
+		return false;
+
+	struct lxc_handler *handler;
+
+	handler = lxc_init(c->name, c->lxc_conf, c->config_path);
+	if (!handler)
+		return false;
+
+	pid = fork();
+	if (pid < 0)
+		return false;
+
+	if (pid == 0) {
+		struct criu_opts os;
+
+		if (unshare(CLONE_NEWNS))
+			return false;
+
+		/* CRIU needs the lxc root bind mounted so that it is the root of some
+		 * mount. */
+		rootfs = &c->lxc_conf->rootfs;
+
+		if (rootfs_is_blockdev(c->lxc_conf)) {
+			if (do_rootfs_setup(c->lxc_conf, c->name, c->config_path) < 0)
+				return false;
+		}
+		else {
+			if (mkdir(rootfs->mount, 0755) < 0 && errno != EEXIST)
+				return false;
+
+			if (mount(rootfs->path, rootfs->mount, NULL, MS_BIND, NULL) < 0) {
+				rmdir(rootfs->mount);
+				return false;
+			}
+		}
+
+		os.action = "restore";
+		os.directory = directory;
+		os.c = c;
+		os.pidfile = pidfile;
+		os.verbose = verbose;
+
+		/* exec_criu() returning is an error */
+		exec_criu(&os);
+		umount(rootfs->mount);
+		rmdir(rootfs->mount);
+		exit(1);
+	} else {
+		int status;
+		pid_t w = waitpid(pid, &status, 0);
+
+		if (w == -1) {
+			perror("waitpid");
+			return false;
+		}
+
+		if (WIFEXITED(status)) {
+			if (WEXITSTATUS(status)) {
+				return false;
+			}
+			else {
+				int netnr = 0, ret;
+				bool error = false;
+				FILE *f = fopen(pidfile, "r");
+				if (!f) {
+					perror("reading pidfile");
+					ERROR("couldn't read restore's init pidfile %s\n", pidfile);
+					return false;
+				}
+
+				ret = fscanf(f, "%d", (int*) &handler->pid);
+				fclose(f);
+				if (ret != 1) {
+					ERROR("reading restore pid failed");
+					return false;
+				}
+
+				if (container_mem_lock(c))
+					return false;
+
+				lxc_list_for_each(it, &c->lxc_conf->network) {
+					char eth[128], veth[128];
+					struct lxc_netdev *netdev = it->elem;
+
+					if (read_criu_file(directory, "veth", netnr, veth)) {
+						error = true;
+						goto out_unlock;
+					}
+					if (read_criu_file(directory, "eth", netnr, eth)) {
+						error = true;
+						goto out_unlock;
+					}
+					netdev->priv.veth_attr.pair = strdup(veth);
+					if (!netdev->priv.veth_attr.pair) {
+						error = true;
+						goto out_unlock;
+					}
+					netnr++;
+				}
+out_unlock:
+				container_mem_unlock(c);
+				if (error)
+					return false;
+
+				if (lxc_set_state(c->name, handler, RUNNING))
+					return false;
+			}
+		}
+
+		if (lxc_poll(c->name, handler)) {
+			lxc_abort(c->name, handler);
+			return false;
+		}
+	}
+
+	return true;
+}
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -3627,6 +4091,8 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->may_control = lxcapi_may_control;
 	c->add_device_node = lxcapi_add_device_node;
 	c->remove_device_node = lxcapi_remove_device_node;
+	c->checkpoint = lxcapi_checkpoint;
+	c->restore = lxcapi_restore;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit d5752559f8d6971dfd189fcc5ff17f0bef99498c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Aug 21 16:02:18 2014 +0000

    chmod container dir to 0770 (v2)
    
    This prevents u2 from going into /home/u1/.local/share/lxc/u1/rootfs
    and running setuid-root applications to get write access to u1's
    container rootfs.
    
    v2: set umask to 002 for the mkdir.  Otherwise if umask happens to be,
    say, 022, then user does not have write permissions under the container
    dir and creation of $containerdir/partial file will fail.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 98174f4..172e667 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -735,6 +735,31 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
+static int do_create_container_dir(const char *path, struct lxc_conf *conf)
+{
+	int ret = -1, lasterr;
+	char *p = alloca(strlen(path)+1);
+	mode_t mask = umask(0002);
+	ret = mkdir(path, 0770);
+	lasterr = errno;
+	umask(mask);
+	errno = lasterr;
+	if (ret) {
+		if (errno == EEXIST)
+			ret = 0;
+		else {
+			SYSERROR("failed to create container path %s", path);
+			return -1;
+		}
+	}
+	strcpy(p, path);
+	if (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {
+		ERROR("Failed to chown container dir");
+		ret = -1;
+	}
+	return ret;
+}
+
 /*
  * create the standard expected container dir
  */
@@ -752,13 +777,7 @@ static bool create_container_dir(struct lxc_container *c)
 		free(s);
 		return false;
 	}
-	ret = mkdir(s, 0755);
-	if (ret) {
-		if (errno == EEXIST)
-			ret = 0;
-		else
-			SYSERROR("failed to create container path for %s", c->name);
-	}
+	ret = do_create_container_dir(s, c->lxc_conf);
 	free(s);
 	return ret == 0;
 }
@@ -2705,17 +2724,15 @@ sudo lxc-clone -o o1 -n n1 -s -L|-fssize fssize -v|--vgname vgname \
 only rootfs gets converted (copied/snapshotted) on clone.
 */
 
-static int create_file_dirname(char *path)
+static int create_file_dirname(char *path, struct lxc_conf *conf)
 {
 	char *p = strrchr(path, '/');
-	int ret;
+	int ret = -1;
 
 	if (!p)
 		return -1;
 	*p = '\0';
-	ret = mkdir(path, 0755);
-	if (ret && errno != EEXIST)
-		SYSERROR("creating container path %s", path);
+        ret = do_create_container_dir(path, conf);
 	*p = '/';
 	return ret;
 }
@@ -2759,7 +2776,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		goto out;
 	}
 
-	ret = create_file_dirname(newpath);
+	ret = create_file_dirname(newpath, c->lxc_conf);
 	if (ret < 0 && errno != EEXIST) {
 		ERROR("Error creating container dir for %s", newpath);
 		goto out;

commit d08779d49d36db9e2dd8ab33a4af9db281a001b5
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 22 04:45:18 2014 +0000

    load_config_locked: update unexp network
    
    When we read a lxc.network.hwaddr line, if it contained any 'x's then
    those get quitely filled in at config_network_hwaddr.  If that happens
    then we want to save the autogenerated hwaddr in the unexpanded config
    so that when we write it to disk, it is saved.
    
    This patch dumbly re-generates the network configuration in the
    unexp configuration every time we load a config file, just as we do
    after every clone.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0cf21ce..98174f4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -412,9 +412,11 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 		c->lxc_conf = lxc_conf_init();
 	if (!c->lxc_conf)
 		return false;
-	if (!lxc_config_read(fname, c->lxc_conf, false))
-		return true;
-	return false;
+	if (lxc_config_read(fname, c->lxc_conf, false) != 0)
+		return false;
+	if (!clone_update_unexp_network(c->lxc_conf))
+		return false;
+	return true;
 }
 
 static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)

commit da8c55e6ec2dec51d4335937e9f3af94fb200efa
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Sat Aug 16 17:16:36 2014 -0400

    Revert "chmod container dir to 0770"
    
    This commit broke the testsuite for unprivileged containers as the
    container directory is now 0750 with the owner being the container root
    and the group being the user's group, meaning that the parent user can
    only enter the directory, not create entries in there.
    
    This reverts commit c86da6a3ac517b78e6f710df7efe2f51d153b73c.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 223f455..0cf21ce 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -733,27 +733,6 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
-static int do_create_container_dir(const char *path, struct lxc_conf *conf)
-{
-	int ret = -1;
-	char *p = alloca(strlen(path)+1);
-	ret = mkdir(path, 0770);
-	if (ret) {
-		if (errno == EEXIST)
-			ret = 0;
-		else {
-			SYSERROR("failed to create container path %s", path);
-			return -1;
-		}
-	}
-	strcpy(p, path);
-	if (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {
-		ERROR("Failed to chown container dir");
-		ret = -1;
-	}
-	return ret;
-}
-
 /*
  * create the standard expected container dir
  */
@@ -771,7 +750,13 @@ static bool create_container_dir(struct lxc_container *c)
 		free(s);
 		return false;
 	}
-	ret = do_create_container_dir(s, c->lxc_conf);
+	ret = mkdir(s, 0755);
+	if (ret) {
+		if (errno == EEXIST)
+			ret = 0;
+		else
+			SYSERROR("failed to create container path for %s", c->name);
+	}
 	free(s);
 	return ret == 0;
 }
@@ -2718,15 +2703,17 @@ sudo lxc-clone -o o1 -n n1 -s -L|-fssize fssize -v|--vgname vgname \
 only rootfs gets converted (copied/snapshotted) on clone.
 */
 
-static int create_file_dirname(char *path, struct lxc_conf *conf)
+static int create_file_dirname(char *path)
 {
 	char *p = strrchr(path, '/');
-	int ret = -1;
+	int ret;
 
 	if (!p)
 		return -1;
 	*p = '\0';
-        ret = do_create_container_dir(path, conf);
+	ret = mkdir(path, 0755);
+	if (ret && errno != EEXIST)
+		SYSERROR("creating container path %s", path);
 	*p = '/';
 	return ret;
 }
@@ -2770,7 +2757,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		goto out;
 	}
 
-	ret = create_file_dirname(newpath, c->lxc_conf);
+	ret = create_file_dirname(newpath);
 	if (ret < 0 && errno != EEXIST) {
 		ERROR("Error creating container dir for %s", newpath);
 		goto out;

commit c86da6a3ac517b78e6f710df7efe2f51d153b73c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Aug 14 18:29:55 2014 +0000

    chmod container dir to 0770
    
    This prevents u2 from going into /home/u1/.local/share/lxc/u1/rootfs
    and running setuid-root applications to get write access to u1's
    container rootfs.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0cf21ce..223f455 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -733,6 +733,27 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
+static int do_create_container_dir(const char *path, struct lxc_conf *conf)
+{
+	int ret = -1;
+	char *p = alloca(strlen(path)+1);
+	ret = mkdir(path, 0770);
+	if (ret) {
+		if (errno == EEXIST)
+			ret = 0;
+		else {
+			SYSERROR("failed to create container path %s", path);
+			return -1;
+		}
+	}
+	strcpy(p, path);
+	if (!lxc_list_empty(&conf->id_map) && chown_mapped_root(p, conf) != 0) {
+		ERROR("Failed to chown container dir");
+		ret = -1;
+	}
+	return ret;
+}
+
 /*
  * create the standard expected container dir
  */
@@ -750,13 +771,7 @@ static bool create_container_dir(struct lxc_container *c)
 		free(s);
 		return false;
 	}
-	ret = mkdir(s, 0755);
-	if (ret) {
-		if (errno == EEXIST)
-			ret = 0;
-		else
-			SYSERROR("failed to create container path for %s", c->name);
-	}
+	ret = do_create_container_dir(s, c->lxc_conf);
 	free(s);
 	return ret == 0;
 }
@@ -2703,17 +2718,15 @@ sudo lxc-clone -o o1 -n n1 -s -L|-fssize fssize -v|--vgname vgname \
 only rootfs gets converted (copied/snapshotted) on clone.
 */
 
-static int create_file_dirname(char *path)
+static int create_file_dirname(char *path, struct lxc_conf *conf)
 {
 	char *p = strrchr(path, '/');
-	int ret;
+	int ret = -1;
 
 	if (!p)
 		return -1;
 	*p = '\0';
-	ret = mkdir(path, 0755);
-	if (ret && errno != EEXIST)
-		SYSERROR("creating container path %s", path);
+        ret = do_create_container_dir(path, conf);
 	*p = '/';
 	return ret;
 }
@@ -2757,7 +2770,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		goto out;
 	}
 
-	ret = create_file_dirname(newpath);
+	ret = create_file_dirname(newpath, c->lxc_conf);
 	if (ret < 0 && errno != EEXIST) {
 		ERROR("Error creating container dir for %s", newpath);
 		goto out;

commit 05d53f4c0d4ec317f4f92f33331b222ac8562335
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Aug 11 14:10:04 2014 +0000

    coverity: don't use newname after null check
    
    Actually, get rid of the temporary variables, and set newname
    and lxcpath to usable values if they were NULL.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 38197d6..0cf21ce 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2726,7 +2726,6 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	struct lxc_container *c2 = NULL;
 	char newpath[MAXPATHLEN];
 	int ret, storage_copied = 0;
-	const char *n, *l;
 	char *origroot = NULL;
 	struct clone_update_data data;
 	FILE *fout;
@@ -2744,9 +2743,11 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	}
 
 	// Make sure the container doesn't yet exist.
-	n = newname ? newname : c->name;
-	l = lxcpath ? lxcpath : c->get_config_path(c);
-	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", l, n);
+	if (!newname)
+		newname = c->name;
+	if (!lxcpath)
+		lxcpath = c->get_config_path(c);
+	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", lxcpath, newname);
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		SYSERROR("clone: failed making config pathname");
 		goto out;
@@ -2776,7 +2777,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	fclose(fout);
 	c->lxc_conf->rootfs.path = origroot;
 
-	sprintf(newpath, "%s/%s/rootfs", l, n);
+	sprintf(newpath, "%s/%s/rootfs", lxcpath, newname);
 	if (mkdir(newpath, 0755) < 0) {
 		SYSERROR("error creating %s", newpath);
 		goto out;
@@ -2789,9 +2790,10 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		}
 	}
 
-	c2 = lxc_container_new(n, l);
+	c2 = lxc_container_new(newname, lxcpath);
 	if (!c2) {
-		ERROR("clone: failed to create new container (%s %s)", n, l);
+		ERROR("clone: failed to create new container (%s %s)", newname,
+				lxcpath);
 		goto out;
 	}
 

commit 9581b4b739323e8ccf85362d7da4be26cd459f4b
Author: Vincent Giersch <vincent.giersch@ovh.net>
Date:   Fri May 23 11:04:26 2014 +0200

    Fix a file descriptor leak in the daemonization
    
    Especially when using the Python API, the child process inherits of
    the file descriptiors of the script.
    
    Signed-off-by: Vincent Giersch <vincent.giersch@ovh.net>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 553f026..38197d6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -625,6 +625,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			SYSERROR("Error chdir()ing to /.");
 			return false;
 		}
+		lxc_check_inherited(conf, -1);
 		close(0);
 		close(1);
 		close(2);

commit cdd01be26ea320a8b5be313a864cb553df90c33e
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 8 15:00:18 2014 +0000

    Do not allow snapshots of LVM backed containers
    
    They don't work right now, so until we fix that, don't allow it.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 814aeb1..553f026 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2987,6 +2987,12 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
+	if (!bdev_can_backup(c->lxc_conf)) {
+		ERROR("%s's backing store cannot be backed up.", c->name);
+		ERROR("Your container must use another backing store type.");
+		return -1;
+	}
+
 	if (!get_snappath_dir(c, snappath))
 		return -1;
 

commit 6b0d553864a16462850d87d4d2e9056ea136ebad
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 1 23:34:16 2014 +0000

    unexpanded config file: turn into a string
    
    Originally, we only kept a struct lxc_conf representing the current
    container configuration.  This was insufficient because lxc.include's
    were expanded, so a clone or a snapshot would contain the expanded
    include file contents, rather than the original "lxc.include".  If
    the host's include files are updated, clones and snapshots would not
    inherit those updates.
    
    To address this, we originally added a lxc_unexp_conf, which mirrored
    the lxc_conf, except that lxc.include was not expanded.
    
    This has its own cshortcomings, however,  In particular, if a lxc.include
    has a lxc.cgroup setting, and you use the api to say:
    
    c.clear_config_item("lxc.cgroup")
    
    this is not representable in the lxc_unexp_conf.  (The original problem,
    which was pointed out to me by stgraber, was slightly different, but
    unlike this problem it was not unsolvable).
    
    This patch changes the unexpanded configuration  to be a textual
    representation of the configuration.  This allows us *order* the
    configuration commands, which is what was not possible using the
    struct lxc_conf *lxc_unexp_conf.
    
    The write_config() now becomes a simple fwrite.  However, lxc_clone
    is slightly complicated in parts, the worst of which is the need to
    rewrite the network configuration if we are changing the macaddrs.
    
    With this patch, lxc-clone and clear_config_item do the right thing.
    lxc-test-saveconfig and lxc-test-clonetest both pass.
    
    There is room for improvement - multiple calls to
    
    c.append_config_item("lxc.network.link", "lxcbr0")
    
    will result in multiple such lines in the configuration file.  In that
    particular case it is harmless.  There may be cases where it is not.
    
    Overall, this should be a huge improvement in terms of correctness.
    
    Changelog: Aug 1: updated to current lxc git head.  All lxc-test* and
       python api test passed.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ca5da87..814aeb1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -238,10 +238,6 @@ static void lxc_container_free(struct lxc_container *c)
 		lxc_conf_free(c->lxc_conf);
 		c->lxc_conf = NULL;
 	}
-	if (c->lxc_unexp_conf) {
-		lxc_conf_free(c->lxc_unexp_conf);
-		c->lxc_unexp_conf = NULL;
-	}
 	if (c->config_path) {
 		free(c->config_path);
 		c->config_path = NULL;
@@ -414,14 +410,9 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
 		c->lxc_conf = lxc_conf_init();
-	if (!c->lxc_unexp_conf) {
-		c->lxc_unexp_conf = lxc_conf_init();
-		if (c->lxc_unexp_conf)
-			c->lxc_unexp_conf->unexpanded = true;
-	}
-	if (c->lxc_conf && c->lxc_unexp_conf &&
-			!lxc_config_read(fname, c->lxc_conf,
-					 c->lxc_unexp_conf))
+	if (!c->lxc_conf)
+		return false;
+	if (!lxc_config_read(fname, c->lxc_conf, false))
 		return true;
 	return false;
 }
@@ -1214,10 +1205,6 @@ static void lxcapi_clear_config(struct lxc_container *c)
 			lxc_conf_free(c->lxc_conf);
 			c->lxc_conf = NULL;
 		}
-		if (c->lxc_unexp_conf) {
-			lxc_conf_free(c->lxc_unexp_conf);
-			c->lxc_unexp_conf = NULL;
-		}
 	}
 }
 
@@ -1342,7 +1329,6 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	/* reload config to get the rootfs */
 	lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
-	c->lxc_unexp_conf = NULL;
 	if (!load_config_locked(c, c->configfile))
 		goto out_unlock;
 
@@ -1440,6 +1426,20 @@ out:
 	return bret;
 }
 
+static void do_clear_unexp_config_line(struct lxc_conf *conf, const char *key)
+{
+	if (strcmp(key, "lxc.cgroup") == 0)
+		clear_unexp_config_line(conf, key, true);
+	else if (strcmp(key, "lxc.network") == 0)
+		clear_unexp_config_line(conf, key, true);
+	else if (strcmp(key, "lxc.hook") == 0)
+		clear_unexp_config_line(conf, key, true);
+	else
+		clear_unexp_config_line(conf, key, false);
+	if (!do_append_unexp_config_line(conf, key, ""))
+		WARN("Error clearing configuration for %s", key);
+}
+
 static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 {
 	int ret;
@@ -1449,6 +1449,8 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	if (container_mem_lock(c))
 		return false;
 	ret = lxc_clear_config_item(c->lxc_conf, key);
+	if (!ret)
+		do_clear_unexp_config_line(c->lxc_conf, key);
 	container_mem_unlock(c);
 	return ret == 0;
 }
@@ -1867,7 +1869,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	fout = fopen(alt_file, "w");
 	if (!fout)
 		goto out;
-	write_config(fout, c->lxc_unexp_conf);
+	write_config(fout, c->lxc_conf);
 	fclose(fout);
 	ret = true;
 
@@ -2140,26 +2142,20 @@ static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
 	return lxcapi_destroy(c);
 }
 
-
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
 {
 	struct lxc_config_t *config;
 
 	if (!c->lxc_conf)
 		c->lxc_conf = lxc_conf_init();
-	if (!c->lxc_unexp_conf) {
-		c->lxc_unexp_conf = lxc_conf_init();
-		if (c->lxc_unexp_conf)
-			c->lxc_unexp_conf->unexpanded = true;
-	}
-	if (!c->lxc_conf || !c->lxc_unexp_conf)
+	if (!c->lxc_conf)
 		return false;
 	config = lxc_getconfig(key);
 	if (!config)
 		return false;
-	if (config->cb(key, v, c->lxc_unexp_conf) != 0)
+	if (config->cb(key, v, c->lxc_conf) != 0)
 		return false;
-	return (0 == config->cb(key, v, c->lxc_conf));
+	return do_append_unexp_config_line(c->lxc_conf, key, v);
 }
 
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
@@ -2415,6 +2411,10 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 		}
 	}
 
+	if (!clone_update_unexp_hooks(c->lxc_conf)) {
+		ERROR("Error saving new hooks in clone");
+		return -1;
+	}
 	c->save_config(c, NULL);
 	return 0;
 }
@@ -2456,6 +2456,8 @@ static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
 	if (!oldpath)
 		return 0;
 
+	clear_unexp_config_line(c->lxc_conf, "lxc.mount", false);
+
 	char *p = strrchr(oldpath, '/');
 	if (!p)
 		return -1;
@@ -2480,6 +2482,10 @@ static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
 		ERROR("error: allocating pathname");
 		return -1;
 	}
+	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.mount", newpath)) {
+		ERROR("error saving new lxctab");
+		return -1;
+	}
 
 	return 0;
 }
@@ -2549,10 +2555,10 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		ERROR("Out of memory while setting storage path");
 		return -1;
 	}
-	free(c->lxc_unexp_conf->rootfs.path);
-	c->lxc_unexp_conf->rootfs.path = strdup(c->lxc_conf->rootfs.path);
-	if (!c->lxc_unexp_conf->rootfs.path) {
-		ERROR("Out of memory while setting storage path");
+	// We will simply append a new lxc.rootfs entry to the unexpanded config
+	clear_unexp_config_line(c->lxc_conf, "lxc.rootfs", false);
+	if (!do_append_unexp_config_line(c->lxc_conf, "lxc.rootfs", c->lxc_conf->rootfs.path)) {
+		ERROR("Error saving new rootfs to cloend config");
 		return -1;
 	}
 	if (flags & LXC_CLONE_SNAPSHOT)
@@ -2765,7 +2771,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		SYSERROR("open %s", newpath);
 		goto out;
 	}
-	write_config(fout, c->lxc_unexp_conf);
+	write_config(fout, c->lxc_conf);
 	fclose(fout);
 	c->lxc_conf->rootfs.path = origroot;
 
@@ -2793,6 +2799,8 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (ret < 0)
 		goto out;
 
+	clear_unexp_config_line(c2->lxc_conf, "lxc.utsname", false);
+
 	// update utsname
 	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
 		ERROR("Error setting new hostname");
@@ -2812,8 +2820,13 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	}
 
 	// update macaddrs
-	if (!(flags & LXC_CLONE_KEEPMACADDR))
+	if (!(flags & LXC_CLONE_KEEPMACADDR)) {
 		network_new_hwaddrs(c2);
+		if (!clone_update_unexp_network(c2->lxc_conf)) {
+			ERROR("Error updating network for clone");
+			goto out;
+		}
+	}
 
 	// We've now successfully created c2's storage, so clear it out if we
 	// fail after this

commit 97e9cfa02ff30cbbc305e745559ab62ce90efd81
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jul 29 18:26:29 2014 +0000

    print a helpful message if creating unpriv container with no idmap
    
    This gives me:
    
    ubuntu@c-t1:~$ lxc-create -t download -n u1
    lxc_container: No mapping for container root
    lxc_container: Error chowning /home/ubuntu/.local/share/lxc/u1/rootfs to container root
    lxc_container: You must either run as root, or define uid mappings
    lxc_container: To pass uid mappings to lxc-create, you could create
    lxc_container: ~/.config/lxc/default.conf:
    lxc_container: lxc.include = /etc/lxc/default.conf
    lxc_container: lxc.id_map = u 0 100000 65536
    lxc_container: lxc.id_map = g 0 100000 65536
    lxc_container: Error creating backing store type (none) for u1
    lxc_container: Error creating container u1
    
    when I create a container without having an id mapping defined.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 103309c..ca5da87 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -813,6 +813,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	if (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {
 		if (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {
 			ERROR("Error chowning %s to container root", bdev->dest);
+			suggest_default_idmap();
 			bdev_put(bdev);
 			return NULL;
 		}

commit d4ef230cc9b86343b1f69d5e23711f3626305873
Author: Rodrigo Vaz <rodrigo@heroku.com>
Date:   Thu Jul 3 15:39:51 2014 -0300

    make the container exit code propagate to lxc-start exit code when appropriate
    
    Signed-off-by: Rodrigo Sampaio Vaz <rodrigo@heroku.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b8eacc1..103309c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -673,6 +673,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 reboot:
 	conf->reboot = 0;
 	ret = lxc_start(c->name, argv, conf, c->config_path);
+	c->error_num = ret;
 
 	if (conf->reboot) {
 		INFO("container requested reboot");

commit 513e1502c824e7705a1f9af73be0b58ec6fd0153
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jun 23 08:41:49 2014 -0500

    coverity: avoid possible null deref
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3d1cf34..b8eacc1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2147,7 +2147,8 @@ static bool set_config_item_locked(struct lxc_container *c, const char *key, con
 		c->lxc_conf = lxc_conf_init();
 	if (!c->lxc_unexp_conf) {
 		c->lxc_unexp_conf = lxc_conf_init();
-		c->lxc_unexp_conf->unexpanded = true;
+		if (c->lxc_unexp_conf)
+			c->lxc_unexp_conf->unexpanded = true;
 	}
 	if (!c->lxc_conf || !c->lxc_unexp_conf)
 		return false;

commit d021832111871f46bbce7edb0806944b4247b5d0
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jun 18 18:01:50 2014 -0500

    clone: make sure to update the rootfs path in unexpanded conf
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 20bf600..3d1cf34 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2546,6 +2546,12 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		ERROR("Out of memory while setting storage path");
 		return -1;
 	}
+	free(c->lxc_unexp_conf->rootfs.path);
+	c->lxc_unexp_conf->rootfs.path = strdup(c->lxc_conf->rootfs.path);
+	if (!c->lxc_unexp_conf->rootfs.path) {
+		ERROR("Out of memory while setting storage path");
+		return -1;
+	}
 	if (flags & LXC_CLONE_SNAPSHOT)
 		copy_rdepends(c, c0);
 	if (need_rdep) {

commit 18aa217bb187b551206fe66075229ba382a1dbe4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 27 16:24:06 2014 -0500

    snapshots: move snapshot directory
    
    Originally we kept snapshots under /var/lib/lxcsnaps.  If a
    separate btrfs is mounted at /var/lib/lxc, then we can't
    make btrfs snapshots under /var/lib/lxcsnaps.
    
    This patch moves the default directory to /var/lib/lxc/c/snaps.
    If /var/lib/lxcsnaps already exists, then we continue to use that.
    
    add c->destroy_with_snapshots() and c->snapshot_destroy_all()
    API methods.  c->snashot_destroy_all() can be triggered from
    lxc-snapshot using '-d ALL'.  There is no command to call
    c->destroy_with_snapshots(c) as of yet.
    
    lxclock: use ".$lxcname" for container lock files
    that way we can use /run/lock/lxc/$lxcpath/$lxcname/snaps as a
    directory when locking snapshots without having to worry about
    /run/lock//lxc/$lxcpath/$lxcname being a file.
    
    destroy: split off a container_destroy
    container_destroy() doesn't check for snapshots, so snapshot_rename can
    use it.  api_destroy() now does check for snapshots (previously it only
    checked for fs - i.e. overlayfs/aufs - snapshots).
    
    Add destroy to the manpage, as it was previously undocumented.
    
    Update snapshot testcase accordingly.
    
    [ rebased in the face of commits 840f05df and 7e36f87e. ]
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index bb7b4bb..20bf600 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1220,6 +1220,8 @@ static void lxcapi_clear_config(struct lxc_container *c)
 }
 
 static bool lxcapi_destroy(struct lxc_container *c);
+static bool container_destroy(struct lxc_container *c);
+static bool get_snappath_dir(struct lxc_container *c, char *snappath);
 /*
  * lxcapi_create:
  * create a container with the given parameters.
@@ -1362,7 +1364,7 @@ out_unlock:
 		remove_partial(c, partial_fd);
 out:
 	if (!ret && c)
-		lxcapi_destroy(c);
+		container_destroy(c);
 free_tpath:
 	if (tpath)
 		free(tpath);
@@ -1968,7 +1970,7 @@ out:
 	fclose(f);
 }
 
-static bool has_snapshots(struct lxc_container *c)
+static bool has_fs_snapshots(struct lxc_container *c)
 {
 	char path[MAXPATHLEN];
 	int ret, v;
@@ -1992,10 +1994,38 @@ out:
 	return bret;
 }
 
+static bool has_snapshots(struct lxc_container *c)
+{
+	char path[MAXPATHLEN];
+	struct dirent dirent, *direntp;
+	int count=0;
+	DIR *dir;
+
+	if (!get_snappath_dir(c, path))
+		return false;
+	dir = opendir(path);
+	if (!dir)
+		return false;
+	while (!readdir_r(dir, &dirent, &direntp)) {
+		if (!direntp)
+			break;
+
+		if (!strcmp(direntp->d_name, "."))
+			continue;
+
+		if (!strcmp(direntp->d_name, ".."))
+			continue;
+		count++;
+		break;
+	}
+	closedir(dir);
+	return count > 0;
+}
+
 static int lxc_rmdir_onedev_wrapper(void *data)
 {
 	char *arg = (char *) data;
-	return lxc_rmdir_onedev(arg);
+	return lxc_rmdir_onedev(arg, "snaps");
 }
 
 static int do_bdev_destroy(struct lxc_conf *conf)
@@ -2030,8 +2060,7 @@ static int bdev_destroy_wrapper(void *data)
 	return do_bdev_destroy(conf);
 }
 
-// do we want the api to support --force, or leave that to the caller?
-static bool lxcapi_destroy(struct lxc_container *c)
+static bool container_destroy(struct lxc_container *c)
 {
 	bool bret = false;
 	int ret;
@@ -2048,11 +2077,6 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (c->lxc_conf && has_snapshots(c)) {
-		ERROR("container %s has dependent snapshots", c->name);
-		goto out;
-	}
-
 	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
 		if (am_unpriv())
 			ret = userns_exec_1(c->lxc_conf, bdev_destroy_wrapper, c->lxc_conf);
@@ -2072,7 +2096,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	if (am_unpriv())
 		ret = userns_exec_1(c->lxc_conf, lxc_rmdir_onedev_wrapper, path);
 	else
-		ret = lxc_rmdir_onedev(path);
+		ret = lxc_rmdir_onedev(path, "snaps");
 	if (ret < 0) {
 		ERROR("Error destroying container directory for %s", c->name);
 		goto out;
@@ -2084,6 +2108,37 @@ out:
 	return bret;
 }
 
+static bool lxcapi_destroy(struct lxc_container *c)
+{
+	if (!c || !lxcapi_is_defined(c))
+		return false;
+	if (has_snapshots(c)) {
+		ERROR("Container %s has snapshots;  not removing", c->name);
+		return false;
+	}
+
+	if (has_fs_snapshots(c)) {
+		ERROR("container %s has snapshots on its rootfs", c->name);
+		return false;
+	}
+
+	return container_destroy(c);
+}
+
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c);
+
+static bool lxcapi_destroy_with_snapshots(struct lxc_container *c)
+{
+	if (!c || !lxcapi_is_defined(c))
+		return false;
+	if (!lxcapi_snapshot_destroy_all(c)) {
+		ERROR("Error deleting all snapshots");
+		return false;
+	}
+	return lxcapi_destroy(c);
+}
+
+
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
 {
 	struct lxc_config_t *config;
@@ -2804,6 +2859,10 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	if (!c || !c->name || !c->config_path || !c->lxc_conf)
 		return false;
 
+	if (has_fs_snapshots(c) || has_snapshots(c)) {
+		ERROR("Renaming a container with snapshots is not supported");
+		return false;
+	}
 	bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -2820,7 +2879,7 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	if (newc && lxcapi_is_defined(newc))
 		lxc_container_put(newc);
 
-	if (!lxcapi_destroy(c)) {
+	if (!container_destroy(c)) {
 		ERROR("Could not destroy existing container %s", c->name);
 		return false;
 	}
@@ -2870,6 +2929,33 @@ static int get_next_index(const char *lxcpath, char *cname)
 	}
 }
 
+static bool get_snappath_dir(struct lxc_container *c, char *snappath)
+{
+	int ret;
+	/*
+	 * If the old style snapshot path exists, use it
+	 * /var/lib/lxc -> /var/lib/lxcsnaps
+	 */
+	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps", c->config_path);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+	if (dir_exists(snappath)) {
+		ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			return false;
+		return true;
+	}
+
+	/*
+	 * Use the new style path
+	 * /var/lib/lxc -> /var/lib/lxc + c->name + /snaps + \0
+	 */
+	ret = snprintf(snappath, MAXPATHLEN, "%s/%s/snaps", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+	return true;
+}
+
 static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
@@ -2879,10 +2965,9 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
-	// /var/lib/lxc -> /var/lib/lxcsnaps \0
-	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN)
+	if (!get_snappath_dir(c, snappath))
 		return -1;
+
 	i = get_next_index(snappath, c->name);
 
 	if (mkdir_p(snappath, 0755) < 0) {
@@ -3016,7 +3101,7 @@ static char *get_timestamp(char* snappath, char *name)
 static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
-	int dirlen, count = 0, ret;
+	int count = 0, ret;
 	struct dirent dirent, *direntp;
 	struct lxc_snapshot *snaps =NULL, *nsnaps;
 	DIR *dir;
@@ -3024,9 +3109,7 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
-	// snappath is ${lxcpath}snaps/${lxcname}/
-	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
+	if (!get_snappath_dir(c, snappath)) {
 		ERROR("path name too long");
 		return -1;
 	}
@@ -3094,7 +3177,7 @@ out_free:
 static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
-	int flags = 0,ret;
+	int flags = 0;
 	struct lxc_container *snap, *rest;
 	struct bdev *bdev;
 	bool b = false;
@@ -3102,6 +3185,11 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
+	if (has_fs_snapshots(c)) {
+		ERROR("container rootfs has dependent snapshots");
+		return false;
+	}
+
 	bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -3111,8 +3199,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	if (!newname)
 		newname = c->name;
 
-	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN) {
+	if (!get_snappath_dir(c, clonelxcpath)) {
 		bdev_put(bdev);
 		return false;
 	}
@@ -3127,7 +3214,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	}
 
 	if (strcmp(c->name, newname) == 0) {
-		if (!lxcapi_destroy(c)) {
+		if (!container_destroy(c)) {
 			ERROR("Could not destroy existing container %s", newname);
 			lxc_container_put(snap);
 			bdev_put(bdev);
@@ -3148,21 +3235,13 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	return b;
 }
 
-static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
+static bool do_snapshot_destroy(const char *snapname, const char *clonelxcpath)
 {
-	int ret;
-	char clonelxcpath[MAXPATHLEN];
 	struct lxc_container *snap = NULL;
-
-	if (!c || !c->name || !c->config_path)
-		return false;
-
-	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		goto err;
+	bool bret = false;
 
 	snap = lxc_container_new(snapname, clonelxcpath);
-	if (!snap || !lxcapi_is_defined(snap)) {
+	if (!snap) {
 		ERROR("Could not find snapshot %s", snapname);
 		goto err;
 	}
@@ -3171,13 +3250,70 @@ static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapnam
 		ERROR("Could not destroy snapshot %s", snapname);
 		goto err;
 	}
-	lxc_container_put(snap);
+	bret = true;
 
-	return true;
 err:
 	if (snap)
 		lxc_container_put(snap);
-	return false;
+	return bret;
+}
+
+static bool remove_all_snapshots(const char *path)
+{
+	DIR *dir;
+	struct dirent dirent, *direntp;
+	bool bret = true;
+
+	dir = opendir(path);
+	if (!dir) {
+		SYSERROR("opendir on snapshot path %s", path);
+		return false;
+	}
+	while (!readdir_r(dir, &dirent, &direntp)) {
+		if (!direntp)
+			break;
+		if (!strcmp(direntp->d_name, "."))
+			continue;
+		if (!strcmp(direntp->d_name, ".."))
+			continue;
+		if (!do_snapshot_destroy(direntp->d_name, path)) {
+			bret = false;
+			continue;
+		}
+	}
+
+	closedir(dir);
+
+	if (rmdir(path))
+		SYSERROR("Error removing directory %s", path);
+
+	return bret;
+}
+
+static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
+{
+	char clonelxcpath[MAXPATHLEN];
+
+	if (!c || !c->name || !c->config_path || !snapname)
+		return false;
+
+	if (!get_snappath_dir(c, clonelxcpath))
+		return false;
+
+	return do_snapshot_destroy(snapname, clonelxcpath);
+}
+
+static bool lxcapi_snapshot_destroy_all(struct lxc_container *c)
+{
+	char clonelxcpath[MAXPATHLEN];
+
+	if (!c || !c->name || !c->config_path)
+		return false;
+
+	if (!get_snappath_dir(c, clonelxcpath))
+		return false;
+
+	return remove_all_snapshots(clonelxcpath);
 }
 
 static bool lxcapi_may_control(struct lxc_container *c)
@@ -3337,6 +3473,9 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 {
 	struct lxc_container *c;
 
+	if (!name)
+		return NULL;
+
 	c = malloc(sizeof(*c));
 	if (!c) {
 		fprintf(stderr, "failed to malloc lxc_container\n");
@@ -3383,7 +3522,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 
 	if (ongoing_create(c) == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
-		lxcapi_destroy(c);
+		container_destroy(c);
 		lxcapi_clear_config(c);
 	}
 	c->daemonize = true;
@@ -3408,6 +3547,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->wait = lxcapi_wait;
 	c->set_config_item = lxcapi_set_config_item;
 	c->destroy = lxcapi_destroy;
+	c->destroy_with_snapshots = lxcapi_destroy_with_snapshots;
 	c->rename = lxcapi_rename;
 	c->save_config = lxcapi_save_config;
 	c->get_keys = lxcapi_get_keys;
@@ -3433,6 +3573,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->snapshot_list = lxcapi_snapshot_list;
 	c->snapshot_restore = lxcapi_snapshot_restore;
 	c->snapshot_destroy = lxcapi_snapshot_destroy;
+	c->snapshot_destroy_all = lxcapi_snapshot_destroy_all;
 	c->may_control = lxcapi_may_control;
 	c->add_device_node = lxcapi_add_device_node;
 	c->remove_device_node = lxcapi_remove_device_node;

commit f979ac15923809df97d9b7b16a1411d20f386777
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Jun 12 14:24:38 2014 +0000

    Add a unexpanded lxc_conf
    
    Currently when a container's configuration file has lxc.includes,
    any future write_config() will expand the lxc.includes.  This
    affects container clones (and snapshots) as well as users of the
    API who make an update and then c.save_config().
    
    To fix this, separately track the expanded and unexpanded lxc_conf.  The
    unexpanded conf does not contain values read from lxc.includes.  The
    expanded conf does.  Lxc functions mainly need the expanded conf to
    figure out how to configure the container.  The unexpanded conf is used
    at write_config().
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5cedb27..bb7b4bb 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -238,6 +238,10 @@ static void lxc_container_free(struct lxc_container *c)
 		lxc_conf_free(c->lxc_conf);
 		c->lxc_conf = NULL;
 	}
+	if (c->lxc_unexp_conf) {
+		lxc_conf_free(c->lxc_unexp_conf);
+		c->lxc_unexp_conf = NULL;
+	}
 	if (c->config_path) {
 		free(c->config_path);
 		c->config_path = NULL;
@@ -410,7 +414,14 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
 		c->lxc_conf = lxc_conf_init();
-	if (c->lxc_conf && !lxc_config_read(fname, c->lxc_conf))
+	if (!c->lxc_unexp_conf) {
+		c->lxc_unexp_conf = lxc_conf_init();
+		if (c->lxc_unexp_conf)
+			c->lxc_unexp_conf->unexpanded = true;
+	}
+	if (c->lxc_conf && c->lxc_unexp_conf &&
+			!lxc_config_read(fname, c->lxc_conf,
+					 c->lxc_unexp_conf))
 		return true;
 	return false;
 }
@@ -1196,9 +1207,15 @@ out_error:
 
 static void lxcapi_clear_config(struct lxc_container *c)
 {
-	if (c && c->lxc_conf) {
-		lxc_conf_free(c->lxc_conf);
-		c->lxc_conf = NULL;
+	if (c) {
+		if (c->lxc_conf) {
+			lxc_conf_free(c->lxc_conf);
+			c->lxc_conf = NULL;
+		}
+		if (c->lxc_unexp_conf) {
+			lxc_conf_free(c->lxc_unexp_conf);
+			c->lxc_unexp_conf = NULL;
+		}
 	}
 }
 
@@ -1321,6 +1338,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	/* reload config to get the rootfs */
 	lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
+	c->lxc_unexp_conf = NULL;
 	if (!load_config_locked(c, c->configfile))
 		goto out_unlock;
 
@@ -1845,7 +1863,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	fout = fopen(alt_file, "w");
 	if (!fout)
 		goto out;
-	write_config(fout, c->lxc_conf);
+	write_config(fout, c->lxc_unexp_conf);
 	fclose(fout);
 	ret = true;
 
@@ -2072,11 +2090,17 @@ static bool set_config_item_locked(struct lxc_container *c, const char *key, con
 
 	if (!c->lxc_conf)
 		c->lxc_conf = lxc_conf_init();
-	if (!c->lxc_conf)
+	if (!c->lxc_unexp_conf) {
+		c->lxc_unexp_conf = lxc_conf_init();
+		c->lxc_unexp_conf->unexpanded = true;
+	}
+	if (!c->lxc_conf || !c->lxc_unexp_conf)
 		return false;
 	config = lxc_getconfig(key);
 	if (!config)
 		return false;
+	if (config->cb(key, v, c->lxc_unexp_conf) != 0)
+		return false;
 	return (0 == config->cb(key, v, c->lxc_conf));
 }
 
@@ -2677,7 +2701,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		SYSERROR("open %s", newpath);
 		goto out;
 	}
-	write_config(fout, c->lxc_conf);
+	write_config(fout, c->lxc_unexp_conf);
 	fclose(fout);
 	c->lxc_conf->rootfs.path = origroot;
 

commit 840f05df8ad3bb43e231c7ae9f8fbd7236469924
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jun 3 13:16:03 2014 -0500

    lxcapi_snapshot: check that c is defined
    
    before using it, like the other snapshot api methods do.
    
    This will need to go into stable-1.0 as well.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ac6de62..5cedb27 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2852,6 +2852,9 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	struct lxc_container *c2;
 	char snappath[MAXPATHLEN], newname[20];
 
+	if (!c || !lxcapi_is_defined(c))
+		return -1;
+
 	// /var/lib/lxc -> /var/lib/lxcsnaps \0
 	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)

commit 0520c252da5d99b611594b80aac810cb29895dc8
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue May 27 15:30:10 2014 -0400

    point user to updated man page in template boilerplate
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8e611c7..ac6de62 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1170,7 +1170,7 @@ static bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		fprintf(f, "%02x", md_value[i]);
 	fprintf(f, "\n");
 #endif
-	fprintf(f, "# For additional config options, please look at lxc.conf(5)\n");
+	fprintf(f, "# For additional config options, please look at lxc.container.conf(5)\n");
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");
 		free(contents);

commit 7e36f87e2560ede94f171f14b6be1cfd5498c0d6
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat May 24 22:19:06 2014 -0400

    destroy the original container after making sure the snapshot exists (fixes #224)
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fdac433..8e611c7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3083,13 +3083,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 
 	if (!newname)
 		newname = c->name;
-	if (strcmp(c->name, newname) == 0) {
-		if (!lxcapi_destroy(c)) {
-			ERROR("Could not destroy existing container %s", newname);
-			bdev_put(bdev);
-			return false;
-		}
-	}
+
 	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN) {
 		bdev_put(bdev);
@@ -3105,6 +3099,15 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 		return false;
 	}
 
+	if (strcmp(c->name, newname) == 0) {
+		if (!lxcapi_destroy(c)) {
+			ERROR("Could not destroy existing container %s", newname);
+			lxc_container_put(snap);
+			bdev_put(bdev);
+			return false;
+		}
+	}
+
 	if (strcmp(bdev->type, "dir") != 0 && strcmp(bdev->type, "loop") != 0)
 		flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
 	rest = lxcapi_clone(snap, newname, c->config_path, flags,

commit 76a26f559ff2d9d47b2c886310e8e8c95af2c667
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu May 15 14:33:18 2014 +0000

    add support for nbd
    
    backing stores supported by qemu-nbd can be attached to a nbd block
    device using qemu-nbd.  This user-space process (pair) stays around for
    the duration of the device attachment.  Obviously we want it to go away
    when the container shuts down, but not before the filesystems have been
    cleanly unmounted.
    
    The device attachment is done from the task which will become the
    container monitor before the container setup+init task is spawned.
    That task starts in a new pid namespace to ensure that the qemu-nbd
    process will be killed if need be.  It sets its parent death signal
    to sighup, and, on receiving sighup, attempts to do a clean
    qemu-device detach, then exits.  This should ensure that the
    device is detached if the qemu monitor crashes or exits.
    
    It may be worth adding a delay before the qemu-nbd is detached, but
    my brief tests haven't seen any data corruption.
    
    Only the parts required for running a nbd-backed container are
    implemented here.  Create, destroy, and clone are not.  The first
    use of this that I imagine is for people to use downloaded nbd-backed
    images (like ubuntu cloud images, or anything previously used with
    qemu).  I imagine people will want to create/clone/destroy out of
    band using qemu-img, but if I'm wrong about that we can implement
    the rest later.
    
    Because attach_block_device() is done before the bdev is initialized,
    and bdev_init needs to know the nbd index so that it can mount the
    filesystem, we now need to pass the lxc_conf.
    
    file_exists() is moved to utils.c so we can use it from bdev.c
    
    The nbd attach/detach should lay the groundwork for trivial implementation
    of qed and raw images.
    
    changelog (may 12): fix idx check at detach
    changelog (may 15): generalize qcow2 to nbd
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 255fde5..fdac433 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -82,13 +82,6 @@ return -1;
 
 lxc_log_define(lxc_container, lxc);
 
-static bool file_exists(const char *f)
-{
-	struct stat statbuf;
-
-	return stat(f, &statbuf) == 0;
-}
-
 static bool config_file_exists(const char *lxcpath, const char *cname)
 {
 	/* $lxcpath + '/' + $cname + '/config' + \0 */
@@ -900,7 +893,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		if (strncmp(src, "aufs:", 5) == 0)
 			src = overlay_getlower(src+5);
 
-		bdev = bdev_init(src, c->lxc_conf->rootfs.mount, NULL);
+		bdev = bdev_init(c->lxc_conf, src, c->lxc_conf->rootfs.mount, NULL);
 		if (!bdev) {
 			ERROR("Error opening rootfs");
 			exit(1);
@@ -1992,7 +1985,7 @@ static int do_bdev_destroy(struct lxc_conf *conf)
 	struct bdev *r;
 	int ret = 0;
 
-	r = bdev_init(conf->rootfs.path, conf->rootfs.mount, NULL);
+	r = bdev_init(conf, conf->rootfs.path, conf->rootfs.mount, NULL);
 	if (!r)
 		return -1;
 
@@ -2522,7 +2515,7 @@ static int clone_update_rootfs(struct clone_update_data *data)
 
 	if (unshare(CLONE_NEWNS) < 0)
 		return -1;
-	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
 		return -1;
 	if (strcmp(bdev->type, "dir") != 0) {
@@ -2787,7 +2780,7 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	if (!c || !c->name || !c->config_path || !c->lxc_conf)
 		return false;
 
-	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
 		return false;
@@ -2880,7 +2873,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	 */
 	flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME |
 		LXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;
-	if (bdev_is_dir(c->lxc_conf->rootfs.path)) {
+	if (bdev_is_dir(c->lxc_conf, c->lxc_conf->rootfs.path)) {
 		ERROR("Snapshot of directory-backed container requested.");
 		ERROR("Making a copy-clone.  If you do want snapshots, then");
 		ERROR("please create an aufs or overlayfs clone first, snapshot that");
@@ -3082,7 +3075,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
-	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	bdev = bdev_init(c->lxc_conf, c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
 		return false;

commit 44a706bdaf1471dbddb05e10269a0d413d224ab5
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 6 21:43:19 2014 +0000

    btrfs: support unprivileged destroy
    
    Do this by calling the bdev->destroy() hook from a user namespace
    configured as the container's.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9e23c7b..255fde5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1987,10 +1987,41 @@ static int lxc_rmdir_onedev_wrapper(void *data)
 	return lxc_rmdir_onedev(arg);
 }
 
+static int do_bdev_destroy(struct lxc_conf *conf)
+{
+	struct bdev *r;
+	int ret = 0;
+
+	r = bdev_init(conf->rootfs.path, conf->rootfs.mount, NULL);
+	if (!r)
+		return -1;
+
+	if (r->ops->destroy(r) < 0)
+		ret = -1;
+	bdev_put(r);
+	return ret;
+}
+
+static int bdev_destroy_wrapper(void *data)
+{
+	struct lxc_conf *conf = data;
+
+	if (setgid(0) < 0) {
+		ERROR("Failed to setgid to 0");
+		return -1;
+	}
+	if (setgroups(0, NULL) < 0)
+		WARN("Failed to clear groups");
+	if (setuid(0) < 0) {
+		ERROR("Failed to setuid to 0");
+		return -1;
+	}
+	return do_bdev_destroy(conf);
+}
+
 // do we want the api to support --force, or leave that to the caller?
 static bool lxcapi_destroy(struct lxc_container *c)
 {
-	struct bdev *r = NULL;
 	bool bret = false;
 	int ret;
 
@@ -2011,15 +2042,14 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (!am_unpriv() && c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
-		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
-		if (r) {
-			if (r->ops->destroy(r) < 0) {
-				bdev_put(r);
-				ERROR("Error destroying rootfs for %s", c->name);
-				goto out;
-			}
-			bdev_put(r);
+	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
+		if (am_unpriv())
+			ret = userns_exec_1(c->lxc_conf, bdev_destroy_wrapper, c->lxc_conf);
+		else
+			ret = do_bdev_destroy(c->lxc_conf);
+		if (ret < 0) {
+			ERROR("Error destroying rootfs for %s", c->name);
+			goto out;
 		}
 	}
 

commit 2659c7cbd55beee72b9b1740f48f48ad9d7d89da
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 6 20:50:45 2014 +0000

    btrfs: support unprivileged create and clone
    
    btrfs subvolume ioctls are usable by unprivileged users, so allow
    unprivileged containers to reside on btrfs.
    
    This patch does not yet enable destroy.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 270b8fc..9e23c7b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -918,9 +918,9 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 				}
 			}
 		}
-		if (strcmp(bdev->type, "dir") != 0) {
+		if (strcmp(bdev->type, "dir") && strcmp(bdev->type, "btrfs")) {
 			if (geteuid() != 0) {
-				ERROR("non-root users can only create directory-backed containers");
+				ERROR("non-root users can only create btrfs and directory-backed containers");
 				exit(1);
 			}
 			if (bdev->ops->mount(bdev) < 0) {

commit 13aad0ae78b39a481f4c3f465a525264747cc92a
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Apr 30 12:15:06 2014 -0400

    clang: Fix build warnings for 3.4
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c90b564..270b8fc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -555,7 +555,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	FILE *pid_fp = NULL;
 	char *default_args[] = {
 		"/sbin/init",
-		'\0',
+		NULL,
 	};
 
 	/* container exists */

commit f79b86a34452a004e4014893da058cd049db94cc
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Apr 28 17:33:36 2014 -0500

    Revert "snapshots: move snapshot directory"
    
    This reverts commit 276a086264a0fc1703128578d38c0574127a1c2f.
    
    It breaks lxc-test-snapshot, and perhaps we should go with
    stgraber's suggestion of using $lxcpath/$lxcname/snaps/

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1059961..c90b564 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2823,42 +2823,16 @@ static int get_next_index(const char *lxcpath, char *cname)
 	}
 }
 
-static bool get_snappath_dir(struct lxc_container *c, char *snappath)
-{
-	int ret;
-	/*
-	 * If the old style snapshot path exists, use it
-	 * /var/lib/lxc -> /var/lib/lxcsnaps
-	 */
-	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps", c->config_path);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		return false;
-	if (dir_exists(snappath)) {
-		ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-		if (ret < 0 || ret >= MAXPATHLEN)
-			return false;
-		return true;
-	}
-
-	/*
-	 * Use the new style path
-	 * /var/lib/lxc -> /var/lib/lxc + /lxcsnaps/ + c->name + \0
-	 */
-	ret = snprintf(snappath, MAXPATHLEN, "%s/lxcsnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		return false;
-	return true;
-}
-
 static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
 	char snappath[MAXPATHLEN], newname[20];
 
-	if (!get_snappath_dir(c, snappath)) {
+	// /var/lib/lxc -> /var/lib/lxcsnaps \0
+	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
 		return -1;
-	}
 	i = get_next_index(snappath, c->name);
 
 	if (mkdir_p(snappath, 0755) < 0) {
@@ -2992,7 +2966,7 @@ static char *get_timestamp(char* snappath, char *name)
 static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
-	int count = 0, ret;
+	int dirlen, count = 0, ret;
 	struct dirent dirent, *direntp;
 	struct lxc_snapshot *snaps =NULL, *nsnaps;
 	DIR *dir;
@@ -3000,7 +2974,9 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
-	if (!get_snappath_dir(c, snappath)) {
+	// snappath is ${lxcpath}snaps/${lxcname}/
+	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
 		ERROR("path name too long");
 		return -1;
 	}
@@ -3068,7 +3044,7 @@ out_free:
 static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
-	int flags = 0;
+	int flags = 0,ret;
 	struct lxc_container *snap, *rest;
 	struct bdev *bdev;
 	bool b = false;
@@ -3091,7 +3067,8 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 			return false;
 		}
 	}
-	if (!get_snappath_dir(c, clonelxcpath)) {
+	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN) {
 		bdev_put(bdev);
 		return false;
 	}
@@ -3307,12 +3284,6 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 {
 	struct lxc_container *c;
 
-	if (!name)
-		return NULL;
-
-	if (strcmp(name, "lxcsnaps") == 0)
-		return NULL;
-
 	c = malloc(sizeof(*c));
 	if (!c) {
 		fprintf(stderr, "failed to malloc lxc_container\n");

commit 276a086264a0fc1703128578d38c0574127a1c2f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Apr 16 14:04:45 2014 -0500

    snapshots: move snapshot directory
    
    Originally we kept snapshots under /var/lib/lxcsnaps.  If a
    separate btrfs is mounted at /var/lib/lxc, then we can't
    make btrfs snapshots under /var/lib/lxcsnaps.
    
    This patch moves the default directory to /var/lib/lxc/lxcsnaps.
    If /var/lib/lxcsnaps already exists, then use that.  Don't allow
    any container to be used with the name 'lxcsnaps'.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c90b564..1059961 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2823,16 +2823,42 @@ static int get_next_index(const char *lxcpath, char *cname)
 	}
 }
 
+static bool get_snappath_dir(struct lxc_container *c, char *snappath)
+{
+	int ret;
+	/*
+	 * If the old style snapshot path exists, use it
+	 * /var/lib/lxc -> /var/lib/lxcsnaps
+	 */
+	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps", c->config_path);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+	if (dir_exists(snappath)) {
+		ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			return false;
+		return true;
+	}
+
+	/*
+	 * Use the new style path
+	 * /var/lib/lxc -> /var/lib/lxc + /lxcsnaps/ + c->name + \0
+	 */
+	ret = snprintf(snappath, MAXPATHLEN, "%s/lxcsnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+	return true;
+}
+
 static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
 	char snappath[MAXPATHLEN], newname[20];
 
-	// /var/lib/lxc -> /var/lib/lxcsnaps \0
-	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN)
+	if (!get_snappath_dir(c, snappath)) {
 		return -1;
+	}
 	i = get_next_index(snappath, c->name);
 
 	if (mkdir_p(snappath, 0755) < 0) {
@@ -2966,7 +2992,7 @@ static char *get_timestamp(char* snappath, char *name)
 static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
 {
 	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
-	int dirlen, count = 0, ret;
+	int count = 0, ret;
 	struct dirent dirent, *direntp;
 	struct lxc_snapshot *snaps =NULL, *nsnaps;
 	DIR *dir;
@@ -2974,9 +3000,7 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
-	// snappath is ${lxcpath}snaps/${lxcname}/
-	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
+	if (!get_snappath_dir(c, snappath)) {
 		ERROR("path name too long");
 		return -1;
 	}
@@ -3044,7 +3068,7 @@ out_free:
 static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
-	int flags = 0,ret;
+	int flags = 0;
 	struct lxc_container *snap, *rest;
 	struct bdev *bdev;
 	bool b = false;
@@ -3067,8 +3091,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 			return false;
 		}
 	}
-	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
-	if (ret < 0 || ret >= MAXPATHLEN) {
+	if (!get_snappath_dir(c, clonelxcpath)) {
 		bdev_put(bdev);
 		return false;
 	}
@@ -3284,6 +3307,12 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 {
 	struct lxc_container *c;
 
+	if (!name)
+		return NULL;
+
+	if (strcmp(name, "lxcsnaps") == 0)
+		return NULL;
+
 	c = malloc(sizeof(*c));
 	if (!c) {
 		fprintf(stderr, "failed to malloc lxc_container\n");

commit de269ee8dec1cf2d882de385f8dd6591e97121e2
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Mar 4 14:54:04 2014 -0600

    snapshot: fix overlayfs restore
    
    And add a testcase to catch regressions.
    
    Without this patch, restoring a snapshot of an overlayfs based
    container fails, because we do not pass in LXC_CLONE_SNAPSHOT,
    and overlayfs does not support clone without snapshot.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b7adebe..c90b564 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3044,7 +3044,7 @@ out_free:
 static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
-	int ret;
+	int flags = 0,ret;
 	struct lxc_container *snap, *rest;
 	struct bdev *bdev;
 	bool b = false;
@@ -3082,7 +3082,10 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 		return false;
 	}
 
-	rest = lxcapi_clone(snap, newname, c->config_path, 0, bdev->type, NULL, 0, NULL);
+	if (strcmp(bdev->type, "dir") != 0 && strcmp(bdev->type, "loop") != 0)
+		flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
+	rest = lxcapi_clone(snap, newname, c->config_path, flags,
+			bdev->type, NULL, 0, NULL);
 	bdev_put(bdev);
 	if (rest && lxcapi_is_defined(rest))
 		b = true;

commit 7e4dfe0bc1e715ccebca930939429aca25a17655
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Mar 3 16:39:00 2014 -0600

    cgmanager updates
    
    1. remove the cgm_dbus_disconnected handler.  We're using a proxy
       anyway, and not keeping it around.
    
    2. comment most of the cgm functions to describe when they are called, to
       ease locking review
    
    3. the cgmanager mutex is now held for the duration of a connection, from
       cgm_dbus_connect to cgm_dbus_disconnect.
    
    3b. so remove the mutex lock/unlock from functions which are called during
       container startup with the cgmanager connection already up
    
    4. remove the cgroup_restart().  It's no longer needed since we don't
       daemonize while we have the cgmanager socket open.
    
    5. report errors and return early if cgm_dbus_connect() fails
    
    6. don't keep the cgm connection open after cgm_ops_init.  I'm a bit torn
       on this one as it means that things like lxc-start will always connect
       twice.  But if we do this there is no good answer, given threaded API
       users, on when to drop that initial connection.
    
    7. cgm_unfreeze and nrtasks: grab the dbus connection, as we'll never
       have it at that point.  (technically i doubt anyone will use
       cgmanager and utmp helper on the same host :)
    
    8. lxc_spawn: make sure we only disconnect cgroups if they were already
       connected.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b0ae44b..b7adebe 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -637,7 +637,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		open("/dev/null", O_RDWR);
 		open("/dev/null", O_RDWR);
 		setsid();
-		restart_cgroups();
 	} else {
 		if (!am_single_threaded()) {
 			ERROR("Cannot start non-daemonized container when threaded");

commit 47c50f7a6206034cc0c1cc10d652384613ef9b23
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Mar 3 13:57:14 2014 -0600

    clone: don't set new containers' rootfs to the old
    
    If clone is called from the api, the container object in memory
    retains the bad fs.  The line is wrong, being a leftover from a
    previous attempt before copy_storage was moved earlier.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c60f927..b0ae44b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2677,7 +2677,6 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		ERROR("clone: failed to create new container (%s %s)", n, l);
 		goto out;
 	}
-	c2->lxc_conf->rootfs.path = origroot;
 
 	// copy/snapshot rootfs's
 	ret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);

commit 8d2efe40a32700eaec6a8f3057b3b9bb16721b3d
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Feb 27 21:49:27 2014 -0600

    clone: don't ever mark the clone's rootfs as being the old, on disk
    
    Otherwise an interrupted clone can lead to the original rootfs
    being delete.
    
    There is a period during lxcapi_clone during which we have written down
    a temporary configuration file on disk, for the new container, using the
    old rootfs. Interruption of clone doesn't allow us to do the cleanup we
    do in error paths, so a subsequent lxc-destroy removes the old rootfs.
    
    Fix this by doing the copy_storage as early as possible, and not
    writing down the rootfs when we write down the temporary configuration
    file.
    
    (note - I tested this by putting a series of
    'if (strcmp(newname, "u%d") == 0) exit(1)' inline to trigger
    interruption between most blocks.  If someone has a good idea
    for a generic way to regression-test this henceforth that'd be
    great)
    
    See https://bugs.launchpad.net/lxc/+bug/1285850
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d9aa973..c60f927 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2610,6 +2610,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	char newpath[MAXPATHLEN];
 	int ret, storage_copied = 0;
 	const char *n, *l;
+	char *origroot = NULL;
 	struct clone_update_data data;
 	FILE *fout;
 	pid_t pid;
@@ -2645,6 +2646,10 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	}
 
 	// copy the configuration, tweak it as needed,
+	if (c->lxc_conf->rootfs.path) {
+		origroot = c->lxc_conf->rootfs.path;
+		c->lxc_conf->rootfs.path = NULL;
+	}
 	fout = fopen(newpath, "w");
 	if (!fout) {
 		SYSERROR("open %s", newpath);
@@ -2652,6 +2657,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	}
 	write_config(fout, c->lxc_conf);
 	fclose(fout);
+	c->lxc_conf->rootfs.path = origroot;
 
 	sprintf(newpath, "%s/%s/rootfs", l, n);
 	if (mkdir(newpath, 0755) < 0) {
@@ -2671,6 +2677,12 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		ERROR("clone: failed to create new container (%s %s)", n, l);
 		goto out;
 	}
+	c2->lxc_conf->rootfs.path = origroot;
+
+	// copy/snapshot rootfs's
+	ret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);
+	if (ret < 0)
+		goto out;
 
 	// update utsname
 	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
@@ -2694,11 +2706,6 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (!(flags & LXC_CLONE_KEEPMACADDR))
 		network_new_hwaddrs(c2);
 
-	// copy/snapshot rootfs's
-	ret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);
-	if (ret < 0)
-		goto out;
-
 	// We've now successfully created c2's storage, so clear it out if we
 	// fail after this
 	storage_copied = 1;

commit 0e6e3a41089c86447fef18e54c2796b312a57a94
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Feb 26 13:00:36 2014 -0500

    Fix unprivileged containers started by root
    
    This change makes it possible to create unprivileged containers as root.
    They will be stored in the usual system wide location, use the usual
    system wide cache but will be running using a uid/gid map.
    
    This also updates lxc_usernsexec to use the same function as the rest of
    LXC, centralizing all the userns switch in a single function.
    
    That function now detects the presence of newuidmap and newgidmap on the
    system, if they are present, they will be used for containers created as
    either user or root. If they're not and the user isn't root, an error is
    shown. If they're not and the user is root, LXC will directly set the
    uid_map and gid_map values.
    
    All that should allow for a consistent experience as well as supporting
    distributions that don't yet ship newuidmap/newgidmap.
    
    To make things simpler in the future, an helper function "on_path" is
    also introduced and used to detect the presence of newuidmap and
    newgidmap.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0427791..d9aa973 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -806,7 +806,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	/* if we are not root, chown the rootfs dir to root in the
 	 * target uidmap */
 
-	if (geteuid() != 0) {
+	if (geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) {
 		if (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {
 			ERROR("Error chowning %s to container root", bdev->dest);
 			bdev_put(bdev);
@@ -992,7 +992,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		 * and we append "--mapped-uid x", where x is the mapped uid
 		 * for our geteuid()
 		 */
-		if (geteuid() != 0 && !lxc_list_empty(&conf->id_map)) {
+		if (!lxc_list_empty(&conf->id_map)) {
 			int n2args = 1;
 			char txtuid[20];
 			char txtgid[20];
@@ -1450,7 +1450,7 @@ static inline bool enter_to_ns(struct lxc_container *c) {
 	init_pid = c->init_pid(c);
 
 	/* Switch to new userns */
-	if (geteuid() && access("/proc/self/ns/user", F_OK) == 0) {
+	if ((geteuid() != 0 || (c->lxc_conf && !lxc_list_empty(&c->lxc_conf->id_map))) && access("/proc/self/ns/user", F_OK) == 0) {
 		ret = snprintf(new_userns_path, MAXPATHLEN, "/proc/%d/ns/user", init_pid);
 		if (ret < 0 || ret >= MAXPATHLEN)
 			goto out;

commit 2c6f3fc932661ad87af90f3675a9ae8c3cb9bc3f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Feb 24 23:08:26 2014 -0600

    always check whether rootfs is shared
    
    (this expands on Dwight's recent patch, commit c597baa8f9)
    
    After unshare(CLONE_NEWNS) and before doing any mounting, always
    check whether rootfs is shared.  Otherwise template runs or clone
    scripts can bleed mount activity to the host.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0d89d11..0427791 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2502,6 +2502,12 @@ static int clone_update_rootfs(struct clone_update_data *data)
 			bdev_put(bdev);
 			return -1;
 		}
+		if (detect_shared_rootfs()) {
+			if (mount(NULL, "/", NULL, MS_SLAVE|MS_REC, NULL)) {
+				SYSERROR("Failed to make / rslave");
+				ERROR("Continuing...");
+			}
+		}
 		if (bdev->ops->mount(bdev) < 0) {
 			bdev_put(bdev);
 			return -1;

commit c597baa8f92e708adda14a95a0ed1bfd6b85c1e6
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Wed Feb 19 16:44:19 2014 -0500

    fix mounts not propagating back to root mntns during create and clone
    
    Systems based on systemd mount the root shared by default. We don't want
    mounts done during creation by templates nor those done internally by
    bdev during rsync based clones to propagate to the root mntns.
    
    The create case already had the right check, but the mount call was
    missing "/", so it was failing.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b8b11d6..0d89d11 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -913,7 +913,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 				exit(1);
 			}
 			if (detect_shared_rootfs()) {
-				if (mount("", "", NULL, MS_SLAVE|MS_REC, 0)) {
+				if (mount(NULL, "/", NULL, MS_SLAVE|MS_REC, NULL)) {
 					SYSERROR("Failed to make / rslave to run template");
 					ERROR("Continuing...");
 				}

commit 03fadd1656ce2bf994fc30617c5bb795803e0fde
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Feb 17 20:53:43 2014 -0500

    Add some missing newlines
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2e9798f..b8b11d6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3283,7 +3283,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		c->config_path = strdup(lxc_global_config_value("lxc.lxcpath"));
 
 	if (!c->config_path) {
-		fprintf(stderr, "Out of memory");
+		fprintf(stderr, "Out of memory\n");
 		goto err;
 	}
 

commit 7eb44573b01b70b21bd007ab3f917e56a2a555d4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sat Feb 15 00:16:58 2014 +0100

    re-open cgmanager socket after fork in daemonized start
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ee7d405..2e9798f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -637,6 +637,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		open("/dev/null", O_RDWR);
 		open("/dev/null", O_RDWR);
 		setsid();
+		restart_cgroups();
 	} else {
 		if (!am_single_threaded()) {
 			ERROR("Cannot start non-daemonized container when threaded");

commit d693cf93cda8e4d665e840fd583fbf9e62911c09
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Feb 13 13:40:34 2014 -0500

    Fix crash in rename with undefined containers
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 44e796c..ee7d405 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2742,7 +2742,7 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	struct bdev *bdev;
 	struct lxc_container *newc;
 
-	if (!c || !c->name || !c->config_path)
+	if (!c || !c->name || !c->config_path || !c->lxc_conf)
 		return false;
 
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);

commit 6b9324bd45374e32465f9fff6e24b1af837c445b
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Feb 13 11:17:48 2014 -0500

    coverity: Do chdir following chroot
    
    We used to do chdir(path), chroot(path). That's correct but not properly
    handled coverity, so do chroot(path), chdir("/") instead as that's the
    recommended way.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a25c196..44e796c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3142,9 +3142,9 @@ static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,
 	if (ret < 0 || ret >= MAXPATHLEN)
 		return false;
 
-	if (chdir(chrootpath) < 0)
+	if (chroot(chrootpath) < 0)
 		exit(1);
-	if (chroot(".") < 0)
+	if (chdir("/") < 0)
 		exit(1);
 	/* remove path if it exists */
 	if(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {

commit e7de366c67fd6f9f0b0675c1d6d8428d3834eaf2
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Feb 12 15:33:57 2014 -0500

    coverity: Free bdev in clone_update_rootfs
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 51e0ac5..a25c196 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2498,10 +2498,13 @@ static int clone_update_rootfs(struct clone_update_data *data)
 	if (strcmp(bdev->type, "dir") != 0) {
 		if (unshare(CLONE_NEWNS) < 0) {
 			ERROR("error unsharing mounts");
+			bdev_put(bdev);
 			return -1;
 		}
-		if (bdev->ops->mount(bdev) < 0)
+		if (bdev->ops->mount(bdev) < 0) {
+			bdev_put(bdev);
 			return -1;
+		}
 	} else { // TODO come up with a better way
 		if (bdev->dest)
 			free(bdev->dest);
@@ -2528,12 +2531,15 @@ static int clone_update_rootfs(struct clone_update_data *data)
 
 		if (run_lxc_hooks(c->name, "clone", conf, c->get_config_path(c), hookargs)) {
 			ERROR("Error executing clone hook for %s", c->name);
+			bdev_put(bdev);
 			return -1;
 		}
 	}
 
 	if (!(flags & LXC_CLONE_KEEPNAME)) {
 		ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
+		bdev_put(bdev);
+
 		if (ret < 0 || ret >= MAXPATHLEN)
 			return -1;
 		if (!file_exists(path))
@@ -2549,6 +2555,9 @@ static int clone_update_rootfs(struct clone_update_data *data)
 		if (fclose(fout) < 0)
 			return -1;
 	}
+	else
+		bdev_put(bdev);
+
 	return 0;
 }
 

commit 1f92162dc0432b6f7f8156d22348f22934cbea3f
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Feb 12 14:01:02 2014 -0500

    bdev: Add aufs support
    
    This is pretty much copy/paste from overlayfs.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 09d287b..51e0ac5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -891,13 +891,15 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 
 		src = c->lxc_conf->rootfs.path;
 		/*
-		 * for an overlayfs create, what the user wants is the template to fill
+		 * for an overlay create, what the user wants is the template to fill
 		 * in what will become the readonly lower layer.  So don't mount for
 		 * the template
 		 */
-		if (strncmp(src, "overlayfs:", 10) == 0) {
-			src = overlayfs_getlower(src+10);
-		}
+		if (strncmp(src, "overlayfs:", 10) == 0)
+			src = overlay_getlower(src+10);
+		if (strncmp(src, "aufs:", 5) == 0)
+			src = overlay_getlower(src+5);
+
 		bdev = bdev_init(src, c->lxc_conf->rootfs.mount, NULL);
 		if (!bdev) {
 			ERROR("Error opening rootfs");
@@ -2830,7 +2832,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	if (bdev_is_dir(c->lxc_conf->rootfs.path)) {
 		ERROR("Snapshot of directory-backed container requested.");
 		ERROR("Making a copy-clone.  If you do want snapshots, then");
-		ERROR("please create an overlayfs clone first, snapshot that");
+		ERROR("please create an aufs or overlayfs clone first, snapshot that");
 		ERROR("and keep the original container pristine.");
 		flags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
 	}

commit 8c39f7a4791cd24625b0f12d3ca279400b36bf84
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Feb 10 14:19:42 2014 -0600

    lxcapi-snapshot: don't snapshot directory-backed containers
    
    Instead force a copy clone.  Else if the user makes a change
    to the original container, the snapshot will be affected.
    The user should first create a snapshot clone, then use
    and snapshot that clone while leaving the original container
    untouched.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index cbd645d..09d287b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2827,6 +2827,13 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	 */
 	flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME |
 		LXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;
+	if (bdev_is_dir(c->lxc_conf->rootfs.path)) {
+		ERROR("Snapshot of directory-backed container requested.");
+		ERROR("Making a copy-clone.  If you do want snapshots, then");
+		ERROR("please create an overlayfs clone first, snapshot that");
+		ERROR("and keep the original container pristine.");
+		flags &= ~LXC_CLONE_SNAPSHOT | LXC_CLONE_MAYBE_SNAPSHOT;
+	}
 	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
 		ERROR("clone of %s:%s failed", c->config_path, c->name);

commit 5f7eba0b1c5b344c7f78ed5dce8b338f139771d6
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Feb 7 15:21:24 2014 -0500

    bionic: Define faccessat if missing
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ac92bf1..cbd645d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -35,6 +35,7 @@
 #include <libgen.h>
 #include <stdint.h>
 #include <grp.h>
+#include <sys/syscall.h>
 
 #include <lxc/lxccontainer.h>
 #include <lxc/version.h>
@@ -65,6 +66,20 @@
 
 #define NOT_SUPPORTED_ERROR "the requested function %s is not currently supported with unprivileged containers"
 
+/* Define faccessat() if missing from the C library */
+#ifndef HAVE_FACCESSAT
+static int faccessat(int __fd, const char *__file, int __type, int __flag)
+{
+#ifdef __NR_faccessat
+return syscall(__NR_faccessat, __fd, __file, __type, __flag);
+#else
+errno = ENOSYS;
+return -1;
+#endif
+}
+#endif
+
+
 lxc_log_define(lxc_container, lxc);
 
 static bool file_exists(const char *f)

commit d5aa23e662fd9c64bf72df47f74765e5232f0a96
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Feb 7 13:00:50 2014 -0600

    add_device_node: act in a chroot
    
    The goal is to avoid an absolute symlink in the guest redirecting
    us to the host's /dev.  Thanks to the libvirt team for considering
    that possibility!
    
    We want to work on kernels which do not support setns, so we simply
    chroot into the container before doing any rm/mknod.  If /dev/vda5
    is a symlink to /XXX, or /dev is a symlink to /etc, this is now
    correctly resolved locally in the chroot.
    
    We would have preferred to use realpath() to check that the resolved
    path is not changed, but realpath across /proc/pid/root does not
    work as expected.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 90f089c..ac92bf1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3084,34 +3084,80 @@ static bool lxcapi_may_control(struct lxc_container *c)
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
+static bool do_add_remove_node(pid_t init_pid, const char *path, bool add,
+		struct stat *st)
+{
+	char chrootpath[MAXPATHLEN];
+	char *directory_path = NULL;
+	pid_t pid;
+	int ret;
+
+	if ((pid = fork()) < 0) {
+		SYSERROR("failed to fork a child helper");
+		return false;
+	}
+	if (pid) {
+		if (wait_for_pid(pid) != 0) {
+			ERROR("Failed to create note in guest");
+			return false;
+		}
+		return true;
+	}
+
+	/* prepare the path */
+	ret = snprintf(chrootpath, MAXPATHLEN, "/proc/%d/root", init_pid);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+
+	if (chdir(chrootpath) < 0)
+		exit(1);
+	if (chroot(".") < 0)
+		exit(1);
+	/* remove path if it exists */
+	if(faccessat(AT_FDCWD, path, F_OK, AT_SYMLINK_NOFOLLOW) == 0) {
+		if (unlink(path) < 0) {
+			ERROR("unlink failed");
+			exit(1);
+		}
+	}
+	if (!add)
+		exit(0);
+
+	/* create any missing directories */
+	directory_path = dirname(strdup(path));
+	if (mkdir_p(directory_path, 0755) < 0 && errno != EEXIST) {
+		ERROR("failed to create directory");
+		exit(1);
+	}
+
+	/* create the device node */
+	if (mknod(path, st->st_mode, st->st_rdev) < 0) {
+		ERROR("mknod failed");
+		exit(1);
+	}
+
+	exit(0);
+}
+
 static bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)
 {
 	int ret;
 	struct stat st;
-	char path[MAXPATHLEN];
 	char value[MAX_BUFFER];
-	char *directory_path = NULL;
 	const char *p;
 
 	/* make sure container is running */
 	if (!c->is_running(c)) {
 		ERROR("container is not running");
-		goto out;
+		return false;
 	}
 
 	/* use src_path if dest_path is NULL otherwise use dest_path */
 	p = dest_path ? dest_path : src_path;
 
-	/* prepare the path */
-	ret = snprintf(path, MAXPATHLEN, "/proc/%d/root/%s", c->init_pid(c), p);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		goto out;
-	remove_trailing_slashes(path);
-
-	p = add ? src_path : path;
 	/* make sure we can access p */
 	if(access(p, F_OK) < 0 || stat(p, &st) < 0)
-		goto out;
+		return false;
 
 	/* continue if path is character device or block device */
 	if (S_ISCHR(st.st_mode))
@@ -3119,55 +3165,29 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 	else if (S_ISBLK(st.st_mode))
 		ret = snprintf(value, MAX_BUFFER, "b %d:%d rwm", major(st.st_rdev), minor(st.st_rdev));
 	else
-		goto out;
+		return false;
 
 	/* check snprintf return code */
 	if (ret < 0 || ret >= MAX_BUFFER)
-		goto out;
+		return false;
 
-	directory_path = dirname(strdup(path));
-	/* remove path and directory_path (if empty) */
-	if(access(path, F_OK) == 0) {
-		if (unlink(path) < 0) {
-			ERROR("unlink failed");
-			goto out;
-		}
-		if (rmdir(directory_path) < 0 && errno != ENOTEMPTY) {
-			ERROR("rmdir failed");
-			goto out;
-		}
-	}
+	if (!do_add_remove_node(c->init_pid(c), p, add, &st))
+		return false;
 
+	/* add or remove device to/from cgroup access list */
 	if (add) {
-		/* create the missing directories */
-		if (mkdir_p(directory_path, 0755) < 0) {
-			ERROR("failed to create directory");
-			goto out;
-		}
-
-		/* create the device node */
-		if (mknod(path, st.st_mode, st.st_rdev) < 0) {
-			ERROR("mknod failed");
-			goto out;
-		}
-
-		/* add device node to device list */
 		if (!c->set_cgroup_item(c, "devices.allow", value)) {
 			ERROR("set_cgroup_item failed while adding the device node");
-			goto out;
+			return false;
 		}
 	} else {
-		/* remove device node from device list */
 		if (!c->set_cgroup_item(c, "devices.deny", value)) {
 			ERROR("set_cgroup_item failed while removing the device node");
-			goto out;
+			return false;
 		}
 	}
+
 	return true;
-out:
-	if (directory_path)
-		free(directory_path);
-	return false;
 }
 
 static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)

commit 959aee9c0017771aedc92c9e81228b0ca75dd3bd
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Feb 7 10:19:27 2014 -0500

    log: Drop trailing \n from log messages
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7d3ebdb..90f089c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -743,7 +743,7 @@ static bool create_container_dir(struct lxc_container *c)
 		if (errno == EEXIST)
 			ret = 0;
 		else
-			SYSERROR("failed to create container path for %s\n", c->name);
+			SYSERROR("failed to create container path for %s", c->name);
 	}
 	free(s);
 	return ret == 0;
@@ -781,7 +781,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 
 	bdev = bdev_create(dest, type, c->name, specs);
 	if (!bdev) {
-		ERROR("Failed to create backing store type %s\n", type);
+		ERROR("Failed to create backing store type %s", type);
 		return NULL;
 	}
 
@@ -792,7 +792,7 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 
 	if (geteuid() != 0) {
 		if (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {
-			ERROR("Error chowning %s to container root\n", bdev->dest);
+			ERROR("Error chowning %s to container root", bdev->dest);
 			bdev_put(bdev);
 			return NULL;
 		}
@@ -827,7 +827,7 @@ static char *get_template_path(const char *t)
 		return NULL;
 	}
 	if (access(tpath, X_OK) < 0) {
-		SYSERROR("bad template: %s\n", t);
+		SYSERROR("bad template: %s", t);
 		free(tpath);
 		return NULL;
 	}
@@ -853,7 +853,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 
 	pid = fork();
 	if (pid < 0) {
-		SYSERROR("failed to fork task for container creation template\n");
+		SYSERROR("failed to fork task for container creation template");
 		return false;
 	}
 
@@ -1083,7 +1083,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 	}
 
 	if (wait_for_pid(pid) != 0) {
-		ERROR("container creation template for %s failed\n", c->name);
+		ERROR("container creation template for %s failed", c->name);
 		return false;
 	}
 
@@ -1126,7 +1126,7 @@ static bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 #if HAVE_LIBGNUTLS
 	tpath = get_template_path(t);
 	if (!tpath) {
-		ERROR("bad template: %s\n", t);
+		ERROR("bad template: %s", t);
 		goto out_free_contents;
 	}
 
@@ -1222,7 +1222,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (t) {
 		tpath = get_template_path(t);
 		if (!tpath) {
-			ERROR("bad template: %s\n", t);
+			ERROR("bad template: %s", t);
 			goto out;
 		}
 	}
@@ -1241,7 +1241,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 	if (!c->lxc_conf) {
 		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
-			ERROR("Error loading default configuration file %s\n", lxc_global_config_value("lxc.default_config"));
+			ERROR("Error loading default configuration file %s", lxc_global_config_value("lxc.default_config"));
 			goto free_tpath;
 		}
 	}
@@ -1282,7 +1282,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	 */
 	pid = fork();
 	if (pid < 0) {
-		SYSERROR("failed to fork task for container creation template\n");
+		SYSERROR("failed to fork task for container creation template");
 		goto out_unlock;
 	}
 
@@ -1297,7 +1297,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 		/* save config file again to store the new rootfs location */
 		if (!c->save_config(c, NULL)) {
-			ERROR("failed to save starting configuration for %s\n", c->name);
+			ERROR("failed to save starting configuration for %s", c->name);
 			// parent task won't see bdev in config so we delete it
 			bdev->ops->umount(bdev);
 			bdev->ops->destroy(bdev);
@@ -1558,7 +1558,7 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 
 	pid = fork();
 	if (pid < 0) {
-		SYSERROR("failed to fork task to get interfaces information\n");
+		SYSERROR("failed to fork task to get interfaces information");
 		close(pipefd[0]);
 		close(pipefd[1]);
 		return NULL;
@@ -1645,7 +1645,7 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 
 	pid = fork();
 	if (pid < 0) {
-		SYSERROR("failed to fork task to get container ips\n");
+		SYSERROR("failed to fork task to get container ips");
 		close(pipefd[0]);
 		close(pipefd[1]);
 		return NULL;
@@ -1808,7 +1808,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
 		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
-			ERROR("Error loading default configuration file %s while saving %s\n", lxc_global_config_value("lxc.default_config"), c->name);
+			ERROR("Error loading default configuration file %s while saving %s", lxc_global_config_value("lxc.default_config"), c->name);
 			return false;
 		}
 	}
@@ -1919,7 +1919,7 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 		return;
 	while (getline(&lxcpath, &pathlen, f) != -1) {
 		if (getline(&lxcname, &namelen, f) == -1) {
-			ERROR("badly formatted file %s\n", path);
+			ERROR("badly formatted file %s", path);
 			goto out;
 		}
 		strip_newline(lxcpath);
@@ -2522,7 +2522,7 @@ static int clone_update_rootfs(struct clone_update_data *data)
 		if (!file_exists(path))
 			return 0;
 		if (!(fout = fopen(path, "w"))) {
-			SYSERROR("unable to open %s: ignoring\n", path);
+			SYSERROR("unable to open %s: ignoring", path);
 			return 0;
 		}
 		if (fprintf(fout, "%s", c->name) < 0) {
@@ -2563,7 +2563,7 @@ static int create_file_dirname(char *path)
 	*p = '\0';
 	ret = mkdir(path, 0755);
 	if (ret && errno != EEXIST)
-		SYSERROR("creating container path %s\n", path);
+		SYSERROR("creating container path %s", path);
 	*p = '/';
 	return ret;
 }
@@ -2628,7 +2628,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 
 	if (am_unpriv()) {
 		if (chown_mapped_root(newpath, c->lxc_conf) < 0) {
-			ERROR("Error chowning %s to container root\n", newpath);
+			ERROR("Error chowning %s to container root", newpath);
 			goto out;
 		}
 	}
@@ -2814,7 +2814,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 		LXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;
 	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
-		ERROR("clone of %s:%s failed\n", c->config_path, c->name);
+		ERROR("clone of %s:%s failed", c->config_path, c->name);
 		return -1;
 	}
 
@@ -2835,7 +2835,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	sprintf(dfnam, "%s/%s/ts", snappath, newname);
 	f = fopen(dfnam, "w");
 	if (!f) {
-		ERROR("Failed to open %s\n", dfnam);
+		ERROR("Failed to open %s", dfnam);
 		return -1;
 	}
 	if (fprintf(f, "%s", buffer) < 0) {

commit 2133f58c66ab7627a4159fafbb75106c556b014d
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Feb 4 13:33:10 2014 -0600

    create: pass --mapped-gid to templates next to --mapped-uid
    
    That way templates can fix group ownership alongside uid ownership.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 85c644a..7d3ebdb 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -977,6 +977,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		if (geteuid() != 0 && !lxc_list_empty(&conf->id_map)) {
 			int n2args = 1;
 			char txtuid[20];
+			char txtgid[20];
 			char **n2 = malloc(n2args * sizeof(*n2));
 			struct lxc_list *it;
 			struct id_map *map;
@@ -1004,13 +1005,13 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 				if (ret < 0 || ret >= 200)
 					exit(1);
 			}
-			int hostid_mapped = mapped_hostid(geteuid(), conf);
+			int hostid_mapped = mapped_hostid(geteuid(), conf, ID_TYPE_UID);
 			int extraargs = hostid_mapped >= 0 ? 1 : 3;
 			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));
 			if (!n2)
 				exit(1);
 			if (hostid_mapped < 0) {
-				hostid_mapped = find_unmapped_nsuid(conf);
+				hostid_mapped = find_unmapped_nsuid(conf, ID_TYPE_UID);
 				n2[n2args++] = "-m";
 				if (hostid_mapped < 0) {
 					ERROR("Could not find free uid to map");
@@ -1028,22 +1029,49 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 					exit(1);
 				}
 			}
+			int hostgid_mapped = mapped_hostid(getegid(), conf, ID_TYPE_GID);
+			extraargs = hostgid_mapped >= 0 ? 1 : 3;
+			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));
+			if (!n2)
+				exit(1);
+			if (hostgid_mapped < 0) {
+				hostgid_mapped = find_unmapped_nsuid(conf, ID_TYPE_GID);
+				n2[n2args++] = "-m";
+				if (hostgid_mapped < 0) {
+					ERROR("Could not find free uid to map");
+					exit(1);
+				}
+				n2[n2args++] = malloc(200);
+				if (!n2[n2args-1]) {
+					SYSERROR("out of memory");
+					exit(1);
+				}
+				ret = snprintf(n2[n2args-1], 200, "g:%d:%d:1",
+					hostgid_mapped, getegid());
+				if (ret < 0 || ret >= 200) {
+					ERROR("string too long");
+					exit(1);
+				}
+			}
 			n2[n2args++] = "--";
 			for (i = 0; i < nargs; i++)
 				n2[i + n2args] = newargv[i];
 			n2args += nargs;
 			// Finally add "--mapped-uid $uid" to tell template what to chown
 			// cached images to
-			n2args += 2;
+			n2args += 4;
 			n2 = realloc(n2, n2args * sizeof(char *));
 			if (!n2) {
 				SYSERROR("out of memory");
 				exit(1);
 			}
 			// note n2[n2args-1] is NULL
-			n2[n2args-3] = "--mapped-uid";
+			n2[n2args-5] = "--mapped-uid";
 			snprintf(txtuid, 20, "%d", hostid_mapped);
-			n2[n2args-2] = txtuid;
+			n2[n2args-4] = txtuid;
+			n2[n2args-3] = "--mapped-gid";
+			snprintf(txtgid, 20, "%d", hostgid_mapped);
+			n2[n2args-2] = txtgid;
 			n2[n2args-1] = NULL;
 			free(newargv);
 			newargv = n2;

commit 0464b881e68ef5f50bd7bb9633b70e2e89be039b
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Jan 31 13:56:55 2014 +0000

    shutdown: Rework API and lxc-stop
    
    With this change, shutdown() will no longer call stop() after the
    timeout, instead it'll just return false and it's up to the caller to
    then call stop() if appropriate.
    
    This also updates the bindings, tests and other scripts.
    
    lxc-stop is then updated to do proper option checking and use shutdown,
    stop or reboot as appropriate.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a0a5af5..85c644a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1348,10 +1348,6 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 		haltsignal = c->lxc_conf->haltsignal;
 	kill(pid, haltsignal);
 	retv = c->wait(c, "STOPPED", timeout);
-	if (!retv && timeout > 0) {
-		c->stop(c);
-		retv = c->wait(c, "STOPPED", 0); // 0 means don't wait
-	}
 	return retv;
 }
 

commit a52e315d12fa8ea682b7f58c999dab6d74c60e33
Author: Robert Vogelgesang <vogel@users.sourceforge.net>
Date:   Fri Jan 31 11:47:02 2014 +0100

    Fix the timeout == 0 case in lxcapi_shutdown()
    
    The timeout argument should be handled as follows:
       -1 => Wait forever
        0 => Don't wait
      > 0 => Wait for timeout seconds
    
    Without this patch, the 0 case is mapped to -1.
    
    Signed-off-by: Robert Vogelgesang <vogel@users.sourceforge.net>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 854be07..a0a5af5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1339,8 +1339,6 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	if (!c)
 		return false;
 
-	if (!timeout)
-		timeout = -1;
 	if (!c->is_running(c))
 		return true;
 	pid = c->init_pid(c);

commit c476bdce46f5fd8e9ee261e40c86988211cbc278
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Jan 30 14:18:30 2014 +0000

    cgmanager: support lxc.mount.auto = cgroup
    
    If it (or any variation thereof) is in the container configuration,
    then mount /sys/fs/cgroup/cgmanager.lower (if it exists) or
    /sys/fs/cgroup/cgmanager into the container so it can run a
    cgproxy.
    
    Also make sure to clear our groups when we start or attach to a
    container.  Else with unprivileged containers we end up with
    lots of nogroups listed in /proc/1/status.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3862890..854be07 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -34,6 +34,7 @@
 #include <arpa/inet.h>
 #include <libgen.h>
 #include <stdint.h>
+#include <grp.h>
 
 #include <lxc/lxccontainer.h>
 #include <lxc/version.h>
@@ -2447,6 +2448,8 @@ static int clone_update_rootfs(struct clone_update_data *data)
 		ERROR("Failed to setuid to 0");
 		return -1;
 	}
+	if (setgroups(0, NULL) < 0)
+		WARN("Failed to clear groups");
 
 	if (unshare(CLONE_NEWNS) < 0)
 		return -1;

commit bac806d1a11ad3e15f69b13579153d1144e4b2e4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jan 28 13:28:19 2014 +0000

    lxc_container_new: fail on config file parse error
    
    If we have a bad config file entry, fail.  Otherwise lxc-start
    will proceed with a partial configuration.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index aad692f..3862890 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3232,8 +3232,8 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		goto err;
 	}
 
-	if (file_exists(c->configfile))
-		lxcapi_load_config(c, NULL);
+	if (file_exists(c->configfile) && !lxcapi_load_config(c, NULL))
+		goto err;
 
 	if (ongoing_create(c) == 2) {
 		ERROR("Error: %s creation was not completed", c->name);

commit 8ac18377749fee21a29158afd5b0746d6c6771b8
Author: S.alar Onur <caglar@10ur.org>
Date:   Mon Jan 27 17:57:37 2014 -0500

    export lxc_cmd_get_config_item via API and use in lxc-info
    
    This allows external users to query network related config items
    from the running containers.
    
    changes since v1:
    - function name change
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index dcdeaad..aad692f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1738,6 +1738,19 @@ static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char
 	return ret;
 }
 
+static char* lxcapi_get_running_config_item(struct lxc_container *c, const char *key)
+{
+	char *ret;
+
+	if (!c || !c->lxc_conf)
+		return NULL;
+	if (container_mem_lock(c))
+		return NULL;
+	ret = lxc_cmd_get_config_item(c->name, key, c->get_config_path(c));
+	container_mem_unlock(c);
+	return ret;
+}
+
 static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	if (!key)
@@ -3259,6 +3272,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->clear_config = lxcapi_clear_config;
 	c->clear_config_item = lxcapi_clear_config_item;
 	c->get_config_item = lxcapi_get_config_item;
+	c->get_running_config_item = lxcapi_get_running_config_item;
 	c->get_cgroup_item = lxcapi_get_cgroup_item;
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
 	c->get_config_path = lxcapi_get_config_path;

commit 6849cb5b57c68c455e74b3cded1166e1ade1a320
Author: Luka Perkov <luka.perkov@sartura.hr>
Date:   Sun Jan 26 00:26:56 2014 +0000

    lxccontainer: fix whitespaces
    
    Signed-off-by: Luka Perkov <luka.perkov@sartura.hr>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d0c5e07..dcdeaad 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -921,7 +921,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		 */
 		if (argv)
 			for (nargs = 0; argv[nargs]; nargs++) ;
-		nargs += 4;  // template, path, rootfs and name args
+		nargs += 4; // template, path, rootfs and name args
 
 		newargv = malloc(nargs * sizeof(*newargv));
 		if (!newargv)
@@ -1004,7 +1004,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 					exit(1);
 			}
 			int hostid_mapped = mapped_hostid(geteuid(), conf);
-			int extraargs = hostid_mapped >= 0 ?  1 : 3;
+			int extraargs = hostid_mapped >= 0 ? 1 : 3;
 			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));
 			if (!n2)
 				exit(1);
@@ -1697,7 +1697,7 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 		/* close the write-end of the pipe, thus sending EOF to the reader */
 		close(pipefd[1]);
 		exit(ret);
-    }
+	}
 
 	/* close the write-end of the pipe */
 	close(pipefd[1]);
@@ -1753,7 +1753,7 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 		return -1;
 	int ret = -1;
 	if (strncmp(key, "lxc.network.", 12) == 0)
-		ret =  lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);
+		ret = lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);
 	container_mem_unlock(c);
 	return ret;
 }
@@ -1767,7 +1767,7 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	if (!alt_file)
 		alt_file = c->configfile;
 	if (!alt_file)
-		return false;  // should we write to stdout if no file is specified?
+		return false; // should we write to stdout if no file is specified?
 
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
@@ -2194,7 +2194,7 @@ static int copy_file(const char *old, const char *new)
 		if (len == 0)
 			break;
 		ret = write(out, buf, len);
-		if (ret < len) {  // should we retry?
+		if (ret < len) { // should we retry?
 			SYSERROR("Error: write to new file %s was interrupted", new);
 			goto err;
 		}
@@ -2490,7 +2490,7 @@ static int clone_update_rootfs(struct clone_update_data *data)
 		if (fprintf(fout, "%s", c->name) < 0) {
 			fclose(fout);
 			return -1;
-        }
+		}
 		if (fclose(fout) < 0)
 			return -1;
 	}
@@ -2558,7 +2558,7 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	n = newname ? newname : c->name;
 	l = lxcpath ? lxcpath : c->get_config_path(c);
 	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", l, n);
-	if (ret < 0  || ret >= MAXPATHLEN) {
+	if (ret < 0 || ret >= MAXPATHLEN) {
 		SYSERROR("clone: failed making config pathname");
 		goto out;
 	}
@@ -3110,7 +3110,7 @@ static bool add_remove_device_node(struct lxc_container *c, const char *src_path
 		/* create the device node */
 		if (mknod(path, st.st_mode, st.st_rdev) < 0) {
 			ERROR("mknod failed");
-            goto out;
+			goto out;
 		}
 
 		/* add device node to device list */

commit 487d80082ff1800198a5b7359ebc5f416a6f6bde
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Fri Jan 24 11:41:27 2014 +0800

    lxccontainer: remove PID file after lxc_start return
    
    Make the way symmetric. This also fix the file leak in
    daemon model.
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6ea7c11..d0c5e07 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -233,11 +233,6 @@ static void lxc_container_free(struct lxc_container *c)
 		free(c->config_path);
 		c->config_path = NULL;
 	}
-	if (c->pidfile) {
-		unlink(c->pidfile);
-		free(c->pidfile);
-		c->pidfile = NULL;
-	}
 
 	free(c);
 }
@@ -665,6 +660,12 @@ reboot:
 		goto reboot;
 	}
 
+	if (c->pidfile) {
+		unlink(c->pidfile);
+		free(c->pidfile);
+		c->pidfile = NULL;
+	}
+
 	if (daemonize)
 		exit (ret == 0 ? true : false);
 	else

commit a684f0b77de5b6f779bdbc477cda1239c3bf941a
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Jan 25 00:46:04 2014 -0500

    close the fd on error
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fbf0824..6ea7c11 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2486,8 +2486,10 @@ static int clone_update_rootfs(struct clone_update_data *data)
 			SYSERROR("unable to open %s: ignoring\n", path);
 			return 0;
 		}
-		if (fprintf(fout, "%s", c->name) < 0)
+		if (fprintf(fout, "%s", c->name) < 0) {
+			fclose(fout);
 			return -1;
+        }
 		if (fclose(fout) < 0)
 			return -1;
 	}

commit e8ff96bbf84fc381e74d8526a0860e1a45032f03
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Jan 23 21:41:28 2014 -0500

    Fix destroy() crash when no config is loaded
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1520cd3..fbf0824 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1957,7 +1957,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (!am_unpriv() && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
+	if (!am_unpriv() && c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 		if (r) {
 			if (r->ops->destroy(r) < 0) {

commit 1354955b02bca17d72162f2d61f38e72edea792f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 22 18:18:04 2014 -0600

    lxc-clone: support unprivileged use
    
    This also fixes unprivileged use of lxc-snapshot and lxc-rename.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 28de455..1520cd3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -66,10 +66,6 @@
 
 lxc_log_define(lxc_container, lxc);
 
-inline static bool am_unpriv() {
-	return geteuid() != 0;
-}
-
 static bool file_exists(const char *f)
 {
 	struct stat statbuf;
@@ -2381,8 +2377,7 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	struct bdev *bdev;
 	int need_rdep;
 
-	bdev = bdev_copy(c0->lxc_conf->rootfs.path, c0->name, c->name,
-			c0->config_path, c->config_path, newtype, flags,
+	bdev = bdev_copy(c0, c->name, c->config_path, newtype, flags,
 			bdevdata, newsize, &need_rdep);
 	if (!bdev) {
 		ERROR("Error copying storage");
@@ -2408,36 +2403,49 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	return 0;
 }
 
-static int clone_update_rootfs(struct lxc_container *c0,
-			       struct lxc_container *c, int flags,
-			       char **hookargs)
+struct clone_update_data {
+	struct lxc_container *c0;
+	struct lxc_container *c1;
+	int flags;
+	char **hookargs;
+};
+
+static int clone_update_rootfs(struct clone_update_data *data)
 {
+	struct lxc_container *c0 = data->c0;
+	struct lxc_container *c = data->c1;
+	int flags = data->flags;
+	char **hookargs = data->hookargs;
 	int ret = -1;
 	char path[MAXPATHLEN];
 	struct bdev *bdev;
 	FILE *fout;
-	pid_t pid;
 	struct lxc_conf *conf = c->lxc_conf;
 
 	/* update hostname in rootfs */
 	/* we're going to mount, so run in a clean namespace to simplify cleanup */
 
-	pid = fork();
-	if (pid < 0)
+	if (setgid(0) < 0) {
+		ERROR("Failed to setgid to 0");
 		return -1;
-	if (pid > 0)
-		return wait_for_pid(pid);
+	}
+	if (setuid(0) < 0) {
+		ERROR("Failed to setuid to 0");
+		return -1;
+	}
 
+	if (unshare(CLONE_NEWNS) < 0)
+		return -1;
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
-		exit(1);
+		return -1;
 	if (strcmp(bdev->type, "dir") != 0) {
 		if (unshare(CLONE_NEWNS) < 0) {
 			ERROR("error unsharing mounts");
-			exit(1);
+			return -1;
 		}
 		if (bdev->ops->mount(bdev) < 0)
-			exit(1);
+			return -1;
 	} else { // TODO come up with a better way
 		if (bdev->dest)
 			free(bdev->dest);
@@ -2464,26 +2472,32 @@ static int clone_update_rootfs(struct lxc_container *c0,
 
 		if (run_lxc_hooks(c->name, "clone", conf, c->get_config_path(c), hookargs)) {
 			ERROR("Error executing clone hook for %s", c->name);
-			exit(1);
+			return -1;
 		}
 	}
 
 	if (!(flags & LXC_CLONE_KEEPNAME)) {
 		ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
 		if (ret < 0 || ret >= MAXPATHLEN)
-			exit(1);
+			return -1;
 		if (!file_exists(path))
-			exit(0);
+			return 0;
 		if (!(fout = fopen(path, "w"))) {
 			SYSERROR("unable to open %s: ignoring\n", path);
-			exit(0);
+			return 0;
 		}
 		if (fprintf(fout, "%s", c->name) < 0)
-			exit(1);
+			return -1;
 		if (fclose(fout) < 0)
-			exit(1);
+			return -1;
 	}
-	exit(0);
+	return 0;
+}
+
+static int clone_update_rootfs_wrapper(void *data)
+{
+	struct clone_update_data *arg = (struct clone_update_data *) data;
+	return clone_update_rootfs(arg);
 }
 
 /*
@@ -2522,16 +2536,13 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	char newpath[MAXPATHLEN];
 	int ret, storage_copied = 0;
 	const char *n, *l;
+	struct clone_update_data data;
 	FILE *fout;
+	pid_t pid;
 
 	if (!c || !c->is_defined(c))
 		return NULL;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return NULL;
-	}
-
 	if (container_mem_lock(c))
 		return NULL;
 
@@ -2574,6 +2585,13 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 		goto out;
 	}
 
+	if (am_unpriv()) {
+		if (chown_mapped_root(newpath, c->lxc_conf) < 0) {
+			ERROR("Error chowning %s to container root\n", newpath);
+			goto out;
+		}
+	}
+
 	c2 = lxc_container_new(n, l);
 	if (!c2) {
 		ERROR("clone: failed to create new container (%s %s)", n, l);
@@ -2614,12 +2632,31 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (!c2->save_config(c2, NULL))
 		goto out;
 
-	if (clone_update_rootfs(c, c2, flags, hookargs) < 0)
+	if ((pid = fork()) < 0) {
+		SYSERROR("fork");
 		goto out;
+	}
+	if (pid > 0) {
+		ret = wait_for_pid(pid);
+		if (ret)
+			goto out;
+		container_mem_unlock(c);
+		return c2;
+	}
+	data.c0 = c;
+	data.c1 = c2;
+	data.flags = flags;
+	data.hookargs = hookargs;
+	if (am_unpriv())
+		ret = userns_exec_1(c->lxc_conf, clone_update_rootfs_wrapper,
+				&data);
+	else
+		ret = clone_update_rootfs(&data);
+	if (ret < 0)
+		exit(1);
 
-	// TODO: update c's lxc.snapshot = count
 	container_mem_unlock(c);
-	return c2;
+	exit(0);
 
 out:
 	container_mem_unlock(c);
@@ -2641,11 +2678,6 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	if (!c || !c->name || !c->config_path)
 		return false;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return false;
-	}
-
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -2718,11 +2750,6 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	struct lxc_container *c2;
 	char snappath[MAXPATHLEN], newname[20];
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return -1;
-	}
-
 	// /var/lib/lxc -> /var/lib/lxcsnaps \0
 	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
@@ -2861,11 +2888,6 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return -1;
-	}
-
 	// snappath is ${lxcpath}snaps/${lxcname}/
 	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
@@ -2944,11 +2966,6 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return false;
-	}
-
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -2998,11 +3015,6 @@ static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return false;
-	}
-
 	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		goto err;

commit 6eaac3034e8c19eab2b91e201628c4ab5a85a085
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Wed Jan 22 12:11:38 2014 +0800

    daemon: fix the wrong pid in daemon model
    
    When you start a container in daemon model, you have at least
    3 processes:
     1. The command the user start (lxc-start -d)
     2. The backgrounded fork of that command after start() is done
     3. The container init process
    
    In PID file, we need (2), but currently we are writing (1),
    this is wrong because (1) exits as soon as the container is
    started, it's complately useless.
    
    So we write pid after daemonize, so that we'll always write
    the right pid to PID file.
    
    Reported-by: Stephane Graber <stgraber@ubuntu.com>
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f1c98a4..28de455 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -545,6 +545,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	int ret;
 	struct lxc_conf *conf;
 	bool daemonize = false;
+	FILE *pid_fp = NULL;
 	char *default_args[] = {
 		"/sbin/init",
 		'\0',
@@ -600,8 +601,14 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		pid_t pid = fork();
 		if (pid < 0)
 			return false;
-		if (pid != 0)
+
+		if (pid != 0) {
+			/* Set to NULL because we don't want father unlink
+			 * the PID file, child will do the free and unlink.
+			 */
+			c->pidfile = NULL;
 			return wait_on_daemonized_start(c, pid);
+		}
 
 		/* second fork to be reparented by init */
 		pid = fork();
@@ -630,6 +637,28 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		}
 	}
 
+	/* We need to write PID file after daeminize, so we always
+	 * write the right PID.
+	 */
+	if (c->pidfile) {
+		pid_fp = fopen(c->pidfile, "w");
+		if (pid_fp == NULL) {
+			SYSERROR("Failed to create pidfile '%s' for '%s'",
+				 c->pidfile, c->name);
+			return false;
+		}
+
+		if (fprintf(pid_fp, "%d\n", getpid()) < 0) {
+			SYSERROR("Failed to write '%s'", c->pidfile);
+			fclose(pid_fp);
+			pid_fp = NULL;
+			return false;
+		}
+
+		fclose(pid_fp);
+		pid_fp = NULL;
+	}
+
 reboot:
 	conf->reboot = 0;
 	ret = lxc_start(c->name, argv, conf, c->config_path);

commit 72cf75fa33b97104c5e9905aab1be8d335119e7b
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Wed Jan 22 12:11:37 2014 +0800

    lxc-start: store PID file to lxc_container
    
    So we can remove PID file untill lxc_container_free.
    
    This also fix bug: https://github.com/lxc/lxc/issues/89
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 167708d..f1c98a4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -237,6 +237,12 @@ static void lxc_container_free(struct lxc_container *c)
 		free(c->config_path);
 		c->config_path = NULL;
 	}
+	if (c->pidfile) {
+		unlink(c->pidfile);
+		free(c->pidfile);
+		c->pidfile = NULL;
+	}
+
 	free(c);
 }
 
@@ -3178,6 +3184,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		lxcapi_clear_config(c);
 	}
 	c->daemonize = true;
+	c->pidfile = NULL;
 
 	// assign the member functions
 	c->is_defined = lxcapi_is_defined;

commit 844f7a387484bf529a9dc3ee13db8330e441779a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sun Jan 19 12:17:42 2014 -0600

    api_start: don't get a container reference for the daemonized case
    
    In the daemonized case we will fork, so the anonymous container memlock
    will not be shared between parent and child.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 70a85bd..167708d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -589,15 +589,11 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	* while container is running...
 	*/
 	if (daemonize) {
-		if (!lxc_container_get(c))
-			return false;
 		lxc_monitord_spawn(c->config_path);
 
 		pid_t pid = fork();
-		if (pid < 0) {
-			lxc_container_put(c);
+		if (pid < 0)
 			return false;
-		}
 		if (pid != 0)
 			return wait_on_daemonized_start(c, pid);
 
@@ -638,12 +634,10 @@ reboot:
 		goto reboot;
 	}
 
-	if (daemonize) {
-		lxc_container_put(c);
+	if (daemonize)
 		exit (ret == 0 ? true : false);
-	} else {
+	else
 		return (ret == 0 ? true : false);
-	}
 }
 
 /*

commit 358afd840d713d9568a13631883fa0c32de5c868
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 22 13:16:59 2014 -0600

    lxcapi_get_interfaces and lxcapi_get_ips: stricter read check
    
    Coverity warns of the danger of a short read otherwise.
    
    (Untested, but should be correct; Tossing over to you :)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: S.alar Onur <caglar@10ur.org>
    Acked-by: S.alar Onur <caglar@10ur.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4ffd9a9..70a85bd 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1556,7 +1556,7 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 	/* close the write-end of the pipe */
 	close(pipefd[1]);
 
-	while (read(pipefd[0], &interface, IFNAMSIZ) > 0) {
+	while (read(pipefd[0], &interface, IFNAMSIZ) == IFNAMSIZ) {
 		if (array_contains(&interfaces, interface, count))
 				continue;
 
@@ -1676,7 +1676,7 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 	/* close the write-end of the pipe */
 	close(pipefd[1]);
 
-	while (read(pipefd[0], &address, INET6_ADDRSTRLEN) > 0) {
+	while (read(pipefd[0], &address, INET6_ADDRSTRLEN) == INET6_ADDRSTRLEN) {
 		if(!add_to_array(&addresses, address, count))
 			ERROR("PARENT: add_to_array failed");
 		count++;

commit 452c91416bc375d92cb8fb3b87f54c8e969d4f8f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 22 13:02:42 2014 -0600

    coverity: close userns file when done
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 55b967a..4ffd9a9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1396,8 +1396,10 @@ static inline bool enter_to_ns(struct lxc_container *c) {
 
 		if (setns(userns, CLONE_NEWUSER)) {
 			SYSERROR("failed to setns for CLONE_NEWUSER");
+			close(userns);
 			goto out;
 		}
+		close(userns);
 	}
 
 	/* Switch to new netns */

commit 32f4b9c77cd6811eb990e408f75fd9ed0c5cac4e
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 22 12:57:53 2014 -0600

    coverity: close netns file when done
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3723997..55b967a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1413,8 +1413,10 @@ static inline bool enter_to_ns(struct lxc_container *c) {
 
 	if (setns(netns, CLONE_NEWNET)) {
 		SYSERROR("failed to setns for CLONE_NEWNET");
+		close(netns);
 		goto out;
 	}
+	close(netns);
 	return true;
 out:
 	return false;

commit ae22a2206489f1a4eba40e26853113772db50929
Author: S.alar Onur <caglar@10ur.org>
Date:   Mon Jan 20 19:57:28 2014 -0500

    make lxcapi_get_interfaces and lxcapi_get_ips unprivileged container aware
    
    Based on Stphane's suggestion, those two API methods now;
    
    * fork a new process,
    * switch to appropriate namespace(s),
    * do what we want,
    * return the data over a pipe to the parent which returns the result to the original caller.
    
    For the whole thread please see;
    
     https://lists.linuxcontainers.org/pipermail/lxc-devel/2014-January/007362.html
    
    This patch also makes lxc-ls and lxc-info call those functions.
    
    I'm adding Stphane as an author here since both the idea as well as
    the initial setns code come from him.
    
    Author: S.alar Onur <caglar@10ur.org>
    Author: Stphane Graber <stgraber@ubuntu.com>
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 794d278..3723997 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1372,48 +1372,51 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
-static inline void exit_from_ns(struct lxc_container *c, int *old_netns, int *new_netns) {
-	/* Switch back to original netns */
-	if (*old_netns >= 0 && setns(*old_netns, CLONE_NEWNET))
-		SYSERROR("failed to setns");
-	if (*new_netns >= 0)
-		close(*new_netns);
-	if (*old_netns >= 0)
-		close(*old_netns);
-}
-
-static inline bool enter_to_ns(struct lxc_container *c, int *old_netns, int *new_netns) {
-	int ret = 0;
+static inline bool enter_to_ns(struct lxc_container *c) {
+	int netns, userns, ret = 0, init_pid = 0;;
 	char new_netns_path[MAXPATHLEN];
+	char new_userns_path[MAXPATHLEN];
 
 	if (!c->is_running(c))
 		goto out;
 
-	/* Save reference to old netns */
-	*old_netns = open("/proc/self/ns/net", O_RDONLY);
-	if (*old_netns < 0) {
-		SYSERROR("failed to open /proc/self/ns/net");
-		goto out;
+	init_pid = c->init_pid(c);
+
+	/* Switch to new userns */
+	if (geteuid() && access("/proc/self/ns/user", F_OK) == 0) {
+		ret = snprintf(new_userns_path, MAXPATHLEN, "/proc/%d/ns/user", init_pid);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			goto out;
+
+		userns = open(new_userns_path, O_RDONLY);
+		if (userns < 0) {
+			SYSERROR("failed to open %s", new_userns_path);
+			goto out;
+		}
+
+		if (setns(userns, CLONE_NEWUSER)) {
+			SYSERROR("failed to setns for CLONE_NEWUSER");
+			goto out;
+		}
 	}
 
 	/* Switch to new netns */
-	ret = snprintf(new_netns_path, MAXPATHLEN, "/proc/%d/ns/net", c->init_pid(c));
+	ret = snprintf(new_netns_path, MAXPATHLEN, "/proc/%d/ns/net", init_pid);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		goto out;
 
-	*new_netns = open(new_netns_path, O_RDONLY);
-	if (*new_netns < 0) {
+	netns = open(new_netns_path, O_RDONLY);
+	if (netns < 0) {
 		SYSERROR("failed to open %s", new_netns_path);
 		goto out;
 	}
 
-	if (setns(*new_netns, CLONE_NEWNET)) {
-		SYSERROR("failed to setns");
+	if (setns(netns, CLONE_NEWNET)) {
+		SYSERROR("failed to setns for CLONE_NEWNET");
 		goto out;
 	}
 	return true;
 out:
-	exit_from_ns(c, old_netns, new_netns);
 	return false;
 }
 
@@ -1490,135 +1493,206 @@ static bool remove_from_array(char ***names, char *cname, int size)
 
 static char** lxcapi_get_interfaces(struct lxc_container *c)
 {
-	int i, count = 0;
-	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+	pid_t pid;
+	int i, count = 0, pipefd[2];
 	char **interfaces = NULL;
-	int old_netns = -1, new_netns = -1;
+	char interface[IFNAMSIZ];
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		goto out;
+	if(pipe(pipefd) < 0) {
+		SYSERROR("pipe failed");
+		return NULL;
 	}
 
-	if (!enter_to_ns(c, &old_netns, &new_netns))
-		goto out;
+	pid = fork();
+	if (pid < 0) {
+		SYSERROR("failed to fork task to get interfaces information\n");
+		close(pipefd[0]);
+		close(pipefd[1]);
+		return NULL;
+	}
 
-	/* Grab the list of interfaces */
-	if (getifaddrs(&interfaceArray)) {
-		SYSERROR("failed to get interfaces list");
-		goto out;
+	if (pid == 0) { // child
+		int ret = 1, nbytes;
+		struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+
+		/* close the read-end of the pipe */
+		close(pipefd[0]);
+
+		if (!enter_to_ns(c)) {
+			SYSERROR("failed to enter namespace");
+			goto out;
+		}
+
+		/* Grab the list of interfaces */
+		if (getifaddrs(&interfaceArray)) {
+			SYSERROR("failed to get interfaces list");
+			goto out;
+		}
+
+		/* Iterate through the interfaces */
+		for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
+			nbytes = write(pipefd[1], tempIfAddr->ifa_name, IFNAMSIZ);
+			if (nbytes < 0) {
+				ERROR("write failed");
+				goto out;
+			}
+			count++;
+		}
+		ret = 0;
+
+	out:
+		if (interfaceArray)
+			freeifaddrs(interfaceArray);
+
+		/* close the write-end of the pipe, thus sending EOF to the reader */
+		close(pipefd[1]);
+		exit(ret);
 	}
 
-	/* Iterate through the interfaces */
-	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
-		if (array_contains(&interfaces, tempIfAddr->ifa_name, count))
-			continue;
+	/* close the write-end of the pipe */
+	close(pipefd[1]);
 
-		if(!add_to_array(&interfaces, tempIfAddr->ifa_name, count))
-			goto err;
+	while (read(pipefd[0], &interface, IFNAMSIZ) > 0) {
+		if (array_contains(&interfaces, interface, count))
+				continue;
+
+		if(!add_to_array(&interfaces, interface, count))
+			ERROR("PARENT: add_to_array failed");
 		count++;
 	}
 
-out:
-	if (interfaceArray)
-		freeifaddrs(interfaceArray);
+	if (wait_for_pid(pid) != 0) {
+		for(i=0;i<count;i++)
+			free(interfaces[i]);
+		free(interfaces);
+		interfaces = NULL;
+	}
 
-	exit_from_ns(c, &old_netns, &new_netns);
+	/* close the read-end of the pipe */
+	close(pipefd[0]);
 
 	/* Append NULL to the array */
 	if(interfaces)
 		interfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);
 
 	return interfaces;
-
-err:
-	for(i=0;i<count;i++)
-		free(interfaces[i]);
-	free(interfaces);
-	interfaces = NULL;
-	goto out;
 }
 
 static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
 {
-	int i, count = 0;
-	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
-	char addressOutputBuffer[INET6_ADDRSTRLEN];
-	void *tempAddrPtr = NULL;
+	pid_t pid;
+	int i, count = 0, pipefd[2];
 	char **addresses = NULL;
-	char *address = NULL;
-	int old_netns = -1, new_netns = -1;
+	char address[INET6_ADDRSTRLEN];
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		goto out;
+	if(pipe(pipefd) < 0) {
+		SYSERROR("pipe failed");
+		return NULL;
 	}
 
-	if (!enter_to_ns(c, &old_netns, &new_netns))
-		goto out;
-
-	/* Grab the list of interfaces */
-	if (getifaddrs(&interfaceArray)) {
-		SYSERROR("failed to get interfaces list");
-		goto out;
+	pid = fork();
+	if (pid < 0) {
+		SYSERROR("failed to fork task to get container ips\n");
+		close(pipefd[0]);
+		close(pipefd[1]);
+		return NULL;
 	}
 
-	/* Iterate through the interfaces */
-	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
-		if (tempIfAddr->ifa_addr == NULL)
-			continue;
+	if (pid == 0) { // child
+		int ret = 1, nbytes;
+		struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+		char addressOutputBuffer[INET6_ADDRSTRLEN];
+		void *tempAddrPtr = NULL;
+		char *address = NULL;
 
-		if(tempIfAddr->ifa_addr->sa_family == AF_INET) {
-			if (family && strcmp(family, "inet"))
-				continue;
-			tempAddrPtr = &((struct sockaddr_in *)tempIfAddr->ifa_addr)->sin_addr;
+		/* close the read-end of the pipe */
+		close(pipefd[0]);
+
+		if (!enter_to_ns(c)) {
+			SYSERROR("failed to enter namespace");
+			goto out;
 		}
-		else {
-			if (family && strcmp(family, "inet6"))
+
+		/* Grab the list of interfaces */
+		if (getifaddrs(&interfaceArray)) {
+			SYSERROR("failed to get interfaces list");
+			goto out;
+		}
+
+		/* Iterate through the interfaces */
+		for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
+			if (tempIfAddr->ifa_addr == NULL)
 				continue;
 
-			if (((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_scope_id != scope)
+			if(tempIfAddr->ifa_addr->sa_family == AF_INET) {
+				if (family && strcmp(family, "inet"))
+					continue;
+				tempAddrPtr = &((struct sockaddr_in *)tempIfAddr->ifa_addr)->sin_addr;
+			}
+			else {
+				if (family && strcmp(family, "inet6"))
+					continue;
+
+				if (((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_scope_id != scope)
+					continue;
+
+				tempAddrPtr = &((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_addr;
+			}
+
+			if (interface && strcmp(interface, tempIfAddr->ifa_name))
+				continue;
+			else if (!interface && strcmp("lo", tempIfAddr->ifa_name) == 0)
 				continue;
 
-			tempAddrPtr = &((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_addr;
+			address = (char *)inet_ntop(tempIfAddr->ifa_addr->sa_family,
+						tempAddrPtr,
+						addressOutputBuffer,
+						sizeof(addressOutputBuffer));
+			if (!address)
+					continue;
+
+			nbytes = write(pipefd[1], address, INET6_ADDRSTRLEN);
+			if (nbytes < 0) {
+				ERROR("write failed");
+				goto out;
+			}
+			count++;
 		}
+		ret = 0;
 
-		if (interface && strcmp(interface, tempIfAddr->ifa_name))
-			continue;
-		else if (!interface && strcmp("lo", tempIfAddr->ifa_name) == 0)
-			continue;
+	out:
+		if(interfaceArray)
+			freeifaddrs(interfaceArray);
 
-		address = (char *)inet_ntop(tempIfAddr->ifa_addr->sa_family,
-					   tempAddrPtr,
-					   addressOutputBuffer,
-					   sizeof(addressOutputBuffer));
-		if (!address)
-			continue;
+		/* close the write-end of the pipe, thus sending EOF to the reader */
+		close(pipefd[1]);
+		exit(ret);
+    }
+
+	/* close the write-end of the pipe */
+	close(pipefd[1]);
 
+	while (read(pipefd[0], &address, INET6_ADDRSTRLEN) > 0) {
 		if(!add_to_array(&addresses, address, count))
-			goto err;
+			ERROR("PARENT: add_to_array failed");
 		count++;
 	}
 
-out:
-	if(interfaceArray)
-		freeifaddrs(interfaceArray);
+	if (wait_for_pid(pid) != 0) {
+		for(i=0;i<count;i++)
+			free(addresses[i]);
+		free(addresses);
+		addresses = NULL;
+	}
 
-	exit_from_ns(c, &old_netns, &new_netns);
+	/* close the read-end of the pipe */
+	close(pipefd[0]);
 
 	/* Append NULL to the array */
 	if(addresses)
 		addresses = (char **)lxc_append_null_to_array((void **)addresses, count);
 
 	return addresses;
-
-err:
-	for(i=0;i<count;i++)
-		free(addresses[i]);
-	free(addresses);
-	addresses = NULL;
-
-	goto out;
 }
 
 static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)

commit c4b9dc3bddb799b7acc06f1e9cb2d32e84808a85
Author: S.alar Onur <caglar@10ur.org>
Date:   Mon Jan 20 23:43:35 2014 -0500

    remove no-longer neeeded check from lxcapi_attach_run_waitl
    
    commit f4364484454c754ed905bfb85bd2727a0a5d0475 introduced attach
    functionality to unprivileged containers so remove this check like
    the rest of the attach functions.
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 38cf24e..794d278 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3037,11 +3037,6 @@ static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return -1;
-	}
-
 	va_start(ap, arg);
 	argv = lxc_va_arg_list_to_argv_const(ap, 1);
 	va_end(ap);

commit f4364484454c754ed905bfb85bd2727a0a5d0475
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Jan 20 15:26:15 2014 -0500

    attach: Support unprivileged containers
    
    This change makes lxc-attach and the matching API functions work
    properly with unprivileged containers.
    
    The trick needed to make that possible was to always start with the
    userns when attaching and also relocate the cgroup management code so
    that the intermediate process is moved to the cgroup before attaching to
    the container's namespace as doing so later would fail due to missing
    permissions.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 368cb46..38cf24e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2567,11 +2567,6 @@ static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_functio
 	if (!c)
 		return -1;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return -1;
-	}
-
 	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
 }
 
@@ -2584,11 +2579,6 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
-	if (am_unpriv()) {
-		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
-		return -1;
-	}
-
 	command.program = (char*)program;
 	command.argv = (char**)argv;
 	r = lxc_attach(c->name, c->config_path, lxc_attach_run_command, &command, options, &pid);

commit c868b261b2e08f29c5e6c5ede2e6a2c3e335ee4d
Author: S.alar Onur <caglar@10ur.org>
Date:   Sun Jan 19 15:28:05 2014 -0500

    handle unprivileged user calls more gracefully (v3)
    
    Return an error if the function is not supposed to be called by an unprivileged user.
    Otherwise those calls fail in the middle of their execution with different reasons.
    
    changes since v2:
    - am_unpriv is now a simple geteuid check,
    - API functions are now providing error messages,
    - lxc-info, lxc-attach are now checking geteuidi,
    - lxc-ls is now calling get_ips only if the container is running
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0bebdff..368cb46 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -62,8 +62,14 @@
 
 #define MAX_BUFFER 4096
 
+#define NOT_SUPPORTED_ERROR "the requested function %s is not currently supported with unprivileged containers"
+
 lxc_log_define(lxc_container, lxc);
 
+inline static bool am_unpriv() {
+	return geteuid() != 0;
+}
+
 static bool file_exists(const char *f)
 {
 	struct stat statbuf;
@@ -1489,6 +1495,11 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 	char **interfaces = NULL;
 	int old_netns = -1, new_netns = -1;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		goto out;
+	}
+
 	if (!enter_to_ns(c, &old_netns, &new_netns))
 		goto out;
 
@@ -1538,6 +1549,11 @@ static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, con
 	char *address = NULL;
 	int old_netns = -1, new_netns = -1;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		goto out;
+	}
+
 	if (!enter_to_ns(c, &old_netns, &new_netns))
 		goto out;
 
@@ -1818,7 +1834,7 @@ static int lxc_rmdir_onedev_wrapper(void *data)
 static bool lxcapi_destroy(struct lxc_container *c)
 {
 	struct bdev *r = NULL;
-	bool bret = false, am_unpriv;
+	bool bret = false;
 	int ret;
 
 	if (!c || !lxcapi_is_defined(c))
@@ -1833,14 +1849,12 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	am_unpriv = c->lxc_conf && geteuid() != 0 && !lxc_list_empty(&c->lxc_conf->id_map);
-
 	if (c->lxc_conf && has_snapshots(c)) {
 		ERROR("container %s has dependent snapshots", c->name);
 		goto out;
 	}
 
-	if (!am_unpriv && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
+	if (!am_unpriv() && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 		if (r) {
 			if (r->ops->destroy(r) < 0) {
@@ -1857,7 +1871,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	const char *p1 = lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
-	if (am_unpriv)
+	if (am_unpriv())
 		ret = userns_exec_1(c->lxc_conf, lxc_rmdir_onedev_wrapper, path);
 	else
 		ret = lxc_rmdir_onedev(path);
@@ -2406,6 +2420,11 @@ static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *n
 	if (!c || !c->is_defined(c))
 		return NULL;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return NULL;
+	}
+
 	if (container_mem_lock(c))
 		return NULL;
 
@@ -2515,6 +2534,11 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 	if (!c || !c->name || !c->config_path)
 		return false;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
+
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -2543,6 +2567,11 @@ static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_functio
 	if (!c)
 		return -1;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return -1;
+	}
+
 	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
 }
 
@@ -2555,6 +2584,11 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return -1;
+	}
+
 	command.program = (char*)program;
 	command.argv = (char**)argv;
 	r = lxc_attach(c->name, c->config_path, lxc_attach_run_command, &command, options, &pid);
@@ -2587,6 +2621,11 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	struct lxc_container *c2;
 	char snappath[MAXPATHLEN], newname[20];
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return -1;
+	}
+
 	// /var/lib/lxc -> /var/lib/lxcsnaps \0
 	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
@@ -2724,6 +2763,12 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 
 	if (!c || !lxcapi_is_defined(c))
 		return -1;
+
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return -1;
+	}
+
 	// snappath is ${lxcpath}snaps/${lxcname}/
 	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
@@ -2802,6 +2847,11 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
+
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev) {
 		ERROR("Failed to find original backing store type");
@@ -2851,6 +2901,11 @@ static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapnam
 	if (!c || !c->name || !c->config_path)
 		return false;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
+
 	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		goto err;
@@ -2967,11 +3022,19 @@ out:
 
 static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
 	return add_remove_device_node(c, src_path, dest_path, true);
 }
 
 static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return false;
+	}
 	return add_remove_device_node(c, src_path, dest_path, false);
 }
 
@@ -2984,6 +3047,11 @@ static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t
 	if (!c)
 		return -1;
 
+	if (am_unpriv()) {
+		ERROR(NOT_SUPPORTED_ERROR, __FUNCTION__);
+		return -1;
+	}
+
 	va_start(ap, arg);
 	argv = lxc_va_arg_list_to_argv_const(ap, 1);
 	va_end(ap);

commit 05e5d7dc9b911b9f1da125fb554de4611d2d1d9b
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Sun Jan 19 12:31:57 2014 -0500

    Revert "lxc-start: fix the container leak when daemonize"
    
    This reverts commit c3f0f139e155f53c83e0a81f14094e9d0f40e8e9.
    
    Done as Serge Hallyn's request:
     Nacked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ddea0d7..0bebdff 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -632,10 +632,12 @@ reboot:
 		goto reboot;
 	}
 
-	if (daemonize)
+	if (daemonize) {
 		lxc_container_put(c);
-	
-	return (ret == 0 ? true : false);
+		exit (ret == 0 ? true : false);
+	} else {
+		return (ret == 0 ? true : false);
+	}
 }
 
 /*

commit c3f0f139e155f53c83e0a81f14094e9d0f40e8e9
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Sat Jan 18 14:59:58 2014 +0800

    lxc-start: fix the container leak when daemonize
    
    When start container with daemon model, we'll have a new daemon
    process in lxcapi_start, whose c->numthreads is 2, inherited
    from his father. Even his father return to main(), the
    lxc_container_put won't affect son's numthreads.
    
    So when daemon stops, he should return to main and do
    lxc_container_put again, rather than exit and leave the
    container alone.
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0bebdff..ddea0d7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -632,12 +632,10 @@ reboot:
 		goto reboot;
 	}
 
-	if (daemonize) {
+	if (daemonize)
 		lxc_container_put(c);
-		exit (ret == 0 ? true : false);
-	} else {
-		return (ret == 0 ? true : false);
-	}
+	
+	return (ret == 0 ? true : false);
 }
 
 /*

commit b022744452e07085a6b0fd1d110fee77263a2581
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Wed Jan 15 10:45:18 2014 +0800

    lxccontainer.c: check lxc_conf before referance haltsignal
    
    If we start container with rcfile(see comments in lxc_start.c), it
    is possible that we have no config file in /usr/local/var/lib/lxc.
    So when we try lxc_stop, lxc_container_new will not load any config
    so we'll get c->lxc_conf = NULL.
    
    In that case, we'll get Segmentation fault in lxcapi_shutdown, a
    simple check would fix this.
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8462ba5..0bebdff 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1313,7 +1313,7 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	pid = c->init_pid(c);
 	if (pid <= 0)
 		return true;
-	if (c->lxc_conf->haltsignal)
+	if (c->lxc_conf && c->lxc_conf->haltsignal)
 		haltsignal = c->lxc_conf->haltsignal;
 	kill(pid, haltsignal);
 	retv = c->wait(c, "STOPPED", timeout);

commit c8ad5f4623bb5e61b1065047a22b90182daa2e66
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jan 13 11:08:48 2014 -0600

    api change: default container->daemonize to true
    
    Pretty much the only case where we do NOT want to daemonize
    a container start is lxc-start.  So make c->daemonize true
    by default, and have lxc-start set it to false.
    
    If there are existing API users who rely on daemonize by
    default, then they will be broken by this.  It seems we should
    do this before beta1 if we're going to do it.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e553415..8462ba5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3052,6 +3052,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		lxcapi_destroy(c);
 		lxcapi_clear_config(c);
 	}
+	c->daemonize = true;
 
 	// assign the member functions
 	c->is_defined = lxcapi_is_defined;

commit 40131a0367658ba6a171d52ef7522df9903b66b1
Author: Luka Perkov <luka.perkov@sartura.hr>
Date:   Mon Jan 13 17:46:55 2014 +0000

    include: remove duplicates
    
    Signed-off-by: Luka Perkov <luka.perkov@sartura.hr>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ab97eef..e553415 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -50,7 +50,6 @@
 #include "bdev.h"
 #include "utils.h"
 #include "attach.h"
-#include "utils.h"
 #include "monitor.h"
 #include "namespace.h"
 #include "lxclock.h"

commit 0f71e1bf61a7ad793bc3e35bcb3c82a86387eab1
Author: Luka Perkov <luka.perkov@sartura.hr>
Date:   Mon Jan 13 17:46:50 2014 +0000

    include: cleanup unnecessary getline defines
    
    The removed chunk is already defined in utils.h which
    is included in modified files.
    
    Signed-off-by: Luka Perkov <luka.perkov@sartura.hr>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 48fef74..ab97eef 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -61,12 +61,6 @@
 #include <../include/ifaddrs.h>
 #endif
 
-#ifndef HAVE_GETLINE
-#ifdef HAVE_FGETLN
-#include <../include/getline.h>
-#endif
-#endif
-
 #define MAX_BUFFER 4096
 
 lxc_log_define(lxc_container, lxc);

commit dad87e3bd14e9bfb0ae415db192856c7b6095980
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Jan 9 18:05:22 2014 -0500

    Drop usage of LXC_DEFAULT_CONFIG in our code
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index faa0a9f..48fef74 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1186,8 +1186,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	}
 
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, LXC_DEFAULT_CONFIG)) {
-			ERROR("Error loading default configuration file %s\n", LXC_DEFAULT_CONFIG);
+		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+			ERROR("Error loading default configuration file %s\n", lxc_global_config_value("lxc.default_config"));
 			goto free_tpath;
 		}
 	}
@@ -1658,8 +1658,8 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 
 	// If we haven't yet loaded a config, load the stock config
 	if (!c->lxc_conf) {
-		if (!c->load_config(c, LXC_DEFAULT_CONFIG)) {
-			ERROR("Error loading default configuration file %s while saving %s\n", LXC_DEFAULT_CONFIG, c->name);
+		if (!c->load_config(c, lxc_global_config_value("lxc.default_config"))) {
+			ERROR("Error loading default configuration file %s while saving %s\n", lxc_global_config_value("lxc.default_config"), c->name);
 			return false;
 		}
 	}

commit 593e84786e2b4709059989bee489deab5c923779
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Thu Jan 9 17:31:52 2014 -0500

    Re-organize API for global lxc.conf config
    
    Instead of having one function for each possible key in lxc.conf which
    doesn't really scale and requires an API update for every new key,
    switch to a generic lxc_get_global_config_item() function which takes a
    key name as argument.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f999cfc..faa0a9f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2035,24 +2035,9 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	return ret;
 }
 
-const char *lxc_get_default_config_path(void)
+const char *lxc_get_global_config_item(const char *key)
 {
-	return default_lxc_path();
-}
-
-const char *lxc_get_default_lvm_vg(void)
-{
-	return default_lvm_vg();
-}
-
-const char *lxc_get_default_lvm_thin_pool(void)
-{
-	return default_lvm_thin_pool();
-}
-
-const char *lxc_get_default_zfs_root(void)
-{
-	return default_zfs_root();
+	return lxc_global_config_value(key);
 }
 
 const char *lxc_get_version(void)
@@ -3035,7 +3020,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	if (configpath)
 		c->config_path = strdup(configpath);
 	else
-		c->config_path = strdup(default_lxc_path());
+		c->config_path = strdup(lxc_global_config_value("lxc.lxcpath"));
 
 	if (!c->config_path) {
 		fprintf(stderr, "Out of memory");
@@ -3157,7 +3142,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 	struct lxc_container *c;
 
 	if (!lxcpath)
-		lxcpath = default_lxc_path();
+		lxcpath = lxc_global_config_value("lxc.lxcpath");
 
 	dir = opendir(lxcpath);
 	if (!dir) {
@@ -3247,7 +3232,7 @@ int list_active_containers(const char *lxcpath, char ***nret,
 	struct lxc_container *c;
 
 	if (!lxcpath)
-		lxcpath = default_lxc_path();
+		lxcpath = lxc_global_config_value("lxc.lxcpath");
 	lxcpath_len = strlen(lxcpath);
 
 	if (cret)

commit d659597e03725411c366c42dc02c64c0c35a167a
Author: Stephen Ayotte <stephen.ayotte@gmail.com>
Date:   Thu Jan 2 14:30:26 2014 -0500

    Support large bdevs on 32-bit; MB units by default.
    
    Change all instances of "unsigned long" where referring to a bdev size
    to uint64_t; this fixes some overflows on 32-bit machines, where
    "unsigned long" is uint32_t. Support all unit-sizes supported by LVM
    except 's' and 'e' [bkmgt]. Print a warning and use default bdev-size if
    invalid unit-size specified.
    
    Signed-off-by: Stephen Ayotte <stephen.ayotte@gmail.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 353b733..f999cfc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -33,6 +33,7 @@
 #include <sched.h>
 #include <arpa/inet.h>
 #include <libgen.h>
+#include <stdint.h>
 
 #include <lxc/lxccontainer.h>
 #include <lxc/version.h>
@@ -2276,7 +2277,7 @@ static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)
 }
 
 static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
-		const char *newtype, int flags, const char *bdevdata, unsigned long newsize)
+		const char *newtype, int flags, const char *bdevdata, uint64_t newsize)
 {
 	struct bdev *bdev;
 	int need_rdep;
@@ -2415,7 +2416,7 @@ static int create_file_dirname(char *path)
 
 static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
-		const char *bdevtype, const char *bdevdata, unsigned long newsize,
+		const char *bdevtype, const char *bdevdata, uint64_t newsize,
 		char **hookargs)
 {
 	struct lxc_container *c2 = NULL;

commit f0f1d8c076ae93d8ecf735c2eeae471e27ca6abd
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Jan 6 12:30:02 2014 -0500

    add lxc.haltsignal for soft shutdown
    
    - use this in the busybox template since busybox's init expects
      to receive SIGUSR1 to halt
    
    - fix lxc.stopsignal to be output by write_config so lxcapi_clone()
      and lxcapi_save_config() will output it
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 132f1a3..353b733 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1307,6 +1307,7 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 {
 	bool retv;
 	pid_t pid;
+	int haltsignal = SIGPWR;
 
 	if (!c)
 		return false;
@@ -1318,7 +1319,9 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	pid = c->init_pid(c);
 	if (pid <= 0)
 		return true;
-	kill(pid, SIGPWR);
+	if (c->lxc_conf->haltsignal)
+		haltsignal = c->lxc_conf->haltsignal;
+	kill(pid, haltsignal);
 	retv = c->wait(c, "STOPPED", timeout);
 	if (!retv && timeout > 0) {
 		c->stop(c);

commit 67c4fe9b2dc41b843dbac1b3b38ea96e4d2b6a07
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Jan 6 09:45:18 2014 -0500

    Revert "Revert "Use pthread_atfork() to unlock mutexes after fork()""
    
    This reverts commit 64b1be2903078ef9e9ba3ffcbc30a4dc9bc5cc6c.
    
    Reverting in preparation for another implementation which is
    bionic-compatible.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 75f6ce3..132f1a3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -601,7 +601,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		if (pid != 0)
 			return wait_on_daemonized_start(c, pid);
 
-		process_unlock(); // we're no longer sharing
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {
@@ -839,7 +838,6 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		char **newargv;
 		struct lxc_conf *conf = c->lxc_conf;
 
-		process_unlock(); // we're no longer sharing
 		if (quiet) {
 			close(0);
 			close(1);
@@ -1236,7 +1234,6 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (pid == 0) { // child
 		struct bdev *bdev = NULL;
 
-		process_unlock(); // we're no longer sharing
 		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
 			ERROR("Error creating backing store type %s for %s",
 				bdevtype ? bdevtype : "(none)", c->name);
@@ -2328,7 +2325,6 @@ static int clone_update_rootfs(struct lxc_container *c0,
 	if (pid > 0)
 		return wait_for_pid(pid);
 
-	process_unlock(); // we're no longer sharing
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
 		exit(1);

commit 0a83cbbb7592ccb4901a790e7677884d728df6f7
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jan 1 13:43:35 2014 -0600

    snapshot: enforce keeping same backing store type (v2)
    
    Stphane noticed that lxc-snapshot of a dir-backed container
    created an overlayfs container.  The expectation is that the
    user can continue to modify the original container and later make
    a new snapshot, but this doesn't work with the existing behavior -
    the overlayfs clone will end up with the modified contents.
    
    So add a 'LXC_CLONE_KEEPBDEVTYPE' flag, which c->snapshot()
    passes to c->clone().
    
    Also add a LXC_CLONE_MAYBE_SNAPSHOT.  If this is set and a
    backing store does not support snapshotting, then proceed with
    a copy clone.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e991e59..75f6ce3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2282,7 +2282,7 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	int need_rdep;
 
 	bdev = bdev_copy(c0->lxc_conf->rootfs.path, c0->name, c->name,
-			c0->config_path, c->config_path, newtype, !!(flags & LXC_CLONE_SNAPSHOT),
+			c0->config_path, c->config_path, newtype, flags,
 			bdevdata, newsize, &need_rdep);
 	if (!bdev) {
 		ERROR("Error copying storage");
@@ -2624,7 +2624,12 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 	if (ret < 0 || ret >= 20)
 		return -1;
 
-	flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME;
+	/*
+	 * We pass LXC_CLONE_SNAPSHOT to make sure that a rdepends file entry is
+	 * created in the original container
+	 */
+	flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME |
+		LXC_CLONE_KEEPBDEVTYPE | LXC_CLONE_MAYBE_SNAPSHOT;
 	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
 	if (!c2) {
 		ERROR("clone of %s:%s failed\n", c->config_path, c->name);

commit 74a3920a972e837263436bd67a73eabd42754124
Author: Andrey Mazo <mazo@telum.ru>
Date:   Tue Dec 24 21:08:13 2013 +0400

    Mark functions as static and arguments/arrays as const where possible
    
    Mark most of functions that are used within only one file as static.
    After 95ee490bbdb97ab2b4f1dfa63a0a26e0dd1c2f17 it's easy to prove they
    are not in public API.
    Several arrays and structs are also marked static.
    This prevents them from being exported from liblxc.so
    
    List of removed previously exported symbols:
    bdevs
    btrfs_ops
    check_autodev
    create_partial
    dir_ops
    dump_stacktrace
    get_mapped_rootid
    get_next_index
    lock_mutex
    loop_ops
    lvm_ops
    lxc_abort
    lxcapi_clone
    lxc_attach_drop_privs
    lxc_attach_get_init_uidgi
    lxc_attach_getpwshell
    lxc_attach_remount_sys_pr
    lxc_attach_set_environmen
    lxc_attach_to_ns
    lxc_clear_saved_nics
    lxc_config_readline
    lxc_devs
    lxc_free_idmap
    lxc_global_config_value
    lxc_poll
    lxc_proc_get_context_info
    lxc_set_state
    lxc_spawn
    mk_devtmpfs
    mount_check_fs
    ongoing_create
    overlayfs_destroy
    overlayfs_ops
    prepend_lxc_header
    remove_partial
    save_phys_nics
    setup_pivot_root
    signames
    static_mutex
    thread_mutex
    unlock_mutex
    unpriv_assign_nic
    zfs_ops
    
    Signed-off-by: Andrey Mazo <mazo@telum.ru>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b62f7ba..e991e59 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -99,7 +99,7 @@ static bool config_file_exists(const char *lxcpath, const char *cname)
  * we remove that file.  When we load or try to start a container, if
  * we find that file, without a flock, we remove the container.
  */
-int ongoing_create(struct lxc_container *c)
+static int ongoing_create(struct lxc_container *c)
 {
 	int len = strlen(c->config_path) + strlen(c->name) + 10;
 	char *path = alloca(len);
@@ -135,7 +135,7 @@ int ongoing_create(struct lxc_container *c)
 	return 2;
 }
 
-int create_partial(struct lxc_container *c)
+static int create_partial(struct lxc_container *c)
 {
 	// $lxcpath + '/' + $name + '/partial' + \0
 	int len = strlen(c->config_path) + strlen(c->name) + 10;
@@ -165,7 +165,7 @@ int create_partial(struct lxc_container *c)
 	return fd;
 }
 
-void remove_partial(struct lxc_container *c, int fd)
+static void remove_partial(struct lxc_container *c, int fd)
 {
 	// $lxcpath + '/' + $name + '/partial' + \0
 	int len = strlen(c->config_path) + strlen(c->name) + 10;
@@ -1037,7 +1037,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 	return true;
 }
 
-bool prepend_lxc_header(char *path, const char *t, char *const argv[])
+static bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 {
 	long flen;
 	char *contents;
@@ -2414,7 +2414,7 @@ static int create_file_dirname(char *path)
 	return ret;
 }
 
-struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+static struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
 		const char *bdevtype, const char *bdevdata, unsigned long newsize,
 		char **hookargs)
@@ -2587,7 +2587,7 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	return lxc_wait_for_pid_status(pid);
 }
 
-int get_next_index(const char *lxcpath, char *cname)
+static int get_next_index(const char *lxcpath, char *cname)
 {
 	char *fname;
 	struct stat sb;

commit 64b1be2903078ef9e9ba3ffcbc30a4dc9bc5cc6c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Jan 2 09:40:16 2014 -0600

    Revert "Use pthread_atfork() to unlock mutexes after fork()"
    
    This reverts commit 84e9e197933e601b66480da578b92630ebedfc72, because
    it breaks bionic builds.  The patch is desirable so hopefully we can
    come up with a solution or alternate patch soon.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e1cbd76..b62f7ba 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -601,6 +601,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		if (pid != 0)
 			return wait_on_daemonized_start(c, pid);
 
+		process_unlock(); // we're no longer sharing
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {
@@ -838,6 +839,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		char **newargv;
 		struct lxc_conf *conf = c->lxc_conf;
 
+		process_unlock(); // we're no longer sharing
 		if (quiet) {
 			close(0);
 			close(1);
@@ -1234,6 +1236,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (pid == 0) { // child
 		struct bdev *bdev = NULL;
 
+		process_unlock(); // we're no longer sharing
 		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
 			ERROR("Error creating backing store type %s for %s",
 				bdevtype ? bdevtype : "(none)", c->name);
@@ -2325,6 +2328,7 @@ static int clone_update_rootfs(struct lxc_container *c0,
 	if (pid > 0)
 		return wait_for_pid(pid);
 
+	process_unlock(); // we're no longer sharing
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
 		exit(1);

commit 84e9e197933e601b66480da578b92630ebedfc72
Author: Andrey Mazo <mazo@telum.ru>
Date:   Mon Dec 30 15:06:25 2013 +0400

    Use pthread_atfork() to unlock mutexes after fork()
    
    Signed-off-by: Andrey Mazo <mazo@telum.ru>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b62f7ba..e1cbd76 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -601,7 +601,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		if (pid != 0)
 			return wait_on_daemonized_start(c, pid);
 
-		process_unlock(); // we're no longer sharing
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {
@@ -839,7 +838,6 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		char **newargv;
 		struct lxc_conf *conf = c->lxc_conf;
 
-		process_unlock(); // we're no longer sharing
 		if (quiet) {
 			close(0);
 			close(1);
@@ -1236,7 +1234,6 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (pid == 0) { // child
 		struct bdev *bdev = NULL;
 
-		process_unlock(); // we're no longer sharing
 		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
 			ERROR("Error creating backing store type %s for %s",
 				bdevtype ? bdevtype : "(none)", c->name);
@@ -2328,7 +2325,6 @@ static int clone_update_rootfs(struct lxc_container *c0,
 	if (pid > 0)
 		return wait_for_pid(pid);
 
-	process_unlock(); // we're no longer sharing
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
 		exit(1);

commit f2363e38d07db2ad4796b5580b95e3665ed34a88
Author: S.alar Onur <caglar@10ur.org>
Date:   Wed Dec 25 14:27:11 2013 -0500

    adjust include statements (v2)
    
    Use "#include <somefile.h>" style for external or exported headers only.
    
    changes since v1:
     - adjusted formatting as Stphane suggested
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e1d004f..b62f7ba 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -30,26 +30,28 @@
 #include <fcntl.h>
 #include <sched.h>
 #include <dirent.h>
+#include <sched.h>
+#include <arpa/inet.h>
+#include <libgen.h>
+
+#include <lxc/lxccontainer.h>
+#include <lxc/version.h>
+
 #include "config.h"
 #include "lxc.h"
 #include "state.h"
-#include <lxc/lxccontainer.h>
 #include "conf.h"
 #include "confile.h"
 #include "console.h"
 #include "cgroup.h"
 #include "commands.h"
-#include "version.h"
 #include "log.h"
 #include "bdev.h"
 #include "utils.h"
 #include "attach.h"
-#include <lxc/utils.h>
-#include <lxc/monitor.h>
-#include <lxc/namespace.h>
-#include <sched.h>
-#include <arpa/inet.h>
-#include <libgen.h>
+#include "utils.h"
+#include "monitor.h"
+#include "namespace.h"
 #include "lxclock.h"
 
 #if HAVE_IFADDRS_H

commit dd1d77f91b3eb5b9b02f97d81c6c1c6c29563c03
Author: Andrey Mazo <mazo@telum.ru>
Date:   Tue Dec 24 14:44:53 2013 +0400

    Remove process_lock() except where actually needed
    
    Functions like open(), close(), socket(), socketpair(), pipe() and mkdir()
    are generally thin wrappers around kernel-provided system calls.
    It's the kernel not libc, who ensures race-free handling of file
    descriptors.
    Thus locking around these functions is unnecessary even on somewhat buggy libcs.
    
    fopen(), fclose() and other stdio functions may maintain internal lists
    of open file handles and thus can be prone to race-conditions.
    Hopefully, most libcs utilize proper locking or other ways to ensure
    thread-safety of these functions.
    Bionic used to have non-thread-safe stdio [2] but that must be fixed
    since android 4.3 [3, 4].
    
    S.alar Onur showed [1] that openpty() (because of nsswitch) is not thread-safe though.
    So we workaround it by protecting openpty() calls with process_lock()/process_unlock().
    
    Because of the need to guard openpty() with process_lock()/process_unlock(),
    process_unlock() is still used after fork().
    
    This commit reverts most of 025ed0f3911836b71f498d8368725c77a7e1932a.
    
    [1] https://github.com/lxc/lxc/pull/106#issuecomment-31077269
    [2] https://bugzilla.mozilla.org/show_bug.cgi?id=687367
    [3] https://android.googlesource.com/platform/bionic/+/f582340a6a48588aa50da17e1620e8f91b146941
    [4] https://android.googlesource.com/platform/bionic/+/6b3f49a5374305ce9690c3c5ca2aadc90f54c521
    
    Signed-off-by: Andrey Mazo <mazo@telum.ru>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 203f4a8..e1d004f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -112,9 +112,7 @@ int ongoing_create(struct lxc_container *c)
 
 	if (!file_exists(path))
 		return 0;
-	process_lock();
 	fd = open(path, O_RDWR);
-	process_unlock();
 	if (fd < 0) {
 		// give benefit of the doubt
 		SYSERROR("Error opening partial file");
@@ -127,15 +125,11 @@ int ongoing_create(struct lxc_container *c)
 	lk.l_pid = -1;
 	if (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {
 		// create is still ongoing
-		process_lock();
 		close(fd);
-		process_unlock();
 		return 1;
 	}
 	// create completed but partial is still there.
-	process_lock();
 	close(fd);
-	process_unlock();
 	return 2;
 }
 
@@ -152,10 +146,8 @@ int create_partial(struct lxc_container *c)
 		ERROR("Error writing partial pathname");
 		return -1;
 	}
-	process_lock();
 	if ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {
 		SYSERROR("Erorr creating partial file");
-		process_unlock();
 		return -1;
 	}
 	lk.l_type = F_WRLCK;
@@ -165,10 +157,8 @@ int create_partial(struct lxc_container *c)
 	if (fcntl(fd, F_SETLKW, &lk) < 0) {
 		SYSERROR("Error locking partial file %s", path);
 		close(fd);
-		process_unlock();
 		return -1;
 	}
-	process_unlock();
 
 	return fd;
 }
@@ -180,9 +170,7 @@ void remove_partial(struct lxc_container *c, int fd)
 	char *path = alloca(len);
 	int ret;
 
-	process_lock();
 	close(fd);
-	process_unlock();
 	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		ERROR("Error writing partial pathname");
@@ -518,9 +506,7 @@ static bool am_single_threaded(void)
 	DIR *dir;
 	int count=0;
 
-	process_lock();
 	dir = opendir("/proc/self/task");
-	process_unlock();
 	if (!dir) {
 		INFO("failed to open /proc/self/task");
 		return false;
@@ -538,9 +524,7 @@ static bool am_single_threaded(void)
 		if (++count > 1)
 			break;
 	}
-	process_lock();
 	closedir(dir);
-	process_unlock();
 	return count == 1;
 }
 
@@ -1063,9 +1047,7 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	char *tpath;
 #endif
 
-	process_lock();
 	f = fopen(path, "r");
-	process_unlock();
 	if (f == NULL)
 		return false;
 
@@ -1081,9 +1063,7 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		goto out_free_contents;
 
 	contents[flen] = '\0';
-	process_lock();
 	ret = fclose(f);
-	process_unlock();
 	f = NULL;
 	if (ret < 0)
 		goto out_free_contents;
@@ -1104,9 +1084,7 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	free(tpath);
 #endif
 
-	process_lock();
 	f = fopen(path, "w");
-	process_unlock();
 	if (f == NULL) {
 		SYSERROR("reopening config for writing");
 		free(contents);
@@ -1131,9 +1109,7 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");
 		free(contents);
-		process_lock();
 		fclose(f);
-		process_unlock();
 		return false;
 	}
 	ret = 0;
@@ -1142,9 +1118,7 @@ out_free_contents:
 out_error:
 	if (f) {
 		int newret;
-		process_lock();
 		newret = fclose(f);
-		process_unlock();
 		if (ret == 0)
 			ret = newret;
 	}
@@ -1400,12 +1374,10 @@ static inline void exit_from_ns(struct lxc_container *c, int *old_netns, int *ne
 	/* Switch back to original netns */
 	if (*old_netns >= 0 && setns(*old_netns, CLONE_NEWNET))
 		SYSERROR("failed to setns");
-	process_lock();
 	if (*new_netns >= 0)
 		close(*new_netns);
 	if (*old_netns >= 0)
 		close(*old_netns);
-	process_unlock();
 }
 
 static inline bool enter_to_ns(struct lxc_container *c, int *old_netns, int *new_netns) {
@@ -1416,9 +1388,7 @@ static inline bool enter_to_ns(struct lxc_container *c, int *old_netns, int *new
 		goto out;
 
 	/* Save reference to old netns */
-	process_lock();
 	*old_netns = open("/proc/self/ns/net", O_RDONLY);
-	process_unlock();
 	if (*old_netns < 0) {
 		SYSERROR("failed to open /proc/self/ns/net");
 		goto out;
@@ -1429,9 +1399,7 @@ static inline bool enter_to_ns(struct lxc_container *c, int *old_netns, int *new
 	if (ret < 0 || ret >= MAXPATHLEN)
 		goto out;
 
-	process_lock();
 	*new_netns = open(new_netns_path, O_RDONLY);
-	process_unlock();
 	if (*new_netns < 0) {
 		SYSERROR("failed to open %s", new_netns_path);
 		goto out;
@@ -1712,15 +1680,11 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	if (lret)
 		return false;
 
-	process_lock();
 	fout = fopen(alt_file, "w");
-	process_unlock();
 	if (!fout)
 		goto out;
 	write_config(fout, c->lxc_conf);
-	process_lock();
 	fclose(fout);
-	process_unlock();
 	ret = true;
 
 out:
@@ -1744,35 +1708,25 @@ static bool mod_rdep(struct lxc_container *c, bool inc)
 			c->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
-	process_lock();
 	f = fopen(path, "r");
-	process_unlock();
 	if (f) {
 		ret = fscanf(f, "%d", &v);
-		process_lock();
 		fclose(f);
-		process_unlock();
 		if (ret != 1) {
 			ERROR("Corrupted file %s", path);
 			goto out;
 		}
 	}
 	v += inc ? 1 : -1;
-	process_lock();
 	f = fopen(path, "w");
-	process_unlock();
 	if (!f)
 		goto out;
 	if (fprintf(f, "%d\n", v) < 0) {
 		ERROR("Error writing new snapshots value");
-		process_lock();
 		fclose(f);
-		process_unlock();
 		goto out;
 	}
-	process_lock();
 	ret = fclose(f);
-	process_unlock();
 	if (ret != 0) {
 		SYSERROR("Error writing to or closing snapshots file");
 		goto out;
@@ -1808,9 +1762,7 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 		ERROR("Path name too long");
 		return;
 	}
-	process_lock();
 	f = fopen(path, "r");
-	process_unlock();
 	if (f == NULL)
 		return;
 	while (getline(&lxcpath, &pathlen, f) != -1) {
@@ -1833,9 +1785,7 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 out:
 	if (lxcpath) free(lxcpath);
 	if (lxcname) free(lxcname);
-	process_lock();
 	fclose(f);
-	process_unlock();
 }
 
 static bool has_snapshots(struct lxc_container *c)
@@ -1849,15 +1799,11 @@ static bool has_snapshots(struct lxc_container *c)
 			c->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
-	process_lock();
 	f = fopen(path, "r");
-	process_unlock();
 	if (!f)
 		goto out;
 	ret = fscanf(f, "%d", &v);
-	process_lock();
 	fclose(f);
-	process_unlock();
 	if (ret != 1)
 		goto out;
 	bret = v != 0;
@@ -2128,21 +2074,15 @@ static int copy_file(const char *old, const char *new)
 		return -1;
 	}
 
-	process_lock();
 	in = open(old, O_RDONLY);
-	process_unlock();
 	if (in < 0) {
 		SYSERROR("Error opening original file %s", old);
 		return -1;
 	}
-	process_lock();
 	out = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);
-	process_unlock();
 	if (out < 0) {
 		SYSERROR("Error opening new file %s", new);
-		process_lock();
 		close(in);
-		process_unlock();
 		return -1;
 	}
 
@@ -2160,10 +2100,8 @@ static int copy_file(const char *old, const char *new)
 			goto err;
 		}
 	}
-	process_lock();
 	close(in);
 	close(out);
-	process_unlock();
 
 	// we set mode, but not owner/group
 	ret = chmod(new, sbuf.st_mode);
@@ -2175,10 +2113,8 @@ static int copy_file(const char *old, const char *new)
 	return 0;
 
 err:
-	process_lock();
 	close(in);
 	close(out);
-	process_unlock();
 	return -1;
 }
 
@@ -2229,17 +2165,13 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 static void new_hwaddr(char *hwaddr)
 {
 	FILE *f;
-	process_lock();
 	f = fopen("/dev/urandom", "r");
-	process_unlock();
 	if (f) {
 		unsigned int seed;
 		int ret = fread(&seed, sizeof(seed), 1, f);
 		if (ret != 1)
 			seed = time(NULL);
-		process_lock();
 		fclose(f);
-		process_unlock();
 		srand(seed);
 	} else
 		srand(time(NULL));
@@ -2329,19 +2261,15 @@ static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)
 		c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		return false;
-	process_lock();
 	f = fopen(path, "a");
-	process_unlock();
 	if (!f)
 		return false;
 	bret = true;
 	// if anything goes wrong, just return an error
 	if (fprintf(f, "%s\n%s\n", c0->config_path, c0->name) < 0)
 		bret = false;
-	process_lock();
 	if (fclose(f) != 0)
 		bret = false;
-	process_unlock();
 	return bret;
 }
 
@@ -2526,17 +2454,13 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	}
 
 	// copy the configuration, tweak it as needed,
-	process_lock();
 	fout = fopen(newpath, "w");
-	process_unlock();
 	if (!fout) {
 		SYSERROR("open %s", newpath);
 		goto out;
 	}
 	write_config(fout, c->lxc_conf);
-	process_lock();
 	fclose(fout);
-	process_unlock();
 
 	sprintf(newpath, "%s/%s/rootfs", l, n);
 	if (mkdir(newpath, 0755) < 0) {
@@ -2720,9 +2644,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 
 	char *dfnam = alloca(strlen(snappath) + strlen(newname) + 5);
 	sprintf(dfnam, "%s/%s/ts", snappath, newname);
-	process_lock();
 	f = fopen(dfnam, "w");
-	process_unlock();
 	if (!f) {
 		ERROR("Failed to open %s\n", dfnam);
 		return -1;
@@ -2732,9 +2654,7 @@ static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 		fclose(f);
 		return -1;
 	}
-	process_lock();
 	ret = fclose(f);
-	process_unlock();
 	if (ret != 0) {
 		SYSERROR("Writing timestamp");
 		return -1;
@@ -2788,9 +2708,7 @@ static char *get_timestamp(char* snappath, char *name)
 	ret = snprintf(path, MAXPATHLEN, "%s/%s/ts", snappath, name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		return NULL;
-	process_lock();
 	fin = fopen(path, "r");
-	process_unlock();
 	if (!fin)
 		return NULL;
 	(void) fseek(fin, 0, SEEK_END);
@@ -2807,9 +2725,7 @@ static char *get_timestamp(char* snappath, char *name)
 			}
 		}
 	}
-	process_lock();
 	fclose(fin);
-	process_unlock();
 	return s;
 }
 
@@ -2829,9 +2745,7 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 		ERROR("path name too long");
 		return -1;
 	}
-	process_lock();
 	dir = opendir(snappath);
-	process_unlock();
 	if (!dir) {
 		INFO("failed to open %s - assuming no snapshots", snappath);
 		return 0;
@@ -2874,10 +2788,8 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 		count++;
 	}
 
-	process_lock();
 	if (closedir(dir))
 		WARN("failed to close directory");
-	process_unlock();
 
 	*ret_snaps = snaps;
 	return count;
@@ -2889,10 +2801,8 @@ out_free:
 			lxcsnap_free(&snaps[i]);
 		free(snaps);
 	}
-	process_lock();
 	if (closedir(dir))
 		WARN("failed to close directory");
-	process_unlock();
 	return -1;
 }
 
@@ -3242,10 +3152,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 	if (!lxcpath)
 		lxcpath = default_lxc_path();
 
-	process_lock();
 	dir = opendir(lxcpath);
-	process_unlock();
-
 	if (!dir) {
 		SYSERROR("opendir on lxcpath");
 		return -1;
@@ -3304,9 +3211,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 		nfound++;
 	}
 
-	process_lock();
 	closedir(dir);
-	process_unlock();
 	return nfound;
 
 free_bad:
@@ -3320,9 +3225,7 @@ free_bad:
 			lxc_container_put((*cret)[i]);
 		free(*cret);
 	}
-	process_lock();
 	closedir(dir);
-	process_unlock();
 	return -1;
 }
 
@@ -3345,9 +3248,7 @@ int list_active_containers(const char *lxcpath, char ***nret,
 	if (nret)
 		*nret = NULL;
 
-	process_lock();
 	FILE *f = fopen("/proc/net/unix", "r");
-	process_unlock();
 	if (!f)
 		return -1;
 
@@ -3429,9 +3330,7 @@ out:
 	if (line)
 		free(line);
 
-	process_lock();
 	fclose(f);
-	process_unlock();
 	return ret;
 }
 

commit 619256b5ee8bf68bf670cd60b0723b94ce069121
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Dec 21 14:48:41 2013 -0500

    remove LXC_CLONE_COPYHOOKS and make lxcapi_clone to copy hooks unconditionally (v3)
    
    changes since v1;
    	incorporated Serge's changes
    changes since v2;
    	added missing Signed-off-by
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1af8d62..203f4a8 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2184,9 +2184,15 @@ err:
 
 static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 {
-	int i;
-	int ret;
+	int i, len, ret;
 	struct lxc_list *it;
+	char *cpath;
+
+	len = strlen(oldc->config_path) + strlen(oldc->name) + 3;
+	cpath = alloca(len);
+	ret = snprintf(cpath, len, "%s/%s/", oldc->config_path, oldc->name);
+	if (ret < 0 || ret >= len)
+		return -1;
 
 	for (i=0; i<NUM_LXC_HOOKS; i++) {
 		lxc_list_for_each(it, &c->lxc_conf->hooks[i]) {
@@ -2195,6 +2201,10 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 			char tmppath[MAXPATHLEN];
 			if (!fname) // relative path - we don't support, but maybe we should
 				return 0;
+			if (strncmp(hookname, cpath, len - 1) != 0) {
+				// this hook is public - ignore
+				continue;
+			}
 			// copy the script, and change the entry in confile
 			ret = snprintf(tmppath, MAXPATHLEN, "%s/%s/%s",
 					c->config_path, c->name, fname+1);
@@ -2546,14 +2556,11 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		goto out;
 	}
 
-
-	// copy hooks if requested
-	if (flags & LXC_CLONE_COPYHOOKS) {
-		ret = copyhooks(c, c2);
-		if (ret < 0) {
-			ERROR("error copying hooks");
-			goto out;
-		}
+	// copy hooks
+	ret = copyhooks(c, c2);
+	if (ret < 0) {
+		ERROR("error copying hooks");
+		goto out;
 	}
 
 	if (copy_fstab(c, c2) < 0) {
@@ -2600,7 +2607,6 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 {
 	struct bdev *bdev;
 	struct lxc_container *newc;
-	int flags = LXC_CLONE_KEEPMACADDR | LXC_CLONE_COPYHOOKS;
 
 	if (!c || !c->name || !c->config_path)
 		return false;
@@ -2611,7 +2617,7 @@ static bool lxcapi_rename(struct lxc_container *c, const char *newname)
 		return false;
 	}
 
-	newc = lxcapi_clone(c, newname, c->config_path, flags, NULL, bdev->type, 0, NULL);
+	newc = lxcapi_clone(c, newname, c->config_path, LXC_CLONE_KEEPMACADDR, NULL, bdev->type, 0, NULL);
 	bdev_put(bdev);
 	if (!newc) {
 		lxc_container_put(newc);

commit 06e5650eaba7182a09bf73b0fa68100f6b43575f
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Dec 14 00:41:25 2013 -0500

    introduce lxcapi_rename for renaming containers
    
    lxcapi_rename implemented as a convenience function as lately
    I find myself in a need to rename a container due to a
    typo in its name. I could have started over but didn't want
    to spend more time (to installing extra packages and changing
    their configuration) on it.
    
    c->clone() followed by c->destroy() did the trick for me and I
    though it could be helpful to the other people, so here it is.
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6326724..1af8d62 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2596,6 +2596,38 @@ out:
 	return NULL;
 }
 
+static bool lxcapi_rename(struct lxc_container *c, const char *newname)
+{
+	struct bdev *bdev;
+	struct lxc_container *newc;
+	int flags = LXC_CLONE_KEEPMACADDR | LXC_CLONE_COPYHOOKS;
+
+	if (!c || !c->name || !c->config_path)
+		return false;
+
+	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	if (!bdev) {
+		ERROR("Failed to find original backing store type");
+		return false;
+	}
+
+	newc = lxcapi_clone(c, newname, c->config_path, flags, NULL, bdev->type, 0, NULL);
+	bdev_put(bdev);
+	if (!newc) {
+		lxc_container_put(newc);
+		return false;
+	}
+
+	if (newc && lxcapi_is_defined(newc))
+		lxc_container_put(newc);
+
+	if (!lxcapi_destroy(c)) {
+		ERROR("Could not destroy existing container %s", c->name);
+		return false;
+	}
+	return true;
+}
+
 static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process)
 {
 	if (!c)
@@ -3139,6 +3171,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->wait = lxcapi_wait;
 	c->set_config_item = lxcapi_set_config_item;
 	c->destroy = lxcapi_destroy;
+	c->rename = lxcapi_rename;
 	c->save_config = lxcapi_save_config;
 	c->get_keys = lxcapi_get_keys;
 	c->create = lxcapi_create;

commit a3b47c094b00824658d0b15555d6cef4c7817b81
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Dec 12 14:02:00 2013 -0600

    coverity: drop gratuitous null check
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 55ef2db..6326724 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1281,8 +1281,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		goto out_unlock;
 
 	/* reload config to get the rootfs */
-	if (c->lxc_conf)
-		lxc_conf_free(c->lxc_conf);
+	lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
 	if (!load_config_locked(c, c->configfile))
 		goto out_unlock;

commit fef48dc942425cfe8bd848189b5a58d5ee4dcace
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Dec 12 13:47:24 2013 -0600

    coverity: fix mix of bool and int
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index be8b74d..55ef2db 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1877,8 +1877,8 @@ static int lxc_rmdir_onedev_wrapper(void *data)
 static bool lxcapi_destroy(struct lxc_container *c)
 {
 	struct bdev *r = NULL;
-	bool ret = false;
-	bool am_unpriv;
+	bool bret = false, am_unpriv;
+	int ret;
 
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -1924,11 +1924,11 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		ERROR("Error destroying container directory for %s", c->name);
 		goto out;
 	}
-	ret = true;
+	bret = true;
 
 out:
 	container_disk_unlock(c);
-	return ret;
+	return bret;
 }
 
 static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)

commit f0ca27269a817ac3b396fc947e350670b31e5487
Author: James Hunt <james.hunt@ubuntu.com>
Date:   Tue Dec 10 10:29:59 2013 +0000

    Make public API string method parameters const where possible.
    
    Signed-off-by: James Hunt <james.hunt@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7e09da9..be8b74d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -68,7 +68,7 @@
 
 lxc_log_define(lxc_container, lxc);
 
-static bool file_exists(char *f)
+static bool file_exists(const char *f)
 {
 	struct stat statbuf;
 
@@ -1565,7 +1565,7 @@ err:
 	goto out;
 }
 
-static char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, int scope)
+static char** lxcapi_get_ips(struct lxc_container *c, const char* interface, const char* family, int scope)
 {
 	int i, count = 0;
 	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
@@ -2112,7 +2112,7 @@ const char *lxc_get_version(void)
 	return LXC_VERSION;
 }
 
-static int copy_file(char *old, char *new)
+static int copy_file(const char *old, const char *new)
 {
 	int in, out;
 	ssize_t len, ret;
@@ -2640,7 +2640,7 @@ int get_next_index(const char *lxcpath, char *cname)
 	}
 }
 
-static int lxcapi_snapshot(struct lxc_container *c, char *commentfile)
+static int lxcapi_snapshot(struct lxc_container *c, const char *commentfile)
 {
 	int i, flags, ret;
 	struct lxc_container *c2;
@@ -2859,7 +2859,7 @@ out_free:
 	return -1;
 }
 
-static bool lxcapi_snapshot_restore(struct lxc_container *c, char *snapname, char *newname)
+static bool lxcapi_snapshot_restore(struct lxc_container *c, const char *snapname, const char *newname)
 {
 	char clonelxcpath[MAXPATHLEN];
 	int ret;
@@ -2910,7 +2910,7 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, char *snapname, cha
 	return b;
 }
 
-static bool lxcapi_snapshot_destroy(struct lxc_container *c, char *snapname)
+static bool lxcapi_snapshot_destroy(struct lxc_container *c, const char *snapname)
 {
 	int ret;
 	char clonelxcpath[MAXPATHLEN];
@@ -2947,13 +2947,14 @@ static bool lxcapi_may_control(struct lxc_container *c)
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
-static bool add_remove_device_node(struct lxc_container *c, char *src_path, char *dest_path, bool add)
+static bool add_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path, bool add)
 {
 	int ret;
 	struct stat st;
 	char path[MAXPATHLEN];
 	char value[MAX_BUFFER];
-	char *directory_path = NULL, *p;
+	char *directory_path = NULL;
+	const char *p;
 
 	/* make sure container is running */
 	if (!c->is_running(c)) {
@@ -3032,12 +3033,12 @@ out:
 	return false;
 }
 
-static bool lxcapi_add_device_node(struct lxc_container *c, char *src_path, char *dest_path)
+static bool lxcapi_add_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	return add_remove_device_node(c, src_path, dest_path, true);
 }
 
-static bool lxcapi_remove_device_node(struct lxc_container *c, char *src_path, char *dest_path)
+static bool lxcapi_remove_device_node(struct lxc_container *c, const char *src_path, const char *dest_path)
 {
 	return add_remove_device_node(c, src_path, dest_path, false);
 }

commit f2a95ee1bf54c949614a68bf152ea9a8e1d3a172
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Nov 29 19:19:09 2013 -0500

    Move some common Ubuntu config
    
    This introduces a new /usr/share/lxc/config directory containing common
    configuration snippets.
    
    The two Ubuntu templates are then simplified to just include the
    relevant entries avoiding a whole lot of hardcoded cgroup, capabilities
    and mount points configuration.
    
    An extra comment is also added at the top of all generated configuration
    files telling the user to look at lxc.conf(5) for more information.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7f54f50..7e09da9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1127,6 +1127,7 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		fprintf(f, "%02x", md_value[i]);
 	fprintf(f, "\n");
 #endif
+	fprintf(f, "# For additional config options, please look at lxc.conf(5)\n");
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");
 		free(contents);

commit 95ee490bbdb97ab2b4f1dfa63a0a26e0dd1c2f17
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Dec 2 13:58:02 2013 -0500

    Reduce public API (V2)
    
    This removes all but the following headers from our includes:
     - attach_options.h
     - lxccontainer.h
     - version.h
    
    This also removes the duplicate lxc_version function (lxc_get_version
    has been preferred for a while).
    
    lxclock.h is now considered private.
    
    As a result quite a lot of files needed addition of extra includes
    previously inherited from lxclock.h.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 50796ae..7f54f50 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -50,6 +50,7 @@
 #include <sched.h>
 #include <arpa/inet.h>
 #include <libgen.h>
+#include "lxclock.h"
 
 #if HAVE_IFADDRS_H
 #include <ifaddrs.h>
@@ -2107,7 +2108,7 @@ const char *lxc_get_default_zfs_root(void)
 
 const char *lxc_get_version(void)
 {
-	return lxc_version();
+	return LXC_VERSION;
 }
 
 static int copy_file(char *old, char *new)

commit 540f932aeb28274e8e7ea1e8f3a8e5889b88e1d6
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Nov 29 10:53:15 2013 -0500

    Allow unsetting daemonize and close_fds
    
    As mentioned in a previous commit, this does two changes:
     - Make want_daemonize return a bool (false on failure, true on success)
     - Make both want_daemonize and want_close_all_fds take a "state"
       argument so the user can choose to unset those flags.
    
    This commit also updates all occurences of those two functions and turns
    the daemonize attribute from an int to a bool.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 283fbb5..50796ae 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -455,21 +455,23 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 	return ret;
 }
 
-static void lxcapi_want_daemonize(struct lxc_container *c)
+static bool lxcapi_want_daemonize(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
-		return;
+		return false;
 	if (container_mem_lock(c)) {
 		ERROR("Error getting mem lock");
-		return;
+		return false;
 	}
-	c->daemonize = 1;
+	c->daemonize = state;
 	/* daemonize implies close_all_fds so set it */
-	c->lxc_conf->close_all_fds = 1;
+	if (state == 1)
+		c->lxc_conf->close_all_fds = 1;
 	container_mem_unlock(c);
+	return true;
 }
 
-static bool lxcapi_want_close_all_fds(struct lxc_container *c)
+static bool lxcapi_want_close_all_fds(struct lxc_container *c, bool state)
 {
 	if (!c || !c->lxc_conf)
 		return false;
@@ -477,7 +479,7 @@ static bool lxcapi_want_close_all_fds(struct lxc_container *c)
 		ERROR("Error getting mem lock");
 		return false;
 	}
-	c->lxc_conf->close_all_fds = 1;
+	c->lxc_conf->close_all_fds = state;
 	container_mem_unlock(c);
 	return true;
 }
@@ -549,7 +551,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 {
 	int ret;
 	struct lxc_conf *conf;
-	int daemonize = 0;
+	bool daemonize = false;
 	char *default_args[] = {
 		"/sbin/init",
 		'\0',

commit 4355ab5fabd56cab1f41d5286b4dc99ef2e7ebe9
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Nov 22 14:39:37 2013 -0600

    lxcapi_destroy: run in a namespace if we are unprivileged
    
    This is necessary to have the rights to remove files owned by our subuids.
    
    Also update lxc_rmdir_onedev to return 0 on success, -1 on failure.
    Callers were not consistent in using it correctly, and this is more
    in keeping with the rest of our code.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c1f99d5..283fbb5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1863,11 +1863,18 @@ out:
 	return bret;
 }
 
+static int lxc_rmdir_onedev_wrapper(void *data)
+{
+	char *arg = (char *) data;
+	return lxc_rmdir_onedev(arg);
+}
+
 // do we want the api to support --force, or leave that to the caller?
 static bool lxcapi_destroy(struct lxc_container *c)
 {
 	struct bdev *r = NULL;
 	bool ret = false;
+	bool am_unpriv;
 
 	if (!c || !lxcapi_is_defined(c))
 		return false;
@@ -1881,20 +1888,23 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
+	am_unpriv = c->lxc_conf && geteuid() != 0 && !lxc_list_empty(&c->lxc_conf->id_map);
+
 	if (c->lxc_conf && has_snapshots(c)) {
 		ERROR("container %s has dependent snapshots", c->name);
 		goto out;
 	}
 
-	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount)
+	if (!am_unpriv && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount) {
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
-	if (r) {
-		if (r->ops->destroy(r) < 0) {
+		if (r) {
+			if (r->ops->destroy(r) < 0) {
+				bdev_put(r);
+				ERROR("Error destroying rootfs for %s", c->name);
+				goto out;
+			}
 			bdev_put(r);
-			ERROR("Error destroying rootfs for %s", c->name);
-			goto out;
 		}
-		bdev_put(r);
 	}
 
 	mod_all_rdeps(c, false);
@@ -1902,7 +1912,11 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	const char *p1 = lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
-	if (lxc_rmdir_onedev(path) < 0) {
+	if (am_unpriv)
+		ret = userns_exec_1(c->lxc_conf, lxc_rmdir_onedev_wrapper, path);
+	else
+		ret = lxc_rmdir_onedev(path);
+	if (ret < 0) {
 		ERROR("Error destroying container directory for %s", c->name);
 		goto out;
 	}

commit 24ef39f4d54e83996129463f7138ba90b26a166a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Nov 21 09:05:59 2013 -0600

    lxcapi_clone: set the right environment variable for mounted fs
    
    If the container is dir-backed, we don't actually mount it (to
    support unprivileged use).  So always set the LXC_ROOTFS_MOUNT
    to bdev->dest, not to the rootfs path specified in the container
    configuration.
    
    This should fix bug http://pad.lv/1253573
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 11e70cb..c1f99d5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2399,7 +2399,7 @@ static int clone_update_rootfs(struct lxc_container *c0,
 		if (setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
 			SYSERROR("failed to set environment variable for config path");
 		}
-		if (setenv("LXC_ROOTFS_MOUNT", conf->rootfs.mount, 1)) {
+		if (setenv("LXC_ROOTFS_MOUNT", bdev->dest, 1)) {
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
 		if (setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {

commit c6a9b0d7976d22cc42ad996927cf38a44a936888
Author: S.alar Onur <caglar@10ur.org>
Date:   Thu Nov 14 23:22:54 2013 -0500

    add missing paranthesis (v2)
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3cabf0d..11e70cb 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2958,9 +2958,9 @@ static bool add_remove_device_node(struct lxc_container *c, char *src_path, char
 		goto out;
 
 	/* continue if path is character device or block device */
-	if S_ISCHR(st.st_mode)
+	if (S_ISCHR(st.st_mode))
 		ret = snprintf(value, MAX_BUFFER, "c %d:%d rwm", major(st.st_rdev), minor(st.st_rdev));
-	else if S_ISBLK(st.st_mode)
+	else if (S_ISBLK(st.st_mode))
 		ret = snprintf(value, MAX_BUFFER, "b %d:%d rwm", major(st.st_rdev), minor(st.st_rdev));
 	else
 		goto out;

commit 4df7f012b9994ea54b1ad68176d8d45a57fa02f3
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Nov 14 12:48:41 2013 -0600

    lxc-start: if we pass in a config file, then don't use any loaded config
    
    To do this, add a c->clear_config() helper to the api.
    
    (this fixes the bug https://bugs.launchpad.net/bugs/1251352)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2a70bc7..3cabf0d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1151,6 +1151,14 @@ out_error:
 	return true;
 }
 
+static void lxcapi_clear_config(struct lxc_container *c)
+{
+	if (c && c->lxc_conf) {
+		lxc_conf_free(c->lxc_conf);
+		c->lxc_conf = NULL;
+	}
+}
+
 static bool lxcapi_destroy(struct lxc_container *c);
 /*
  * lxcapi_create:
@@ -1280,9 +1288,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 	// now clear out the lxc_conf we have, reload from the created
 	// container
-	if (c->lxc_conf)
-		lxc_conf_free(c->lxc_conf);
-	c->lxc_conf = NULL;
+	lxcapi_clear_config(c);
 
 	if (t) {
 		if (!prepend_lxc_header(c->configfile, tpath, argv)) {
@@ -3093,8 +3099,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	if (ongoing_create(c) == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
 		lxcapi_destroy(c);
-		lxc_conf_free(c->lxc_conf);
-		c->lxc_conf = NULL;
+		lxcapi_clear_config(c);
 	}
 
 	// assign the member functions
@@ -3122,6 +3127,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->createl = lxcapi_createl;
 	c->shutdown = lxcapi_shutdown;
 	c->reboot = lxcapi_reboot;
+	c->clear_config = lxcapi_clear_config;
 	c->clear_config_item = lxcapi_clear_config_item;
 	c->get_config_item = lxcapi_get_config_item;
 	c->get_cgroup_item = lxcapi_get_cgroup_item;

commit a9a0ed90dd1cdadd412576a45af16419efc0e939
Author: S.alar Onur <caglar@10ur.org>
Date:   Wed Nov 13 00:39:00 2013 -0500

    introduce lxcapi_add_device_node and lxcapi_remove_device_node to API (v3)
    
    Adding block/char devices to running container is a common operation so
    provide a common implementation for users to consume.
    
    changes since v2;
    * lets the user set an alternate path inside the container as Stphane suggested
    
    changes since v1;
    * removed duplicated code
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 05ca643..2a70bc7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -49,6 +49,7 @@
 #include <lxc/namespace.h>
 #include <sched.h>
 #include <arpa/inet.h>
+#include <libgen.h>
 
 #if HAVE_IFADDRS_H
 #include <ifaddrs.h>
@@ -62,6 +63,8 @@
 #endif
 #endif
 
+#define MAX_BUFFER 4096
+
 lxc_log_define(lxc_container, lxc);
 
 static bool file_exists(char *f)
@@ -2920,6 +2923,101 @@ static bool lxcapi_may_control(struct lxc_container *c)
 	return lxc_try_cmd(c->name, c->config_path) == 0;
 }
 
+static bool add_remove_device_node(struct lxc_container *c, char *src_path, char *dest_path, bool add)
+{
+	int ret;
+	struct stat st;
+	char path[MAXPATHLEN];
+	char value[MAX_BUFFER];
+	char *directory_path = NULL, *p;
+
+	/* make sure container is running */
+	if (!c->is_running(c)) {
+		ERROR("container is not running");
+		goto out;
+	}
+
+	/* use src_path if dest_path is NULL otherwise use dest_path */
+	p = dest_path ? dest_path : src_path;
+
+	/* prepare the path */
+	ret = snprintf(path, MAXPATHLEN, "/proc/%d/root/%s", c->init_pid(c), p);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		goto out;
+	remove_trailing_slashes(path);
+
+	p = add ? src_path : path;
+	/* make sure we can access p */
+	if(access(p, F_OK) < 0 || stat(p, &st) < 0)
+		goto out;
+
+	/* continue if path is character device or block device */
+	if S_ISCHR(st.st_mode)
+		ret = snprintf(value, MAX_BUFFER, "c %d:%d rwm", major(st.st_rdev), minor(st.st_rdev));
+	else if S_ISBLK(st.st_mode)
+		ret = snprintf(value, MAX_BUFFER, "b %d:%d rwm", major(st.st_rdev), minor(st.st_rdev));
+	else
+		goto out;
+
+	/* check snprintf return code */
+	if (ret < 0 || ret >= MAX_BUFFER)
+		goto out;
+
+	directory_path = dirname(strdup(path));
+	/* remove path and directory_path (if empty) */
+	if(access(path, F_OK) == 0) {
+		if (unlink(path) < 0) {
+			ERROR("unlink failed");
+			goto out;
+		}
+		if (rmdir(directory_path) < 0 && errno != ENOTEMPTY) {
+			ERROR("rmdir failed");
+			goto out;
+		}
+	}
+
+	if (add) {
+		/* create the missing directories */
+		if (mkdir_p(directory_path, 0755) < 0) {
+			ERROR("failed to create directory");
+			goto out;
+		}
+
+		/* create the device node */
+		if (mknod(path, st.st_mode, st.st_rdev) < 0) {
+			ERROR("mknod failed");
+            goto out;
+		}
+
+		/* add device node to device list */
+		if (!c->set_cgroup_item(c, "devices.allow", value)) {
+			ERROR("set_cgroup_item failed while adding the device node");
+			goto out;
+		}
+	} else {
+		/* remove device node from device list */
+		if (!c->set_cgroup_item(c, "devices.deny", value)) {
+			ERROR("set_cgroup_item failed while removing the device node");
+			goto out;
+		}
+	}
+	return true;
+out:
+	if (directory_path)
+		free(directory_path);
+	return false;
+}
+
+static bool lxcapi_add_device_node(struct lxc_container *c, char *src_path, char *dest_path)
+{
+	return add_remove_device_node(c, src_path, dest_path, true);
+}
+
+static bool lxcapi_remove_device_node(struct lxc_container *c, char *src_path, char *dest_path)
+{
+	return add_remove_device_node(c, src_path, dest_path, false);
+}
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -3041,6 +3139,8 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->snapshot_restore = lxcapi_snapshot_restore;
 	c->snapshot_destroy = lxcapi_snapshot_destroy;
 	c->may_control = lxcapi_may_control;
+	c->add_device_node = lxcapi_add_device_node;
+	c->remove_device_node = lxcapi_remove_device_node;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit 68c9cf36681cf0cdec6725b513107f9b65273498
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Nov 12 14:04:39 2013 -0500

    add process_lock()/unlock() in save_config()
    
    This is likely unnecessary, but is consistent with other uses of
    fopen()/fclose() in lxc.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0a94f5e..05ca643 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1700,11 +1700,15 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	if (lret)
 		return false;
 
+	process_lock();
 	fout = fopen(alt_file, "w");
+	process_unlock();
 	if (!fout)
 		goto out;
 	write_config(fout, c->lxc_conf);
+	process_lock();
 	fclose(fout);
+	process_unlock();
 	ret = true;
 
 out:

commit 6c6892b5c5c6281d1e74c979168d1cbbe6a50ffc
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Nov 12 14:04:45 2013 -0500

    fix multithreaded create()
    
    We were calling save_config() twice within the create() flow, each
    from a different process. Depending on order of scheduling, sometimes
    the data from the first save_config() (which was just the stuff from
    LXC_DEFAULT_CONFIG) would overwrite the config we wanted (the full
    config), causing a truncated config file which would then cause lxc
    to segfault once it read it back in because no rootfs.path was set.
    
    This fixes it by only calling save_config() once in the create()
    flow. A rejected alternative was to call fsync(fileno(fout)) before
    the fclose in save_config.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ede0113..0a94f5e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1192,16 +1192,19 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
 			access(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {
 		ERROR("Container %s:%s already exists", c->config_path, c->name);
-		free(tpath);
-		return false;
+		goto free_tpath;
 	}
 
-	/* Save the loaded configuration to disk */
-	if (!c->save_config(c, NULL)) {
-		ERROR("failed to save starting configuration for %s\n", c->name);
-		goto out;
+	if (!c->lxc_conf) {
+		if (!c->load_config(c, LXC_DEFAULT_CONFIG)) {
+			ERROR("Error loading default configuration file %s\n", LXC_DEFAULT_CONFIG);
+			goto free_tpath;
+		}
 	}
 
+	if (!create_container_dir(c))
+		goto free_tpath;
+
 	/*
 	 * either template or rootfs.path should be set.
 	 * if both template and rootfs.path are set, template is setup as rootfs.path.
@@ -1290,10 +1293,11 @@ out_unlock:
 	if (partial_fd >= 0)
 		remove_partial(c, partial_fd);
 out:
-	if (tpath)
-		free(tpath);
 	if (!ret && c)
 		lxcapi_destroy(c);
+free_tpath:
+	if (tpath)
+		free(tpath);
 	return ret;
 }
 

commit 03f064ff7447816c89fff24de9b0a5076614dfd3
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Nov 8 17:41:16 2013 +0000

    wait_on_damonized-start: wait only on the pid we want
    
    Otherwise we can reap another thread's forked pid.
    
    Changelog: Per Dwight's suggestion, use pid_t for argument.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: S.alar Onur <caglar@10ur.org>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 827cae0..ede0113 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -491,7 +491,7 @@ static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 }
 
 
-static bool wait_on_daemonized_start(struct lxc_container *c)
+static bool wait_on_daemonized_start(struct lxc_container *c, int pid)
 {
 	/* we'll probably want to make this timeout configurable? */
 	int timeout = 5, ret, status;
@@ -500,7 +500,7 @@ static bool wait_on_daemonized_start(struct lxc_container *c)
 	 * our child is going to fork again, then exit.  reap the
 	 * child
 	 */
-	ret = wait(&status);
+	ret = waitpid(pid, &status, 0);
 	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
 		DEBUG("failed waiting for first dual-fork child");
 	return lxcapi_wait(c, "RUNNING", timeout);
@@ -607,7 +607,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			return false;
 		}
 		if (pid != 0)
-			return wait_on_daemonized_start(c);
+			return wait_on_daemonized_start(c, pid);
 
 		process_unlock(); // we're no longer sharing
 		/* second fork to be reparented by init */

commit 2d834aa8074b3e8f7341ad9feff7a7c5b695a3b3
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Nov 7 22:20:33 2013 -0600

    api_start: refuse to run undaemonized if multithreaded
    
    lxc-start is not safe (and doesn't actually make sense) if the
    task is nto single-threaded.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 05e5405..827cae0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -506,6 +506,38 @@ static bool wait_on_daemonized_start(struct lxc_container *c)
 	return lxcapi_wait(c, "RUNNING", timeout);
 }
 
+static bool am_single_threaded(void)
+{
+	struct dirent dirent, *direntp;
+	DIR *dir;
+	int count=0;
+
+	process_lock();
+	dir = opendir("/proc/self/task");
+	process_unlock();
+	if (!dir) {
+		INFO("failed to open /proc/self/task");
+		return false;
+	}
+
+	while (!readdir_r(dir, &dirent, &direntp)) {
+		if (!direntp)
+			break;
+
+		if (!strcmp(direntp->d_name, "."))
+			continue;
+
+		if (!strcmp(direntp->d_name, ".."))
+			continue;
+		if (++count > 1)
+			break;
+	}
+	process_lock();
+	closedir(dir);
+	process_unlock();
+	return count == 1;
+}
+
 /*
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
@@ -598,6 +630,11 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		open("/dev/null", O_RDWR);
 		open("/dev/null", O_RDWR);
 		setsid();
+	} else {
+		if (!am_single_threaded()) {
+			ERROR("Cannot start non-daemonized container when threaded");
+			return false;
+		}
 	}
 
 reboot:

commit 57d116ab501594c2e50ab45f1cf2fae48c5eab09
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Nov 1 15:27:49 2013 -0500

    create_run_template: tell the template what caller's uid was mapped to
    
    conf.c/conf.h: have replaced bool hostid_is_mapped() with int mapped_hostid()
       which returns the mapped uid for the caller's uid on the host, or -1 if
       none
    
    create_run_template: pass caller's uid into template.
    
    lxc-ubuntu-cloud:
    	1. accept --mapped-uid argument
    	2. don't write to devices cgroup - not allowed.
    	3. if running in userns, use $HOME/.cache
    	4. chown cached files to the uid to which our caller was
    	   mapped
    	5. ignore /dev when extracting rootfs in a userns
    
    Changelog: nov 5: remove debugging INFO line.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7fa3d51..05e5405 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -917,20 +917,27 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		 * If we're running the template in a mapped userns, then
 		 * we prepend the template command with:
 		 * lxc-usernsexec <-m map1> ... <-m mapn> --
+		 * and we append "--mapped-uid x", where x is the mapped uid
+		 * for our geteuid()
 		 */
 		if (geteuid() != 0 && !lxc_list_empty(&conf->id_map)) {
 			int n2args = 1;
+			char txtuid[20];
 			char **n2 = malloc(n2args * sizeof(*n2));
 			struct lxc_list *it;
 			struct id_map *map;
 
+			if (!n2) {
+				SYSERROR("out of memory");
+				exit(1);
+			}
 			newargv[0] = tpath;
 			tpath = "lxc-usernsexec";
 			n2[0] = "lxc-usernsexec";
 			lxc_list_for_each(it, &conf->id_map) {
 				map = it->elem;
 				n2args += 2;
-				n2 = realloc(n2, n2args * sizeof(*n2));
+				n2 = realloc(n2, n2args * sizeof(char *));
 				if (!n2)
 					exit(1);
 				n2[n2args-2] = "-m";
@@ -943,15 +950,15 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 				if (ret < 0 || ret >= 200)
 					exit(1);
 			}
-			bool hostid_mapped = hostid_is_mapped(geteuid(), conf);
-			int extraargs = hostid_mapped ?  1 : 3;
-			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(*n2));
+			int hostid_mapped = mapped_hostid(geteuid(), conf);
+			int extraargs = hostid_mapped >= 0 ?  1 : 3;
+			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(char *));
 			if (!n2)
 				exit(1);
-			if (!hostid_mapped) {
-				int free_id = find_unmapped_nsuid(conf);
+			if (hostid_mapped < 0) {
+				hostid_mapped = find_unmapped_nsuid(conf);
 				n2[n2args++] = "-m";
-				if (free_id < 0) {
+				if (hostid_mapped < 0) {
 					ERROR("Could not find free uid to map");
 					exit(1);
 				}
@@ -961,7 +968,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 					exit(1);
 				}
 				ret = snprintf(n2[n2args-1], 200, "u:%d:%d:1",
-					free_id, geteuid());
+					hostid_mapped, geteuid());
 				if (ret < 0 || ret >= 200) {
 					ERROR("string too long");
 					exit(1);
@@ -970,6 +977,20 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 			n2[n2args++] = "--";
 			for (i = 0; i < nargs; i++)
 				n2[i + n2args] = newargv[i];
+			n2args += nargs;
+			// Finally add "--mapped-uid $uid" to tell template what to chown
+			// cached images to
+			n2args += 2;
+			n2 = realloc(n2, n2args * sizeof(char *));
+			if (!n2) {
+				SYSERROR("out of memory");
+				exit(1);
+			}
+			// note n2[n2args-1] is NULL
+			n2[n2args-3] = "--mapped-uid";
+			snprintf(txtuid, 20, "%d", hostid_mapped);
+			n2[n2args-2] = txtuid;
+			n2[n2args-1] = NULL;
 			free(newargv);
 			newargv = n2;
 		}

commit 148a9d276cd256746515068ba0fef7b45a917dfe
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Nov 5 13:17:02 2013 -0500

    fix leak in list_active_containers()
    
    Found by running the lxc-test-list test with valgrind. The names were
    put into a local array, and never freed in the success case where the
    caller didn't want the names returned and in the early out failure case.
    
    Note we don't need to check the return from remove_from_array() because
    we just successfully added the name above.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1cc29b0..7fa3d51 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -19,6 +19,7 @@
  */
 
 #define _GNU_SOURCE
+#include <assert.h>
 #include <stdarg.h>
 #include <pthread.h>
 #include <unistd.h>
@@ -3096,12 +3097,13 @@ free_bad:
 	return -1;
 }
 
-int list_active_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)
+int list_active_containers(const char *lxcpath, char ***nret,
+			   struct lxc_container ***cret)
 {
-	int i, cfound = 0, nfound = 0;
+	int i, ret = -1, cret_cnt = 0, ct_name_cnt = 0;
 	int lxcpath_len;
 	char *line = NULL;
-	char **unique_names = NULL;
+	char **ct_name = NULL;
 	size_t len = 0;
 	struct lxc_container *c;
 
@@ -3111,8 +3113,8 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 
 	if (cret)
 		*cret = NULL;
-	if (names)
-		*names = NULL;
+	if (nret)
+		*nret = NULL;
 
 	process_lock();
 	FILE *f = fopen("/proc/net/unix", "r");
@@ -3140,27 +3142,22 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 			continue;
 		*p2 = '\0';
 
-		if (array_contains(&unique_names, p, nfound))
+		if (array_contains(&ct_name, p, ct_name_cnt))
 			continue;
 
-		if (!add_to_array(&unique_names, p, nfound))
-			goto free_bad;
+		if (!add_to_array(&ct_name, p, ct_name_cnt))
+			goto free_cret_list;
 
-		cfound++;
+		ct_name_cnt++;
 
-		if (!cret) {
-			nfound++;
+		if (!cret)
 			continue;
-		}
 
 		c = lxc_container_new(p, lxcpath);
 		if (!c) {
 			INFO("Container %s:%s is running but could not be loaded",
 				lxcpath, p);
-			if (names) {
-				if(!remove_from_array(&unique_names, p, cfound--))
-					goto free_bad;
-			}
+			remove_from_array(&ct_name, p, ct_name_cnt--);
 			continue;
 		}
 
@@ -3170,42 +3167,43 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 		 * fact that the command socket exists.
 		 */
 
-		if (!add_to_clist(cret, c, nfound, true)) {
+		if (!add_to_clist(cret, c, cret_cnt, true)) {
 			lxc_container_put(c);
-			goto free_bad;
+			goto free_cret_list;
 		}
-		nfound++;
+		cret_cnt++;
 	}
 
-	if (names)
-		*names = unique_names;
-
-	if (line)
-		free(line);
-
-	process_lock();
-	fclose(f);
-	process_unlock();
-	return nfound;
+	assert(!nret || !cret || cret_cnt == ct_name_cnt);
+	ret = ct_name_cnt;
+	if (nret)
+		*nret = ct_name;
+	else
+		goto free_ct_name;
+	goto out;
 
-free_bad:
-	if (names && *names) {
-		for (i=0; i<cfound; i++)
-			free((*names)[i]);
-		free(*names);
-	}
+free_cret_list:
 	if (cret && *cret) {
-		for (i=0; i<nfound; i++)
+		for (i = 0; i < cret_cnt; i++)
 			lxc_container_put((*cret)[i]);
 		free(*cret);
 	}
+
+free_ct_name:
+	if (ct_name) {
+		for (i = 0; i < ct_name_cnt; i++)
+			free(ct_name[i]);
+		free(ct_name);
+	}
+
+out:
 	if (line)
 		free(line);
 
 	process_lock();
 	fclose(f);
 	process_unlock();
-	return -1;
+	return ret;
 }
 
 int list_all_containers(const char *lxcpath, char ***nret,

commit 2871830a40751c5a8fc30f47a8b8861dfa09d9dc
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Nov 5 13:16:51 2013 -0500

    add list_all_containers(), returns defined and active containers
    
    Changelog: [serge] remove unneeded explicity qsort call
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 89b45ed..1cc29b0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1403,7 +1403,7 @@ static bool add_to_array(char ***names, char *cname, int pos)
 	return true;
 }
 
-static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos)
+static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos, bool sort)
 {
 	struct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));
 	if (!newlist) {
@@ -1415,7 +1415,8 @@ static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c,
 	newlist[pos] = c;
 
 	// sort the arrray as we will use binary search on it
-	qsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);
+	if (sort)
+		qsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);
 
 	return true;
 }
@@ -3066,7 +3067,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 			continue;
 		}
 
-		if (!add_to_clist(cret, c, nfound)) {
+		if (!add_to_clist(cret, c, nfound, true)) {
 			lxc_container_put(c);
 			goto free_bad;
 		}
@@ -3169,7 +3170,7 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 		 * fact that the command socket exists.
 		 */
 
-		if (!add_to_clist(cret, c, nfound)) {
+		if (!add_to_clist(cret, c, nfound, true)) {
 			lxc_container_put(c);
 			goto free_bad;
 		}
@@ -3206,3 +3207,88 @@ free_bad:
 	process_unlock();
 	return -1;
 }
+
+int list_all_containers(const char *lxcpath, char ***nret,
+			struct lxc_container ***cret)
+{
+	int i, ret, active_cnt, ct_cnt, ct_list_cnt;
+	char **active_name;
+	char **ct_name;
+	struct lxc_container **ct_list = NULL;
+
+	ct_cnt = list_defined_containers(lxcpath, &ct_name, NULL);
+	if (ct_cnt < 0)
+		return ct_cnt;
+
+	active_cnt = list_active_containers(lxcpath, &active_name, NULL);
+	if (active_cnt < 0) {
+		ret = active_cnt;
+		goto free_ct_name;
+	}
+
+	for (i = 0; i < active_cnt; i++) {
+		if (!array_contains(&ct_name, active_name[i], ct_cnt)) {
+			if (!add_to_array(&ct_name, active_name[i], ct_cnt)) {
+				ret = -1;
+				goto free_active_name;
+			}
+			ct_cnt++;
+		}
+		free(active_name[i]);
+		active_name[i] = NULL;
+	}
+	free(active_name);
+	active_name = NULL;
+	active_cnt = 0;
+
+	for (i = 0, ct_list_cnt = 0; i < ct_cnt && cret; i++) {
+		struct lxc_container *c;
+
+		c = lxc_container_new(ct_name[i], lxcpath);
+		if (!c) {
+			WARN("Container %s:%s could not be loaded", lxcpath, ct_name[i]);
+			remove_from_array(&ct_name, ct_name[i], ct_cnt--);
+			continue;
+		}
+
+		if (!add_to_clist(&ct_list, c, ct_list_cnt, false)) {
+			lxc_container_put(c);
+			ret = -1;
+			goto free_ct_list;
+		}
+		ct_list_cnt++;
+	}
+
+	if (cret)
+		*cret = ct_list;
+
+	if (nret)
+		*nret = ct_name;
+	else {
+		ret = ct_cnt;
+		goto free_ct_name;
+	}
+	return ct_cnt;
+
+free_ct_list:
+	for (i = 0; i < ct_list_cnt; i++) {
+		lxc_container_put(ct_list[i]);
+	}
+	if (ct_list)
+		free(ct_list);
+
+free_active_name:
+	for (i = 0; i < active_cnt; i++) {
+		if (active_name[i])
+			free(active_name[i]);
+	}
+	if (active_name)
+		free(active_name);
+
+free_ct_name:
+	for (i = 0; i < ct_cnt; i++) {
+		free(ct_name[i]);
+	}
+	free(ct_name);
+	return ret;
+}

commit 6502006a44d27a27fe1e2d9d8cac721c0ec8907a
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 4 17:35:15 2013 -0500

    allow lxcapi_get_cgroup_item() on lxc-execute containers
    
    Containers started with lxc-execute may not have a conf, but
    nothing in the implementation of lxcapi_get_cgroup_item()
    actually needs/uses it, and it can be useful to get items out
    of the containers' cgroup items.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ef828dc..89b45ed 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1977,7 +1977,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 {
 	int ret;
 
-	if (!c || !c->lxc_conf)
+	if (!c)
 		return -1;
 
 	if (is_stopped(c))

commit 497a2995687a56a1f12a69311d8bacbb645e0d97
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Nov 2 17:15:36 2013 -0400

    make sure to check c->lxc_conf is not NULL before dereferencing it.
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 946133d..ef828dc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -453,7 +453,7 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 
 static void lxcapi_want_daemonize(struct lxc_container *c)
 {
-	if (!c)
+	if (!c || !c->lxc_conf)
 		return;
 	if (container_mem_lock(c)) {
 		ERROR("Error getting mem lock");

commit 4de2791fa7dcc6d4cd445f3c6678623a998b18e2
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Nov 1 12:17:52 2013 -0500

    always remount / rslave before running creation template (if root)
    
    If we're not root, our mounts in private userns won't get pushed
    back anyway.  If we are root, we need to make sure that anything
    the template does gets cleaned up.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 8b81a63..946133d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -24,6 +24,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <sys/mount.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <sched.h>
@@ -833,11 +834,23 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 			exit(1);
 		}
 
-		if (strcmp(bdev->type, "dir") != 0) {
+		if (geteuid() == 0) {
 			if (unshare(CLONE_NEWNS) < 0) {
 				ERROR("error unsharing mounts");
 				exit(1);
 			}
+			if (detect_shared_rootfs()) {
+				if (mount("", "", NULL, MS_SLAVE|MS_REC, 0)) {
+					SYSERROR("Failed to make / rslave to run template");
+					ERROR("Continuing...");
+				}
+			}
+		}
+		if (strcmp(bdev->type, "dir") != 0) {
+			if (geteuid() != 0) {
+				ERROR("non-root users can only create directory-backed containers");
+				exit(1);
+			}
 			if (bdev->ops->mount(bdev) < 0) {
 				ERROR("Error mounting rootfs");
 				exit(1);

commit 83758ed00f731b11abed774097112db61b7131bf
Author: S.alar Onur <caglar@10ur.org>
Date:   Wed Oct 30 16:10:26 2013 -0400

    daemonize implies close_all_fds so set it in lxcapi_want_daemonize instead of setting in every cli or in every binding explicitly
    
    Reported-by: Fatih Arslan <ftharsln@gmail.com>
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1254dc0..8b81a63 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -459,6 +459,8 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 		return;
 	}
 	c->daemonize = 1;
+	/* daemonize implies close_all_fds so set it */
+	c->lxc_conf->close_all_fds = 1;
 	container_mem_unlock(c);
 }
 

commit 0590e82c10ea3b75f0c4d462de3f5bb344da37c5
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 30 12:47:38 2013 -0500

    api_create: undo unneeded chunk in previous commit
    
    lxc_conf exists after api_save_config
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 680b536..1254dc0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1128,24 +1128,22 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		goto out;
 	}
 
-	if (c->lxc_conf) {
-		/*
-		 * either template or rootfs.path should be set.
-		 * if both template and rootfs.path are set, template is setup as rootfs.path.
-		 * container is already created if we have a config and rootfs.path is accessible
-		 */
-		if (!c->lxc_conf->rootfs.path && !tpath)
-			/* no template passed in and rootfs does not exist: error */
-			goto out;
-		if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
-			/* rootfs passed into configuration, but does not exist: error */
-			goto out;
-		if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
-			/* Rootfs already existed, user just wanted to save the
-			 * loaded configuration */
-			ret = true;
-			goto out;
-		}
+	/*
+	 * either template or rootfs.path should be set.
+	 * if both template and rootfs.path are set, template is setup as rootfs.path.
+	 * container is already created if we have a config and rootfs.path is accessible
+	 */
+	if (!c->lxc_conf->rootfs.path && !tpath)
+		/* no template passed in and rootfs does not exist: error */
+		goto out;
+	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
+		/* rootfs passed into configuration, but does not exist: error */
+		goto out;
+	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
+		/* Rootfs already existed, user just wanted to save the
+		 * loaded configuration */
+		ret = true;
+		goto out;
 	}
 
 	/* Mark that this container is being created */

commit cf465fe41c937dabd36052f1fd973e5fb539d1ad
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 30 10:57:45 2013 -0500

    api_create and do_bdev_create: a few more fixes
    
    don't use lxcpath variable for rootfs_path, it's confusing.
    
    if rootfs is passed in and tpath is passed in, return error
    before we save a new config, and don't delete the container
    
    make sure to check c->lxc_conf is not NULL before dereferencing it.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d882fc3..680b536 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -701,19 +701,18 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 			 struct bdev_specs *specs)
 {
 	char *dest;
-	const char *lxcpath;
 	size_t len;
 	struct bdev *bdev;
 	int ret;
 
 	/* rootfs.path or lxcpath/lxcname/rootfs */
 	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {
-		lxcpath = c->lxc_conf->rootfs.path;
-		len = strlen(lxcpath) + 1;
+		const char *rpath = c->lxc_conf->rootfs.path;
+		len = strlen(rpath) + 1;
 		dest = alloca(len);
-		ret = snprintf(dest, len, "%s", lxcpath);
+		ret = snprintf(dest, len, "%s", rpath);
 	} else {
-		lxcpath = lxcapi_get_config_path(c);
+		const char *lxcpath = lxcapi_get_config_path(c);
 		len = strlen(c->name) + strlen(lxcpath) + 9;
 		dest = alloca(len);
 		ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
@@ -1110,23 +1109,43 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		}
 	}
 
+	/*
+	 * If a template is passed in, and the rootfs already is defined in
+	 * the container config and exists, then * caller is trying to create
+	 * an existing container.  Return an error, but do NOT delete the
+	 * container.
+	 */
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path &&
+			access(c->lxc_conf->rootfs.path, F_OK) == 0 && tpath) {
+		ERROR("Container %s:%s already exists", c->config_path, c->name);
+		free(tpath);
+		return false;
+	}
+
+	/* Save the loaded configuration to disk */
 	if (!c->save_config(c, NULL)) {
 		ERROR("failed to save starting configuration for %s\n", c->name);
 		goto out;
 	}
 
-	/*
-	 * either template or rootfs.path should be set.
-	 * if both template and rootfs.path are set, template is setup as rootfs.path.
-	 * container is already created if we have a config and rootfs.path is accessible
-	 */
-	if (c->lxc_conf && !c->lxc_conf->rootfs.path && !tpath)
-		goto out;
-	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
-		goto out;
-	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
-		ret = true;
-		goto out;
+	if (c->lxc_conf) {
+		/*
+		 * either template or rootfs.path should be set.
+		 * if both template and rootfs.path are set, template is setup as rootfs.path.
+		 * container is already created if we have a config and rootfs.path is accessible
+		 */
+		if (!c->lxc_conf->rootfs.path && !tpath)
+			/* no template passed in and rootfs does not exist: error */
+			goto out;
+		if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
+			/* rootfs passed into configuration, but does not exist: error */
+			goto out;
+		if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
+			/* Rootfs already existed, user just wanted to save the
+			 * loaded configuration */
+			ret = true;
+			goto out;
+		}
 	}
 
 	/* Mark that this container is being created */

commit cd219ae6590646d3a56c61f8bd5195c1c01d934b
Author: Sheng Yong <shyodx@gmail.com>
Date:   Sun Oct 27 14:38:03 2013 +0800

    lxc-create: fix conflict of rootfs.path and template default path
    
    1. rootfs.path set, -t not set: rootfs.path is rootfs path
    2. rootfs.path set, -t set: change template default path to rootfs path
    3. rootfs.path not set, -t set: template default path is rootfs path
    4. rootfs.path not set, -t not set: error
    5. rootfs.path set but cannot access: error
    
    Signed-off-by: Sheng Yong <shyodx@gmail.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7a4d75f..d882fc3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -701,15 +701,23 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 			 struct bdev_specs *specs)
 {
 	char *dest;
-	const char *lxcpath = lxcapi_get_config_path(c);
+	const char *lxcpath;
 	size_t len;
 	struct bdev *bdev;
 	int ret;
 
-	/* lxcpath/lxcname/rootfs */
-	len = strlen(c->name) + strlen(lxcpath) + 9;
-	dest = alloca(len);
-	ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
+	/* rootfs.path or lxcpath/lxcname/rootfs */
+	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) {
+		lxcpath = c->lxc_conf->rootfs.path;
+		len = strlen(lxcpath) + 1;
+		dest = alloca(len);
+		ret = snprintf(dest, len, "%s", lxcpath);
+	} else {
+		lxcpath = lxcapi_get_config_path(c);
+		len = strlen(c->name) + strlen(lxcpath) + 9;
+		dest = alloca(len);
+		ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
+	}
 	if (ret < 0 || ret >= len)
 		return NULL;
 
@@ -1107,8 +1115,16 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		goto out;
 	}
 
-	/* container is already created if we have a config and rootfs.path is accessible */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0 && !tpath) {
+	/*
+	 * either template or rootfs.path should be set.
+	 * if both template and rootfs.path are set, template is setup as rootfs.path.
+	 * container is already created if we have a config and rootfs.path is accessible
+	 */
+	if (c->lxc_conf && !c->lxc_conf->rootfs.path && !tpath)
+		goto out;
+	if (c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) != 0)
+		goto out;
+	if (lxcapi_is_defined(c) && c->lxc_conf->rootfs.path && !tpath) {
 		ret = true;
 		goto out;
 	}

commit a69aad27ad5a217a4f58f525fb34f764390dd474
Author: Sheng Yong <shyodx@gmail.com>
Date:   Sun Oct 27 14:37:46 2013 +0800

    lxcapi_create: don't delete if container rootfs already exists
    
    If lxc.rootfs is specified, we believe rootfs is ready. lxc-start will
    check this later. Return true, because the container is created.
    
    Signed-off-by: Sheng Yong <shyodx@gmail.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9d537a6..7a4d75f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1086,7 +1086,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags,
 		char *const argv[])
 {
-	bool bret = false;
+	bool ret = false;
 	pid_t pid;
 	char *tpath = NULL;
 	int partial_fd;
@@ -1108,8 +1108,10 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	}
 
 	/* container is already created if we have a config and rootfs.path is accessible */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0)
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0 && !tpath) {
+		ret = true;
 		goto out;
+	}
 
 	/* Mark that this container is being created */
 	if ((partial_fd = create_partial(c)) < 0)
@@ -1175,7 +1177,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 			goto out_unlock;
 		}
 	}
-	bret = load_config_locked(c, c->configfile);
+	ret = load_config_locked(c, c->configfile);
 
 out_unlock:
 	if (partial_fd >= 0)
@@ -1183,9 +1185,9 @@ out_unlock:
 out:
 	if (tpath)
 		free(tpath);
-	if (!bret && c)
+	if (!ret && c)
 		lxcapi_destroy(c);
-	return bret;
+	return ret;
 }
 
 static bool lxcapi_reboot(struct lxc_container *c)

commit 4e03ae57eddef788856415673b6d9bc0e3370795
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Oct 29 14:38:00 2013 -0400

    fix free() of args to startl
    
    Coverity 1076328 marked this as "Use after free", which it isn't really,
    its actually just free()ing the wrong 2nd, 3rd, etc... pointers. Test by
    passing two or more args to startl, without this change you get segfault
    when free()ing the second pointer/arg.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f2f7240..9d537a6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -641,9 +641,9 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 
 out:
 	if (inargs) {
-		char *arg;
-		for (arg = *inargs; arg; arg++)
-			free(arg);
+		char **arg;
+		for (arg = inargs; *arg; arg++)
+			free(*arg);
 		free(inargs);
 	}
 

commit e853a32df142fe3cee161e03b00ffb229714fadb
Author: S.alar Onur <caglar@10ur.org>
Date:   Mon Oct 28 15:39:12 2013 -0400

    free getline allocated line variable to make valgrind happy
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1600276..f2f7240 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3129,6 +3129,9 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 	if (names)
 		*names = unique_names;
 
+	if (line)
+		free(line);
+
 	process_lock();
 	fclose(f);
 	process_unlock();
@@ -3145,6 +3148,9 @@ free_bad:
 			lxc_container_put((*cret)[i]);
 		free(*cret);
 	}
+	if (line)
+		free(line);
+
 	process_lock();
 	fclose(f);
 	process_unlock();

commit 9c88ff1f95eea1e1b2c06c22fcc09c5cb94bd270
Author: S.alar Onur <caglar@10ur.org>
Date:   Thu Oct 24 00:02:37 2013 -0400

    Eliminate duplicate entries from list_active_containers (v2)
    
    list_active_containers parses /proc/net/unix which can contain multiple entries for the same container;
    
    0000000000000000: 00000002 00000000 00010000 0001 01 273672 @/var/lib/lxc/6/command
    0000000000000000: 00000002 00000000 00010000 0001 01 274395 @/var/lib/lxc/5/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273890 @/var/lib/lxc/4/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273141 @/var/lib/lxc/3/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273915 @/var/lib/lxc/2/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273683 @/var/lib/lxc/1/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273074 @/var/lib/lxc/0/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273931 @/var/lib/lxc/9/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273110 @/var/lib/lxc/8/command
    0000000000000000: 00000002 00000000 00010000 0001 01 273390 @/var/lib/lxc/7/command
    0000000000000000: 00000003 00000000 00000000 0001 03 275903 @/var/lib/lxc/8/command
    0000000000000000: 00000003 00000000 00000000 0001 03 276043 @/var/lib/lxc/1/command
    0000000000000000: 00000003 00000000 00000000 0001 03 273301 @/var/lib/lxc/0/command
    0000000000000000: 00000003 00000000 00000000 0001 03 275650 @/var/lib/lxc/4/command
    
    On this system list_active_containers returns 14 containers while only 10 containers are running.
    
    Following patch;
    
    	* Introduces array_contains function to do a binary search on given array,
    	* Starts to sort arrays inside the add_to_clist and add_to_names functions,
    	* Consumes array_contains in list_active_containers to eliminate duplicates,
    	* Replaces the linear search code in lxcapi_get_interfaces with the new function.
    
    Changes since v1:
    	* Do not load containers if a if a container list is not passed in
    	* Fix possible memory leaks in lxcapi_get_ips and lxcapi_get_interfaces if realloc fails
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9aea614..1600276 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1322,12 +1322,81 @@ out:
 	return false;
 }
 
+// used by qsort and bsearch functions for comparing names
+static inline int string_cmp(char **first, char **second)
+{
+	return strcmp(*first, *second);
+}
+
+// used by qsort and bsearch functions for comparing container names
+static inline int container_cmp(struct lxc_container **first, struct lxc_container **second)
+{
+	return strcmp((*first)->name, (*second)->name);
+}
+
+static bool add_to_array(char ***names, char *cname, int pos)
+{
+	char **newnames = realloc(*names, (pos+1) * sizeof(char *));
+	if (!newnames) {
+		ERROR("Out of memory");
+		return false;
+	}
+
+	*names = newnames;
+	newnames[pos] = strdup(cname);
+	if (!newnames[pos])
+		return false;
+
+	// sort the arrray as we will use binary search on it
+	qsort(newnames, pos + 1, sizeof(char *), (int (*)(const void *,const void *))string_cmp);
+
+	return true;
+}
+
+static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos)
+{
+	struct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));
+	if (!newlist) {
+		ERROR("Out of memory");
+		return false;
+	}
+
+	*list = newlist;
+	newlist[pos] = c;
+
+	// sort the arrray as we will use binary search on it
+	qsort(newlist, pos + 1, sizeof(struct lxc_container *), (int (*)(const void *,const void *))container_cmp);
+
+	return true;
+}
+
+static char** get_from_array(char ***names, char *cname, int size)
+{
+	return (char **)bsearch(&cname, *names, size, sizeof(char *), (int (*)(const void *, const void *))string_cmp);
+}
+
+
+static bool array_contains(char ***names, char *cname, int size) {
+	if(get_from_array(names, cname, size) != NULL)
+		return true;
+	return false;
+}
+
+static bool remove_from_array(char ***names, char *cname, int size)
+{
+	char **result = get_from_array(names, cname, size);
+	if (result != NULL) {
+		free(result);
+		return true;
+	}
+	return false;
+}
+
 static char** lxcapi_get_interfaces(struct lxc_container *c)
 {
-	int count = 0, i;
-	bool found = false;
+	int i, count = 0;
 	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
-	char **interfaces = NULL, **temp;
+	char **interfaces = NULL;
 	int old_netns = -1, new_netns = -1;
 
 	if (!enter_to_ns(c, &old_netns, &new_netns))
@@ -1341,51 +1410,41 @@ static char** lxcapi_get_interfaces(struct lxc_container *c)
 
 	/* Iterate through the interfaces */
 	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
-		/*
-		 * WARNING: Following "for" loop does a linear search over the interfaces array
-		 * For the containers with lots of interfaces this may be problematic.
-		 * I'm not expecting this to be the common usage but if it turns out to be
-		 *     than using binary search or a hash table could be more elegant solution.
-		 */
-		for (i = 0; i < count; i++) {
-			if (strcmp(interfaces[i], tempIfAddr->ifa_name) == 0) {
-				found = true;
-				break;
-			}
-		}
+		if (array_contains(&interfaces, tempIfAddr->ifa_name, count))
+			continue;
 
-		if (!found) {
-			count += 1;
-			temp = realloc(interfaces, count * sizeof(*interfaces));
-			if (!temp) {
-				count -= 1;
-				goto out;
-			}
-			interfaces = temp;
-			interfaces[count - 1] = strdup(tempIfAddr->ifa_name);
-		}
-		found = false;
-    }
+		if(!add_to_array(&interfaces, tempIfAddr->ifa_name, count))
+			goto err;
+		count++;
+	}
 
 out:
-       if (interfaceArray)
-               freeifaddrs(interfaceArray);
+	if (interfaceArray)
+		freeifaddrs(interfaceArray);
+
+	exit_from_ns(c, &old_netns, &new_netns);
 
-       exit_from_ns(c, &old_netns, &new_netns);
+	/* Append NULL to the array */
+	if(interfaces)
+		interfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);
 
-       /* Append NULL to the array */
-       interfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);
+	return interfaces;
 
-       return interfaces;
+err:
+	for(i=0;i<count;i++)
+		free(interfaces[i]);
+	free(interfaces);
+	interfaces = NULL;
+	goto out;
 }
 
 static char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, int scope)
 {
-	int count = 0;
+	int i, count = 0;
 	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
 	char addressOutputBuffer[INET6_ADDRSTRLEN];
 	void *tempAddrPtr = NULL;
-	char **addresses = NULL, **temp;
+	char **addresses = NULL;
 	char *address = NULL;
 	int old_netns = -1, new_netns = -1;
 
@@ -1430,14 +1489,9 @@ static char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* fam
 		if (!address)
 			continue;
 
-		count += 1;
-		temp = realloc(addresses, count * sizeof(*addresses));
-		if (!temp) {
-			count--;
-			goto out;
-		}
-		addresses = temp;
-		addresses[count - 1] = strdup(address);
+		if(!add_to_array(&addresses, address, count))
+			goto err;
+		count++;
 	}
 
 out:
@@ -1447,9 +1501,18 @@ out:
 	exit_from_ns(c, &old_netns, &new_netns);
 
 	/* Append NULL to the array */
-	addresses = (char **)lxc_append_null_to_array((void **)addresses, count);
+	if(addresses)
+		addresses = (char **)lxc_append_null_to_array((void **)addresses, count);
 
 	return addresses;
+
+err:
+	for(i=0;i<count;i++)
+		free(addresses[i]);
+	free(addresses);
+	addresses = NULL;
+
+	goto out;
 }
 
 static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
@@ -2884,34 +2947,6 @@ int lxc_get_wait_states(const char **states)
 	return MAX_STATE;
 }
 
-
-static bool add_to_names(char ***names, char *cname, int pos)
-{
-	char **newnames = realloc(*names, (pos+1) * sizeof(char *));
-	if (!newnames) {
-		ERROR("Out of memory");
-		return false;
-	}
-	*names = newnames;
-	newnames[pos] = strdup(cname);
-	if (!newnames[pos])
-		return false;
-	return true;
-}
-
-static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos)
-{
-	struct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));
-	if (!newlist) {
-		ERROR("Out of memory");
-		return false;
-	}
-
-	*list = newlist;
-	newlist[pos] = c;
-	return true;
-}
-
 /*
  * These next two could probably be done smarter with reusing a common function
  * with different iterators and tests...
@@ -2952,7 +2987,7 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 			continue;
 
 		if (names) {
-			if (!add_to_names(names, direntp->d_name, cfound))
+			if (!add_to_array(names, direntp->d_name, cfound))
 				goto free_bad;
 		}
 		cfound++;
@@ -2967,14 +3002,16 @@ int list_defined_containers(const char *lxcpath, char ***names, struct lxc_conta
 			INFO("Container %s:%s has a config but could not be loaded",
 				lxcpath, direntp->d_name);
 			if (names)
-				free((*names)[cfound--]);
+				if(!remove_from_array(names, direntp->d_name, cfound--))
+					goto free_bad;
 			continue;
 		}
 		if (!lxcapi_is_defined(c)) {
 			INFO("Container %s:%s has a config but is not defined",
 				lxcpath, direntp->d_name);
 			if (names)
-				free((*names)[cfound--]);
+				if(!remove_from_array(names, direntp->d_name, cfound--))
+					goto free_bad;
 			lxc_container_put(c);
 			continue;
 		}
@@ -3013,6 +3050,7 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 	int i, cfound = 0, nfound = 0;
 	int lxcpath_len;
 	char *line = NULL;
+	char **unique_names = NULL;
 	size_t len = 0;
 	struct lxc_container *c;
 
@@ -3051,10 +3089,12 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 			continue;
 		*p2 = '\0';
 
-		if (names) {
-			if (!add_to_names(names, p, nfound))
-				goto free_bad;
-		}
+		if (array_contains(&unique_names, p, nfound))
+			continue;
+
+		if (!add_to_array(&unique_names, p, nfound))
+			goto free_bad;
+
 		cfound++;
 
 		if (!cret) {
@@ -3066,8 +3106,10 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 		if (!c) {
 			INFO("Container %s:%s is running but could not be loaded",
 				lxcpath, p);
-			if (names)
-				free((*names)[cfound--]);
+			if (names) {
+				if(!remove_from_array(&unique_names, p, cfound--))
+					goto free_bad;
+			}
 			continue;
 		}
 
@@ -3084,6 +3126,9 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 		nfound++;
 	}
 
+	if (names)
+		*names = unique_names;
+
 	process_lock();
 	fclose(f);
 	process_unlock();

commit c4d10a05c309dcf8b8577c36d641f8943f66cde2
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 23 01:02:58 2013 +0000

    fix chowning of tty and console uids
    
    It needs to be done from the handler, not the container, since
    the container may not have the rights.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>
    
    Changelog:
        Jul 22: remove hardcoded path for /bin/chown
        Jul 22: use new lxc-usernsexec
    
    Conflicts:
    	src/lxc/lxccontainer.c

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fca0da2..9aea614 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -694,49 +694,6 @@ static const char *lxcapi_get_config_path(struct lxc_container *c);
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
 
 /*
- * chown_mapped: for an unprivileged user with uid X to chown a dir
- * to subuid Y, he needs to run chown as root in a userns where
- * nsid 0 is mapped to hostuid Y, and nsid Y is mapped to hostuid
- * X.  That way, the container root is privileged with respect to
- * hostuid X, allowing him to do the chown.
- */
-static int chown_mapped(int nsrootid, char *path)
-{
-	if (nsrootid < 0)
-		return nsrootid;
-	pid_t pid = fork();
-	if (pid < 0) {
-		SYSERROR("Failed forking");
-		return -1;
-	}
-	if (!pid) {
-		int hostuid = geteuid(), ret;
-		char map1[100], map2[100];
-		char *args[] = {"lxc-usernsexec", "-m", map1, "-m", map2, "--", "chown",
-				 "0", path, NULL};
-
-		// "b:0:nsrootid:1"
-		ret = snprintf(map1, 100, "b:0:%d:1", nsrootid);
-		if (ret < 0 || ret >= 100) {
-			ERROR("Error uid printing map string");
-			return -1;
-		}
-
-		// "b:hostuid:hostuid:1"
-		ret = snprintf(map2, 100, "b:%d:%d:1", hostuid, hostuid);
-		if (ret < 0 || ret >= 100) {
-			ERROR("Error uid printing map string");
-			return -1;
-		}
-
-		ret = execvp("lxc-usernsexec", args);
-		SYSERROR("Failed executing lxc-usernsexec");
-		exit(1);
-	}
-	return wait_for_pid(pid);
-}
-
-/*
  * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
  * it returns a mounted bdev on success, NULL on error.
  */
@@ -768,15 +725,8 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	 * target uidmap */
 
 	if (geteuid() != 0) {
-		int rootid;
-		if ((rootid = get_mapped_rootid(c->lxc_conf)) <= 0) {
-			ERROR("No mapping for container root");
-			bdev_put(bdev);
-			return NULL;
-		}
-		ret = chown_mapped(rootid, bdev->dest);
-		if (ret < 0) {
-			ERROR("Error chowning %s to %d\n", bdev->dest, rootid);
+		if (chown_mapped_root(bdev->dest, c->lxc_conf) < 0) {
+			ERROR("Error chowning %s to container root\n", bdev->dest);
 			bdev_put(bdev);
 			return NULL;
 		}

commit cf3ef16dc479c102433a82b8ddbb4265d3818cce
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Oct 23 01:02:57 2013 +0000

    container creation: support unpriv container creation in user namespaces
    
    1. lxcapi_create: don't try to unshare and mount for dir backed containers
    
    It's unnecessary, and breaks unprivileged lxc-create (since unpriv users
    cannot yet unshare(CLONE_NEWNS)).
    
    2. api_create: chown rootfs
    
    chown rootfs to the host uid to which container root will be mapped
    
    3. create: run template in a mapped user ns
    
    4. use (setuid-root) newxidmap to set id_map if we are not root
    
    This is needed to be able to set userns mappings as an unprivileged
    user, for unprivileged lxc-start.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6e6c38c..fca0da2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -694,6 +694,49 @@ static const char *lxcapi_get_config_path(struct lxc_container *c);
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
 
 /*
+ * chown_mapped: for an unprivileged user with uid X to chown a dir
+ * to subuid Y, he needs to run chown as root in a userns where
+ * nsid 0 is mapped to hostuid Y, and nsid Y is mapped to hostuid
+ * X.  That way, the container root is privileged with respect to
+ * hostuid X, allowing him to do the chown.
+ */
+static int chown_mapped(int nsrootid, char *path)
+{
+	if (nsrootid < 0)
+		return nsrootid;
+	pid_t pid = fork();
+	if (pid < 0) {
+		SYSERROR("Failed forking");
+		return -1;
+	}
+	if (!pid) {
+		int hostuid = geteuid(), ret;
+		char map1[100], map2[100];
+		char *args[] = {"lxc-usernsexec", "-m", map1, "-m", map2, "--", "chown",
+				 "0", path, NULL};
+
+		// "b:0:nsrootid:1"
+		ret = snprintf(map1, 100, "b:0:%d:1", nsrootid);
+		if (ret < 0 || ret >= 100) {
+			ERROR("Error uid printing map string");
+			return -1;
+		}
+
+		// "b:hostuid:hostuid:1"
+		ret = snprintf(map2, 100, "b:%d:%d:1", hostuid, hostuid);
+		if (ret < 0 || ret >= 100) {
+			ERROR("Error uid printing map string");
+			return -1;
+		}
+
+		ret = execvp("lxc-usernsexec", args);
+		SYSERROR("Failed executing lxc-usernsexec");
+		exit(1);
+	}
+	return wait_for_pid(pid);
+}
+
+/*
  * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
  * it returns a mounted bdev on success, NULL on error.
  */
@@ -720,6 +763,25 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	}
 
 	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+
+	/* if we are not root, chown the rootfs dir to root in the
+	 * target uidmap */
+
+	if (geteuid() != 0) {
+		int rootid;
+		if ((rootid = get_mapped_rootid(c->lxc_conf)) <= 0) {
+			ERROR("No mapping for container root");
+			bdev_put(bdev);
+			return NULL;
+		}
+		ret = chown_mapped(rootid, bdev->dest);
+		if (ret < 0) {
+			ERROR("Error chowning %s to %d\n", bdev->dest, rootid);
+			bdev_put(bdev);
+			return NULL;
+		}
+	}
+
 	return bdev;
 }
 
@@ -785,6 +847,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		int i;
 		int ret, len, nargs = 0;
 		char **newargv;
+		struct lxc_conf *conf = c->lxc_conf;
 
 		process_unlock(); // we're no longer sharing
 		if (quiet) {
@@ -795,10 +858,6 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 			open("/dev/null", O_RDWR);
 			open("/dev/null", O_RDWR);
 		}
-		if (unshare(CLONE_NEWNS) < 0) {
-			ERROR("error unsharing mounts");
-			exit(1);
-		}
 
 		src = c->lxc_conf->rootfs.path;
 		/*
@@ -815,9 +874,19 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 			exit(1);
 		}
 
-		if (bdev->ops->mount(bdev) < 0) {
-			ERROR("Error mounting rootfs");
-			exit(1);
+		if (strcmp(bdev->type, "dir") != 0) {
+			if (unshare(CLONE_NEWNS) < 0) {
+				ERROR("error unsharing mounts");
+				exit(1);
+			}
+			if (bdev->ops->mount(bdev) < 0) {
+				ERROR("Error mounting rootfs");
+				exit(1);
+			}
+		} else { // TODO come up with a better way here!
+			if (bdev->dest)
+				free(bdev->dest);
+			bdev->dest = strdup(bdev->src);
 		}
 
 		/*
@@ -827,6 +896,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		if (argv)
 			for (nargs = 0; argv[nargs]; nargs++) ;
 		nargs += 4;  // template, path, rootfs and name args
+
 		newargv = malloc(nargs * sizeof(*newargv));
 		if (!newargv)
 			exit(1);
@@ -870,8 +940,68 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 			exit(1);
 		newargv[nargs - 1] = NULL;
 
+		/*
+		 * If we're running the template in a mapped userns, then
+		 * we prepend the template command with:
+		 * lxc-usernsexec <-m map1> ... <-m mapn> --
+		 */
+		if (geteuid() != 0 && !lxc_list_empty(&conf->id_map)) {
+			int n2args = 1;
+			char **n2 = malloc(n2args * sizeof(*n2));
+			struct lxc_list *it;
+			struct id_map *map;
+
+			newargv[0] = tpath;
+			tpath = "lxc-usernsexec";
+			n2[0] = "lxc-usernsexec";
+			lxc_list_for_each(it, &conf->id_map) {
+				map = it->elem;
+				n2args += 2;
+				n2 = realloc(n2, n2args * sizeof(*n2));
+				if (!n2)
+					exit(1);
+				n2[n2args-2] = "-m";
+				n2[n2args-1] = malloc(200);
+				if (!n2[n2args-1])
+					exit(1);
+				ret = snprintf(n2[n2args-1], 200, "%c:%lu:%lu:%lu",
+					map->idtype == ID_TYPE_UID ? 'u' : 'g',
+					map->nsid, map->hostid, map->range);
+				if (ret < 0 || ret >= 200)
+					exit(1);
+			}
+			bool hostid_mapped = hostid_is_mapped(geteuid(), conf);
+			int extraargs = hostid_mapped ?  1 : 3;
+			n2 = realloc(n2, (nargs + n2args + extraargs) * sizeof(*n2));
+			if (!n2)
+				exit(1);
+			if (!hostid_mapped) {
+				int free_id = find_unmapped_nsuid(conf);
+				n2[n2args++] = "-m";
+				if (free_id < 0) {
+					ERROR("Could not find free uid to map");
+					exit(1);
+				}
+				n2[n2args++] = malloc(200);
+				if (!n2[n2args-1]) {
+					SYSERROR("out of memory");
+					exit(1);
+				}
+				ret = snprintf(n2[n2args-1], 200, "u:%d:%d:1",
+					free_id, geteuid());
+				if (ret < 0 || ret >= 200) {
+					ERROR("string too long");
+					exit(1);
+				}
+			}
+			n2[n2args++] = "--";
+			for (i = 0; i < nargs; i++)
+				n2[i + n2args] = newargv[i];
+			free(newargv);
+			newargv = n2;
+		}
 		/* execute */
-		execv(tpath, newargv);
+		execvp(tpath, newargv);
 		SYSERROR("failed to execute template %s", tpath);
 		exit(1);
 	}
@@ -2102,15 +2232,21 @@ static int clone_update_rootfs(struct lxc_container *c0,
 		return wait_for_pid(pid);
 
 	process_unlock(); // we're no longer sharing
-	if (unshare(CLONE_NEWNS) < 0) {
-		ERROR("error unsharing mounts");
-		exit(1);
-	}
 	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (!bdev)
 		exit(1);
-	if (bdev->ops->mount(bdev) < 0)
-		exit(1);
+	if (strcmp(bdev->type, "dir") != 0) {
+		if (unshare(CLONE_NEWNS) < 0) {
+			ERROR("error unsharing mounts");
+			exit(1);
+		}
+		if (bdev->ops->mount(bdev) < 0)
+			exit(1);
+	} else { // TODO come up with a better way
+		if (bdev->dest)
+			free(bdev->dest);
+		bdev->dest = strdup(bdev->src);
+	}
 
 	if (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {
 		/* Start of environment variable setup for hooks */

commit 9d65a4872917d4bed744aaddafc99046c588e7ae
Author: KATOH Yasufumi <karma@jazz.email.ne.jp>
Date:   Wed Oct 23 21:00:53 2013 +0900

    Fix segfault on lxc-create when no template specified
    
    When no template file is specified on lxc-create, recieve segfault.
    So change not to append header in config when no template is specified.
    
    Signed-off-by: KATOH Yasufumi <karma@jazz.email.ne.jp>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c8ecef3..6e6c38c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1089,9 +1089,11 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
 
-	if (!prepend_lxc_header(c->configfile, tpath, argv)) {
-		ERROR("Error prepending header to configuration file");
-		goto out_unlock;
+	if (t) {
+		if (!prepend_lxc_header(c->configfile, tpath, argv)) {
+			ERROR("Error prepending header to configuration file");
+			goto out_unlock;
+		}
 	}
 	bret = load_config_locked(c, c->configfile);
 

commit 771d96b3807ed090a5dd341302d6317acdfb16ca
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Oct 19 00:49:20 2013 -0400

    introduce snapshot_destroy
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c46adf3..c8ecef3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2614,6 +2614,38 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, char *snapname, cha
 	return b;
 }
 
+static bool lxcapi_snapshot_destroy(struct lxc_container *c, char *snapname)
+{
+	int ret;
+	char clonelxcpath[MAXPATHLEN];
+	struct lxc_container *snap = NULL;
+
+	if (!c || !c->name || !c->config_path)
+		return false;
+
+	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		goto err;
+
+	snap = lxc_container_new(snapname, clonelxcpath);
+	if (!snap || !lxcapi_is_defined(snap)) {
+		ERROR("Could not find snapshot %s", snapname);
+		goto err;
+	}
+
+	if (!lxcapi_destroy(snap)) {
+		ERROR("Could not destroy snapshot %s", snapname);
+		goto err;
+	}
+	lxc_container_put(snap);
+
+	return true;
+err:
+	if (snap)
+		lxc_container_put(snap);
+	return false;
+}
+
 static bool lxcapi_may_control(struct lxc_container *c)
 {
 	return lxc_try_cmd(c->name, c->config_path) == 0;
@@ -2738,6 +2770,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->snapshot = lxcapi_snapshot;
 	c->snapshot_list = lxcapi_snapshot_list;
 	c->snapshot_restore = lxcapi_snapshot_restore;
+	c->snapshot_destroy = lxcapi_snapshot_destroy;
 	c->may_control = lxcapi_may_control;
 
 	/* we'll allow the caller to update these later */

commit 0f8f9c8aa41b0db9a1896e8eff5a4b810f123cd5
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Oct 18 18:00:24 2013 -0400

    lxccontainer.c: Replace rindex by strrchr (bionic)
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 616c92d..c46adf3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2911,7 +2911,7 @@ int list_active_containers(const char *lxcpath, char ***names, struct lxc_contai
 		return -1;
 
 	while (getline(&line, &len, f) != -1) {
-		char *p = rindex(line, ' '), *p2;
+		char *p = strrchr(line, ' '), *p2;
 		if (!p)
 			continue;
 		p++;

commit f99c386b60e7f635c2f95a2e3256f21e751fb50b
Author: Sidnei da Silva <sidnei.da.silva@canonical.com>
Date:   Mon Aug 19 19:34:19 2013 -0300

    Add a --thinpool argument to lxc-create, to use thin pool backed lvm when creating the container. When cloning a container backed by a thin pool, the clone will default to the same thin pool.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6f97879..616c92d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1807,6 +1807,11 @@ const char *lxc_get_default_lvm_vg(void)
 	return default_lvm_vg();
 }
 
+const char *lxc_get_default_lvm_thin_pool(void)
+{
+	return default_lvm_thin_pool();
+}
+
 const char *lxc_get_default_zfs_root(void)
 {
 	return default_zfs_root();

commit a41f104bfbd69e5f068e5ca312a2eb513d9e81b8
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Oct 11 10:44:39 2013 -0500

    define list container api (v2)
    
    Two new commands are defined: list_defined_containers() and
    list_active_containers().  Both take an lxcpath (NULL means
    use the default lxcpath) and return the number of containers
    found.  If a lxc_container ** is passed in, then an array of
    lxc_container's is returned, one for each container found.
    The caller must then lxc_container_put() each container and
    free the array, as shown in the new list testcase.
    If a char ** is passed in, then an array of container names
    is returned, after which the caller must free all the names
    and the name array, as showsn in the testcase.
    
    Changelog:
    	Check for the container config file before trying to
    	create an lxc_container *, to save some work. [ per
    	stgraber comments]
    	Add names ** argument to return only container names.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 13ed4d2..6f97879 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -69,6 +69,19 @@ static bool file_exists(char *f)
 	return stat(f, &statbuf) == 0;
 }
 
+static bool config_file_exists(const char *lxcpath, const char *cname)
+{
+	/* $lxcpath + '/' + $cname + '/config' + \0 */
+	int ret, len = strlen(lxcpath) + strlen(cname) + 9;
+	char *fname = alloca(len);
+
+	ret = snprintf(fname, len,  "%s/%s/config", lxcpath, cname);
+	if (ret < 0 || ret >= len)
+		return false;
+
+	return file_exists(fname);
+}
+
 /*
  * A few functions to help detect when a container creation failed.
  * If a container creation was killed partway through, then trying
@@ -2744,3 +2757,225 @@ int lxc_get_wait_states(const char **states)
 			states[i] = lxc_state2str(i);
 	return MAX_STATE;
 }
+
+
+static bool add_to_names(char ***names, char *cname, int pos)
+{
+	char **newnames = realloc(*names, (pos+1) * sizeof(char *));
+	if (!newnames) {
+		ERROR("Out of memory");
+		return false;
+	}
+	*names = newnames;
+	newnames[pos] = strdup(cname);
+	if (!newnames[pos])
+		return false;
+	return true;
+}
+
+static bool add_to_clist(struct lxc_container ***list, struct lxc_container *c, int pos)
+{
+	struct lxc_container **newlist = realloc(*list, (pos+1) * sizeof(struct lxc_container *));
+	if (!newlist) {
+		ERROR("Out of memory");
+		return false;
+	}
+
+	*list = newlist;
+	newlist[pos] = c;
+	return true;
+}
+
+/*
+ * These next two could probably be done smarter with reusing a common function
+ * with different iterators and tests...
+ */
+int list_defined_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)
+{
+	DIR *dir;
+	int i, cfound = 0, nfound = 0;
+	struct dirent dirent, *direntp;
+	struct lxc_container *c;
+
+	if (!lxcpath)
+		lxcpath = default_lxc_path();
+
+	process_lock();
+	dir = opendir(lxcpath);
+	process_unlock();
+
+	if (!dir) {
+		SYSERROR("opendir on lxcpath");
+		return -1;
+	}
+
+	if (cret)
+		*cret = NULL;
+	if (names)
+		*names = NULL;
+
+	while (!readdir_r(dir, &dirent, &direntp)) {
+		if (!direntp)
+			break;
+		if (!strcmp(direntp->d_name, "."))
+			continue;
+		if (!strcmp(direntp->d_name, ".."))
+			continue;
+
+		if (!config_file_exists(lxcpath, direntp->d_name))
+			continue;
+
+		if (names) {
+			if (!add_to_names(names, direntp->d_name, cfound))
+				goto free_bad;
+		}
+		cfound++;
+
+		if (!cret) {
+			nfound++;
+			continue;
+		}
+
+		c = lxc_container_new(direntp->d_name, lxcpath);
+		if (!c) {
+			INFO("Container %s:%s has a config but could not be loaded",
+				lxcpath, direntp->d_name);
+			if (names)
+				free((*names)[cfound--]);
+			continue;
+		}
+		if (!lxcapi_is_defined(c)) {
+			INFO("Container %s:%s has a config but is not defined",
+				lxcpath, direntp->d_name);
+			if (names)
+				free((*names)[cfound--]);
+			lxc_container_put(c);
+			continue;
+		}
+
+		if (!add_to_clist(cret, c, nfound)) {
+			lxc_container_put(c);
+			goto free_bad;
+		}
+		nfound++;
+	}
+
+	process_lock();
+	closedir(dir);
+	process_unlock();
+	return nfound;
+
+free_bad:
+	if (names && *names) {
+		for (i=0; i<cfound; i++)
+			free((*names)[i]);
+		free(*names);
+	}
+	if (cret && *cret) {
+		for (i=0; i<nfound; i++)
+			lxc_container_put((*cret)[i]);
+		free(*cret);
+	}
+	process_lock();
+	closedir(dir);
+	process_unlock();
+	return -1;
+}
+
+int list_active_containers(const char *lxcpath, char ***names, struct lxc_container ***cret)
+{
+	int i, cfound = 0, nfound = 0;
+	int lxcpath_len;
+	char *line = NULL;
+	size_t len = 0;
+	struct lxc_container *c;
+
+	if (!lxcpath)
+		lxcpath = default_lxc_path();
+	lxcpath_len = strlen(lxcpath);
+
+	if (cret)
+		*cret = NULL;
+	if (names)
+		*names = NULL;
+
+	process_lock();
+	FILE *f = fopen("/proc/net/unix", "r");
+	process_unlock();
+	if (!f)
+		return -1;
+
+	while (getline(&line, &len, f) != -1) {
+		char *p = rindex(line, ' '), *p2;
+		if (!p)
+			continue;
+		p++;
+		if (*p != 0x40)
+			continue;
+		p++;
+		if (strncmp(p, lxcpath, lxcpath_len) != 0)
+			continue;
+		p += lxcpath_len;
+		while (*p == '/')
+			p++;
+
+		// Now p is the start of lxc_name
+		p2 = index(p, '/');
+		if (!p2 || strncmp(p2, "/command", 8) != 0)
+			continue;
+		*p2 = '\0';
+
+		if (names) {
+			if (!add_to_names(names, p, nfound))
+				goto free_bad;
+		}
+		cfound++;
+
+		if (!cret) {
+			nfound++;
+			continue;
+		}
+
+		c = lxc_container_new(p, lxcpath);
+		if (!c) {
+			INFO("Container %s:%s is running but could not be loaded",
+				lxcpath, p);
+			if (names)
+				free((*names)[cfound--]);
+			continue;
+		}
+
+		/*
+		 * If this is an anonymous container, then is_defined *can*
+		 * return false.  So we don't do that check.  Count on the
+		 * fact that the command socket exists.
+		 */
+
+		if (!add_to_clist(cret, c, nfound)) {
+			lxc_container_put(c);
+			goto free_bad;
+		}
+		nfound++;
+	}
+
+	process_lock();
+	fclose(f);
+	process_unlock();
+	return nfound;
+
+free_bad:
+	if (names && *names) {
+		for (i=0; i<cfound; i++)
+			free((*names)[i]);
+		free(*names);
+	}
+	if (cret && *cret) {
+		for (i=0; i<nfound; i++)
+			lxc_container_put((*cret)[i]);
+		free(*cret);
+	}
+	process_lock();
+	fclose(f);
+	process_unlock();
+	return -1;
+}

commit 9baa57bdd4e8aac1ce4fe792065ac5eb2981ec38
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Oct 7 14:03:20 2013 -0500

    coverity: closedir on error path
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 02126b2..13ed4d2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2538,6 +2538,10 @@ out_free:
 			lxcsnap_free(&snaps[i]);
 		free(snaps);
 	}
+	process_lock();
+	if (closedir(dir))
+		WARN("failed to close directory");
+	process_unlock();
 	return -1;
 }
 

commit b494d2ddf769220da1ef75fd24275ce68cdf297c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 27 21:01:07 2013 -0500

    add c->may_control
    
    This is an api function which will return false if the container
    is running, and the caller may not talk to its monitor over its
    command socket.  Otherwise - if the container is not running, or
    the caller may access it - it returns true.
    
    We can use this in several tools early on to prevent the segvs
    etc which we currently get.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3a2ae92..02126b2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -2592,6 +2592,11 @@ static bool lxcapi_snapshot_restore(struct lxc_container *c, char *snapname, cha
 	return b;
 }
 
+static bool lxcapi_may_control(struct lxc_container *c)
+{
+	return lxc_try_cmd(c->name, c->config_path) == 0;
+}
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -2711,6 +2716,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->snapshot = lxcapi_snapshot;
 	c->snapshot_list = lxcapi_snapshot_list;
 	c->snapshot_restore = lxcapi_snapshot_restore;
+	c->may_control = lxcapi_may_control;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit fe218ca38358dd69dd51fca6433088ac631d6240
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Sun Sep 29 19:41:52 2013 -0400

    Fix crasher in get_ips
    
    Check that the interface structure is not NULL before trying to access
    its members.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1b3f2f5..3a2ae92 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1305,6 +1305,9 @@ static char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* fam
 
 	/* Iterate through the interfaces */
 	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
+		if (tempIfAddr->ifa_addr == NULL)
+			continue;
+
 		if(tempIfAddr->ifa_addr->sa_family == AF_INET) {
 			if (family && strcmp(family, "inet"))
 				continue;

commit 566981770e840b9043f57dac15958a723413e688
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Sep 26 08:14:50 2013 -0500

    drop now-useless have_tpath bool
    
    (Which will also break failure-to-build in the !HAVE_LIBGNUTLS
    case)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d3f5b0d..1b3f2f5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -881,7 +881,6 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	int i;
 	unsigned char md_value[SHA_DIGEST_LENGTH];
 	char *tpath;
-	bool have_tpath = false;
 #endif
 
 	process_lock();
@@ -916,7 +915,6 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		goto out_free_contents;
 	}
 
-	have_tpath = true;
 	ret = sha1sum_file(tpath, md_value);
 	if (ret < 0) {
 		ERROR("Error getting sha1sum of %s", tpath);
@@ -944,12 +942,10 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		fprintf(f, "\n");
 	}
 #if HAVE_LIBGNUTLS
-	if (have_tpath) {
-		fprintf(f, "# Template script checksum (SHA-1): ");
-		for (i=0; i<SHA_DIGEST_LENGTH; i++)
-			fprintf(f, "%02x", md_value[i]);
-		fprintf(f, "\n");
-	}
+	fprintf(f, "# Template script checksum (SHA-1): ");
+	for (i=0; i<SHA_DIGEST_LENGTH; i++)
+		fprintf(f, "%02x", md_value[i]);
+	fprintf(f, "\n");
 #endif
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");

commit 85db5535c346fcba1ff6c30835ebd3a95214da04
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Wed Sep 25 18:18:28 2013 -0400

    fix segfault on lxc-create with bad template name
    
    - change get_template_path() to only return NULL or non-NULL since one of
      the callers was doing a free(-1) which caused the segfault. Handle the
      NULL template case in the lxcapi_create() caller.
    
    - make sure to free(tpath) in the sha1sum_file() failure case
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f5d41b3..d3f5b0d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -713,38 +713,32 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 /*
  * Given the '-t' template option to lxc-create, figure out what to
  * do.  If the template is a full executable path, use that.  If it
- * is something like 'sshd', then return $templatepath/lxc-sshd.  If
- * no template was passed in, return NULL  (this is ok).
- * On error return (char *) -1.
+ * is something like 'sshd', then return $templatepath/lxc-sshd.
+ * On success return the template, on error return NULL.
  */
-char *get_template_path(const char *t)
+static char *get_template_path(const char *t)
 {
 	int ret, len;
 	char *tpath;
 
-	if (!t)
-		return NULL;
-
 	if (t[0] == '/' && access(t, X_OK) == 0) {
 		tpath = strdup(t);
-		if (!tpath)
-			return (char *) -1;
 		return tpath;
 	}
 
 	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
 	tpath = malloc(len);
 	if (!tpath)
-		return (char *) -1;
+		return NULL;
 	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
 	if (ret < 0 || ret >= len) {
 		free(tpath);
-		return (char *) -1;
+		return NULL;
 	}
 	if (access(tpath, X_OK) < 0) {
 		SYSERROR("bad template: %s\n", t);
 		free(tpath);
-		return (char *) -1;
+		return NULL;
 	}
 
 	return tpath;
@@ -917,20 +911,19 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 
 #if HAVE_LIBGNUTLS
 	tpath = get_template_path(t);
-	if (tpath == (char *) -1) {
+	if (!tpath) {
 		ERROR("bad template: %s\n", t);
 		goto out_free_contents;
 	}
 
-	if (tpath) {
-		have_tpath = true;
-		ret = sha1sum_file(tpath, md_value);
-		if (ret < 0) {
-			ERROR("Error getting sha1sum of %s", tpath);
-			goto out_free_contents;
-		}
+	have_tpath = true;
+	ret = sha1sum_file(tpath, md_value);
+	if (ret < 0) {
+		ERROR("Error getting sha1sum of %s", tpath);
 		free(tpath);
+		goto out_free_contents;
 	}
+	free(tpath);
 #endif
 
 	process_lock();
@@ -1006,16 +999,18 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 {
 	bool bret = false;
 	pid_t pid;
-	char *tpath;
+	char *tpath = NULL;
 	int partial_fd;
 
 	if (!c)
 		return false;
 
-	tpath = get_template_path(t);
-	if (tpath == (char *) -1) {
-		ERROR("bad template: %s\n", t);
-		goto out;
+	if (t) {
+		tpath = get_template_path(t);
+		if (!tpath) {
+			ERROR("bad template: %s\n", t);
+			goto out;
+		}
 	}
 
 	if (!c->save_config(c, NULL)) {

commit 89cd77934835d1f04edd17c718d77591974e01f5
Author: Qiang Huang <h.huangqiang@huawei.com>
Date:   Tue Sep 24 15:27:53 2013 +0800

    utils: move remove_trailing_slashes to utils
    
    Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ea5a84e..f5d41b3 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -69,13 +69,6 @@ static bool file_exists(char *f)
 	return stat(f, &statbuf) == 0;
 }
 
-static void remove_trailing_slashes(char *p)
-{
-	int l = strlen(p);
-	while (--l >= 0 && (p[l] == '/' || p[l] == '\n'))
-		p[l] = '\0';
-}
-
 /*
  * A few functions to help detect when a container creation failed.
  * If a container creation was killed partway through, then trying

commit 948955a2d6f8e4e28bceada9666c5831de4a6bb8
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Sat Sep 21 17:43:45 2013 -0500

    Consistently use <lxc/lxccontainer.h> for the API
    
    The API header was included in a variety of ways before, standardize
    those to "include <lxc/lxccontainer.h>" as this will always work both in
    tree and on a system with the headers installed.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5c49b8b..ea5a84e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -31,7 +31,7 @@
 #include "config.h"
 #include "lxc.h"
 #include "state.h"
-#include "lxccontainer.h"
+#include <lxc/lxccontainer.h>
 #include "conf.h"
 #include "confile.h"
 #include "console.h"

commit 49badbbef602f1b8add1ea55d7cf0e1563bfe0db
Author: S.alar Onur <caglar@10ur.org>
Date:   Sat Sep 21 13:00:15 2013 -0400

    return the result of the lxcapi_want_close_all_fds call to the caller
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 727c680..5c49b8b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -456,16 +456,17 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 	container_mem_unlock(c);
 }
 
-static void lxcapi_want_close_all_fds(struct lxc_container *c)
+static bool lxcapi_want_close_all_fds(struct lxc_container *c)
 {
 	if (!c || !c->lxc_conf)
-		return;
+		return false;
 	if (container_mem_lock(c)) {
 		ERROR("Error getting mem lock");
-		return;
+		return false;
 	}
 	c->lxc_conf->close_all_fds = 1;
 	container_mem_unlock(c);
+	return true;
 }
 
 static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)

commit 130a188840ae655da41dde4771074ff38abaf46f
Author: S.alar Onur <caglar@10ur.org>
Date:   Fri Sep 20 18:45:21 2013 -0400

    Expose underlying close_all_fds config value via API
    
    Being able to set close_all_fds via API would be usefull for the
    situations like running an application (let's say web server)
    that controls the lifecycle of the container using the LXC API.
    We don't want forked process to inherit parent's resource (file, socket, ...)
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e8dde91..727c680 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -456,6 +456,18 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 	container_mem_unlock(c);
 }
 
+static void lxcapi_want_close_all_fds(struct lxc_container *c)
+{
+	if (!c || !c->lxc_conf)
+		return;
+	if (container_mem_lock(c)) {
+		ERROR("Error getting mem lock");
+		return;
+	}
+	c->lxc_conf->close_all_fds = 1;
+	container_mem_unlock(c);
+}
+
 static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 {
 	int ret;
@@ -2682,6 +2694,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->init_pid = lxcapi_init_pid;
 	c->load_config = lxcapi_load_config;
 	c->want_daemonize = lxcapi_want_daemonize;
+	c->want_close_all_fds = lxcapi_want_close_all_fds;
 	c->start = lxcapi_start;
 	c->startl = lxcapi_startl;
 	c->stop = lxcapi_stop;

commit 799f29ab699f08e67231b012f20a25e23a6c391d
Author: S.alar Onur <caglar@10ur.org>
Date:   Wed Sep 18 15:13:22 2013 -0400

    Add get_interfaces to the API
    
    get_ips accepts an interface name as a parameter but there was no
    way to get the interfaces names from the container. This patch
    introduces a new get_interfaces call to the API so that users
    can obtain the name of the interfaces.
    
    Support for python bindings also introduced as a part of this version.
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d77ce37..e8dde91 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1179,25 +1179,30 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
-char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, int scope)
-{
-	int count = 0;
-	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
-	char addressOutputBuffer[INET6_ADDRSTRLEN];
-	void *tempAddrPtr = NULL;
-	char **addresses = NULL, **temp;
-	char *address = NULL;
+static inline void exit_from_ns(struct lxc_container *c, int *old_netns, int *new_netns) {
+	/* Switch back to original netns */
+	if (*old_netns >= 0 && setns(*old_netns, CLONE_NEWNET))
+		SYSERROR("failed to setns");
+	process_lock();
+	if (*new_netns >= 0)
+		close(*new_netns);
+	if (*old_netns >= 0)
+		close(*old_netns);
+	process_unlock();
+}
+
+static inline bool enter_to_ns(struct lxc_container *c, int *old_netns, int *new_netns) {
+	int ret = 0;
 	char new_netns_path[MAXPATHLEN];
-	int old_netns = -1, new_netns = -1, ret = 0;
 
 	if (!c->is_running(c))
 		goto out;
 
 	/* Save reference to old netns */
 	process_lock();
-	old_netns = open("/proc/self/ns/net", O_RDONLY);
+	*old_netns = open("/proc/self/ns/net", O_RDONLY);
 	process_unlock();
-	if (old_netns < 0) {
+	if (*old_netns < 0) {
 		SYSERROR("failed to open /proc/self/ns/net");
 		goto out;
 	}
@@ -1208,17 +1213,92 @@ char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, in
 		goto out;
 
 	process_lock();
-	new_netns = open(new_netns_path, O_RDONLY);
+	*new_netns = open(new_netns_path, O_RDONLY);
 	process_unlock();
-	if (new_netns < 0) {
+	if (*new_netns < 0) {
 		SYSERROR("failed to open %s", new_netns_path);
 		goto out;
 	}
 
-	if (setns(new_netns, CLONE_NEWNET)) {
+	if (setns(*new_netns, CLONE_NEWNET)) {
 		SYSERROR("failed to setns");
 		goto out;
 	}
+	return true;
+out:
+	exit_from_ns(c, old_netns, new_netns);
+	return false;
+}
+
+static char** lxcapi_get_interfaces(struct lxc_container *c)
+{
+	int count = 0, i;
+	bool found = false;
+	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+	char **interfaces = NULL, **temp;
+	int old_netns = -1, new_netns = -1;
+
+	if (!enter_to_ns(c, &old_netns, &new_netns))
+		goto out;
+
+	/* Grab the list of interfaces */
+	if (getifaddrs(&interfaceArray)) {
+		SYSERROR("failed to get interfaces list");
+		goto out;
+	}
+
+	/* Iterate through the interfaces */
+	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
+		/*
+		 * WARNING: Following "for" loop does a linear search over the interfaces array
+		 * For the containers with lots of interfaces this may be problematic.
+		 * I'm not expecting this to be the common usage but if it turns out to be
+		 *     than using binary search or a hash table could be more elegant solution.
+		 */
+		for (i = 0; i < count; i++) {
+			if (strcmp(interfaces[i], tempIfAddr->ifa_name) == 0) {
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			count += 1;
+			temp = realloc(interfaces, count * sizeof(*interfaces));
+			if (!temp) {
+				count -= 1;
+				goto out;
+			}
+			interfaces = temp;
+			interfaces[count - 1] = strdup(tempIfAddr->ifa_name);
+		}
+		found = false;
+    }
+
+out:
+       if (interfaceArray)
+               freeifaddrs(interfaceArray);
+
+       exit_from_ns(c, &old_netns, &new_netns);
+
+       /* Append NULL to the array */
+       interfaces = (char **)lxc_append_null_to_array((void **)interfaces, count);
+
+       return interfaces;
+}
+
+static char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, int scope)
+{
+	int count = 0;
+	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+	char addressOutputBuffer[INET6_ADDRSTRLEN];
+	void *tempAddrPtr = NULL;
+	char **addresses = NULL, **temp;
+	char *address = NULL;
+	int old_netns = -1, new_netns = -1;
+
+	if (!enter_to_ns(c, &old_netns, &new_netns))
+		goto out;
 
 	/* Grab the list of interfaces */
 	if (getifaddrs(&interfaceArray)) {
@@ -1269,30 +1349,10 @@ out:
 	if(interfaceArray)
 		freeifaddrs(interfaceArray);
 
-	/* Switch back to original netns */
-	if (old_netns >= 0 && setns(old_netns, CLONE_NEWNET))
-		SYSERROR("failed to setns");
-	process_lock();
-	if (new_netns >= 0)
-		close(new_netns);
-	if (old_netns >= 0)
-		close(old_netns);
-	process_unlock();
+	exit_from_ns(c, &old_netns, &new_netns);
 
 	/* Append NULL to the array */
-	if (count) {
-		count++;
-		temp = realloc(addresses, count * sizeof(*addresses));
-		if (!temp) {
-			int i;
-			for (i = 0; i < count-1; i++)
-				free(addresses[i]);
-			free(addresses);
-			return NULL;
-		}
-		addresses = temp;
-		addresses[count - 1] = NULL;
-	}
+	addresses = (char **)lxc_append_null_to_array((void **)addresses, count);
 
 	return addresses;
 }
@@ -2642,6 +2702,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->get_config_path = lxcapi_get_config_path;
 	c->set_config_path = lxcapi_set_config_path;
 	c->clone = lxcapi_clone;
+	c->get_interfaces = lxcapi_get_interfaces;
 	c->get_ips = lxcapi_get_ips;
 	c->attach = lxcapi_attach;
 	c->attach_run_wait = lxcapi_attach_run_wait;

commit 025ed0f3911836b71f498d8368725c77a7e1932a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Sep 16 18:28:41 2013 -0500

    make heavier use of process_lock (v2)
    
    pthread_mutex_lock() will only return an error if it was set to
    PTHREAD_MUTEX_ERRORCHECK and we are recursively calling it (and
    would otherwise have deadlocked).  If that's the case then log a
    message for future debugging and exit.  Trying to "recover" is
    nonsense at that point.
    
    process_lock() was held over too long a time in lxcapi_start()
    in the daemonize case.  (note the non-daemonized case still needs a
    check to enforce that it must NOT be called while threaded).  Add
    process_lock() at least across all open/close/socket() calls.
    
    Anything done after a fork() doesn't need the locks as it is no
    longer threaded - so some open/close/dups()s are not locked for
    that reason.  However, some common functions are called from both
    threaded and non-threaded contexts.  So after doing a fork(), do
    a possibly-extraneous process_unlock() to make sure that, if we
    were forked while pthread mutex was held, we aren't deadlocked by
    nobody.
    
    Tested that lp:~serge-hallyn/+junk/lxc-test still works with this
    patch.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Tested-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 79237df..d77ce37 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -100,12 +100,12 @@ int ongoing_create(struct lxc_container *c)
 
 	if (!file_exists(path))
 		return 0;
-	if (process_lock())
-		return -1;
-	if ((fd = open(path, O_RDWR)) < 0) {
+	process_lock();
+	fd = open(path, O_RDWR);
+	process_unlock();
+	if (fd < 0) {
 		// give benefit of the doubt
 		SYSERROR("Error opening partial file");
-		process_unlock();
 		return 0;
 	}
 	lk.l_type = F_WRLCK;
@@ -115,11 +115,13 @@ int ongoing_create(struct lxc_container *c)
 	lk.l_pid = -1;
 	if (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {
 		// create is still ongoing
+		process_lock();
 		close(fd);
 		process_unlock();
 		return 1;
 	}
 	// create completed but partial is still there.
+	process_lock();
 	close(fd);
 	process_unlock();
 	return 2;
@@ -138,8 +140,7 @@ int create_partial(struct lxc_container *c)
 		ERROR("Error writing partial pathname");
 		return -1;
 	}
-	if (process_lock())
-		return -1;
+	process_lock();
 	if ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {
 		SYSERROR("Erorr creating partial file");
 		process_unlock();
@@ -167,17 +168,16 @@ void remove_partial(struct lxc_container *c, int fd)
 	char *path = alloca(len);
 	int ret;
 
+	process_lock();
 	close(fd);
+	process_unlock();
 	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		ERROR("Error writing partial pathname");
 		return;
 	}
-	if (process_lock())
-		return;
 	if (unlink(path) < 0)
 		SYSERROR("Error unlink partial file %s", path);
-	process_unlock();
 }
 
 /* LOCKING
@@ -546,20 +546,15 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			return false;
 		lxc_monitord_spawn(c->config_path);
 
-		if (process_lock())
-			return false;
 		pid_t pid = fork();
 		if (pid < 0) {
 			lxc_container_put(c);
-			process_unlock();
 			return false;
 		}
-		if (pid != 0) {
-			ret = wait_on_daemonized_start(c);
-			process_unlock();
-			return ret;
-		}
-		process_unlock();
+		if (pid != 0)
+			return wait_on_daemonized_start(c);
+
+		process_unlock(); // we're no longer sharing
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {
@@ -778,6 +773,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 		int ret, len, nargs = 0;
 		char **newargv;
 
+		process_unlock(); // we're no longer sharing
 		if (quiet) {
 			close(0);
 			close(1);
@@ -880,56 +876,44 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	long flen;
 	char *contents;
 	FILE *f;
+	int ret = -1;
 #if HAVE_LIBGNUTLS
-	int i, ret;
+	int i;
 	unsigned char md_value[SHA_DIGEST_LENGTH];
 	char *tpath;
 	bool have_tpath = false;
 #endif
 
-	if ((f = fopen(path, "r")) == NULL) {
-		SYSERROR("Opening old config");
-		return false;
-	}
-	if (fseek(f, 0, SEEK_END) < 0) {
-		SYSERROR("Seeking to end of old config file");
-		fclose(f);
-		return false;
-	}
-	if ((flen = ftell(f)) < 0) {
-		SYSERROR("telling size of old config");
-		fclose(f);
-		return false;
-	}
-	if (fseek(f, 0, SEEK_SET) < 0) {
-		SYSERROR("rewinding old config");
-		fclose(f);
-		return false;
-	}
-	if ((contents = malloc(flen + 1)) == NULL) {
-		SYSERROR("out of memory");
-		fclose(f);
-		return false;
-	}
-	if (fread(contents, 1, flen, f) != flen) {
-		SYSERROR("Reading old config");
-		free(contents);
-		fclose(f);
+	process_lock();
+	f = fopen(path, "r");
+	process_unlock();
+	if (f == NULL)
 		return false;
-	}
+
+	if (fseek(f, 0, SEEK_END) < 0)
+		goto out_error;
+	if ((flen = ftell(f)) < 0)
+		goto out_error;
+	if (fseek(f, 0, SEEK_SET) < 0)
+		goto out_error;
+	if ((contents = malloc(flen + 1)) == NULL)
+		goto out_error;
+	if (fread(contents, 1, flen, f) != flen)
+		goto out_free_contents;
+
 	contents[flen] = '\0';
-	if (fclose(f) < 0) {
-		SYSERROR("closing old config");
-		free(contents);
-		return false;
-	}
+	process_lock();
+	ret = fclose(f);
+	process_unlock();
+	f = NULL;
+	if (ret < 0)
+		goto out_free_contents;
 
 #if HAVE_LIBGNUTLS
 	tpath = get_template_path(t);
 	if (tpath == (char *) -1) {
 		ERROR("bad template: %s\n", t);
-		free(contents);
-		return false;
+		goto out_free_contents;
 	}
 
 	if (tpath) {
@@ -937,14 +921,16 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		ret = sha1sum_file(tpath, md_value);
 		if (ret < 0) {
 			ERROR("Error getting sha1sum of %s", tpath);
-			free(contents);
-			return false;
+			goto out_free_contents;
 		}
 		free(tpath);
 	}
 #endif
 
-	if ((f = fopen(path, "w")) == NULL) {
+	process_lock();
+	f = fopen(path, "w");
+	process_unlock();
+	if (f == NULL) {
 		SYSERROR("reopening config for writing");
 		free(contents);
 		return false;
@@ -969,12 +955,25 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	if (fwrite(contents, 1, flen, f) != flen) {
 		SYSERROR("Writing original contents");
 		free(contents);
+		process_lock();
 		fclose(f);
+		process_unlock();
 		return false;
 	}
+	ret = 0;
+out_free_contents:
 	free(contents);
-	if (fclose(f) < 0) {
-		SYSERROR("Closing config file after write");
+out_error:
+	if (f) {
+		int newret;
+		process_lock();
+		newret = fclose(f);
+		process_unlock();
+		if (ret == 0)
+			ret = newret;
+	}
+	if (ret < 0) {
+		SYSERROR("Error prepending header");
 		return false;
 	}
 	return true;
@@ -1044,6 +1043,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (pid == 0) { // child
 		struct bdev *bdev = NULL;
 
+		process_unlock(); // we're no longer sharing
 		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
 			ERROR("Error creating backing store type %s for %s",
 				bdevtype ? bdevtype : "(none)", c->name);
@@ -1194,7 +1194,9 @@ char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, in
 		goto out;
 
 	/* Save reference to old netns */
+	process_lock();
 	old_netns = open("/proc/self/ns/net", O_RDONLY);
+	process_unlock();
 	if (old_netns < 0) {
 		SYSERROR("failed to open /proc/self/ns/net");
 		goto out;
@@ -1205,7 +1207,9 @@ char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, in
 	if (ret < 0 || ret >= MAXPATHLEN)
 		goto out;
 
+	process_lock();
 	new_netns = open(new_netns_path, O_RDONLY);
+	process_unlock();
 	if (new_netns < 0) {
 		SYSERROR("failed to open %s", new_netns_path);
 		goto out;
@@ -1268,10 +1272,12 @@ out:
 	/* Switch back to original netns */
 	if (old_netns >= 0 && setns(old_netns, CLONE_NEWNET))
 		SYSERROR("failed to setns");
+	process_lock();
 	if (new_netns >= 0)
 		close(new_netns);
 	if (old_netns >= 0)
 		close(old_netns);
+	process_unlock();
 
 	/* Append NULL to the array */
 	if (count) {
@@ -1390,25 +1396,36 @@ static bool mod_rdep(struct lxc_container *c, bool inc)
 			c->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
+	process_lock();
 	f = fopen(path, "r");
+	process_unlock();
 	if (f) {
 		ret = fscanf(f, "%d", &v);
+		process_lock();
 		fclose(f);
+		process_unlock();
 		if (ret != 1) {
 			ERROR("Corrupted file %s", path);
 			goto out;
 		}
 	}
 	v += inc ? 1 : -1;
+	process_lock();
 	f = fopen(path, "w");
+	process_unlock();
 	if (!f)
 		goto out;
 	if (fprintf(f, "%d\n", v) < 0) {
 		ERROR("Error writing new snapshots value");
+		process_lock();
 		fclose(f);
+		process_unlock();
 		goto out;
 	}
-	if (fclose(f) != 0) {
+	process_lock();
+	ret = fclose(f);
+	process_unlock();
+	if (ret != 0) {
 		SYSERROR("Error writing to or closing snapshots file");
 		goto out;
 	}
@@ -1443,7 +1460,10 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 		ERROR("Path name too long");
 		return;
 	}
-	if ((f = fopen(path, "r")) == NULL)
+	process_lock();
+	f = fopen(path, "r");
+	process_unlock();
+	if (f == NULL)
 		return;
 	while (getline(&lxcpath, &pathlen, f) != -1) {
 		if (getline(&lxcname, &namelen, f) == -1) {
@@ -1465,7 +1485,9 @@ static void mod_all_rdeps(struct lxc_container *c, bool inc)
 out:
 	if (lxcpath) free(lxcpath);
 	if (lxcname) free(lxcname);
+	process_lock();
 	fclose(f);
+	process_unlock();
 }
 
 static bool has_snapshots(struct lxc_container *c)
@@ -1479,11 +1501,15 @@ static bool has_snapshots(struct lxc_container *c)
 			c->name);
 	if (ret < 0 || ret > MAXPATHLEN)
 		goto out;
+	process_lock();
 	f = fopen(path, "r");
+	process_unlock();
 	if (!f)
 		goto out;
 	ret = fscanf(f, "%d", &v);
+	process_lock();
 	fclose(f);
+	process_unlock();
 	if (ret != 1)
 		goto out;
 	bret = v != 0;
@@ -1735,15 +1761,21 @@ static int copy_file(char *old, char *new)
 		return -1;
 	}
 
+	process_lock();
 	in = open(old, O_RDONLY);
+	process_unlock();
 	if (in < 0) {
 		SYSERROR("Error opening original file %s", old);
 		return -1;
 	}
+	process_lock();
 	out = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);
+	process_unlock();
 	if (out < 0) {
 		SYSERROR("Error opening new file %s", new);
+		process_lock();
 		close(in);
+		process_unlock();
 		return -1;
 	}
 
@@ -1761,8 +1793,10 @@ static int copy_file(char *old, char *new)
 			goto err;
 		}
 	}
+	process_lock();
 	close(in);
 	close(out);
+	process_unlock();
 
 	// we set mode, but not owner/group
 	ret = chmod(new, sbuf.st_mode);
@@ -1774,8 +1808,10 @@ static int copy_file(char *old, char *new)
 	return 0;
 
 err:
+	process_lock();
 	close(in);
 	close(out);
+	process_unlock();
 	return -1;
 }
 
@@ -1815,13 +1851,18 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 
 static void new_hwaddr(char *hwaddr)
 {
-	FILE *f = fopen("/dev/urandom", "r");
+	FILE *f;
+	process_lock();
+	f = fopen("/dev/urandom", "r");
+	process_unlock();
 	if (f) {
 		unsigned int seed;
 		int ret = fread(&seed, sizeof(seed), 1, f);
 		if (ret != 1)
 			seed = time(NULL);
+		process_lock();
 		fclose(f);
+		process_unlock();
 		srand(seed);
 	} else
 		srand(time(NULL));
@@ -1911,15 +1952,19 @@ static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)
 		c->name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		return false;
+	process_lock();
 	f = fopen(path, "a");
+	process_unlock();
 	if (!f)
 		return false;
 	bret = true;
 	// if anything goes wrong, just return an error
 	if (fprintf(f, "%s\n%s\n", c0->config_path, c0->name) < 0)
 		bret = false;
+	process_lock();
 	if (fclose(f) != 0)
 		bret = false;
+	process_unlock();
 	return bret;
 }
 
@@ -1976,6 +2021,7 @@ static int clone_update_rootfs(struct lxc_container *c0,
 	if (pid > 0)
 		return wait_for_pid(pid);
 
+	process_unlock(); // we're no longer sharing
 	if (unshare(CLONE_NEWNS) < 0) {
 		ERROR("error unsharing mounts");
 		exit(1);
@@ -2097,13 +2143,17 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	}
 
 	// copy the configuration, tweak it as needed,
+	process_lock();
 	fout = fopen(newpath, "w");
+	process_unlock();
 	if (!fout) {
 		SYSERROR("open %s", newpath);
 		goto out;
 	}
 	write_config(fout, c->lxc_conf);
+	process_lock();
 	fclose(fout);
+	process_unlock();
 
 	sprintf(newpath, "%s/%s/rootfs", l, n);
 	if (mkdir(newpath, 0755) < 0) {
@@ -2250,6 +2300,7 @@ static int lxcapi_snapshot(struct lxc_container *c, char *commentfile)
 	time_t timer;
 	char buffer[25];
 	struct tm* tm_info;
+	FILE *f;
 
 	time(&timer);
 	tm_info = localtime(&timer);
@@ -2258,7 +2309,9 @@ static int lxcapi_snapshot(struct lxc_container *c, char *commentfile)
 
 	char *dfnam = alloca(strlen(snappath) + strlen(newname) + 5);
 	sprintf(dfnam, "%s/%s/ts", snappath, newname);
-	FILE *f = fopen(dfnam, "w");
+	process_lock();
+	f = fopen(dfnam, "w");
+	process_unlock();
 	if (!f) {
 		ERROR("Failed to open %s\n", dfnam);
 		return -1;
@@ -2268,7 +2321,10 @@ static int lxcapi_snapshot(struct lxc_container *c, char *commentfile)
 		fclose(f);
 		return -1;
 	}
-	if (fclose(f) != 0) {
+	process_lock();
+	ret = fclose(f);
+	process_unlock();
+	if (ret != 0) {
 		SYSERROR("Writing timestamp");
 		return -1;
 	}
@@ -2321,7 +2377,10 @@ static char *get_timestamp(char* snappath, char *name)
 	ret = snprintf(path, MAXPATHLEN, "%s/%s/ts", snappath, name);
 	if (ret < 0 || ret >= MAXPATHLEN)
 		return NULL;
-	if ((fin = fopen(path, "r")) == NULL)
+	process_lock();
+	fin = fopen(path, "r");
+	process_unlock();
+	if (!fin)
 		return NULL;
 	(void) fseek(fin, 0, SEEK_END);
 	len = ftell(fin);
@@ -2337,7 +2396,9 @@ static char *get_timestamp(char* snappath, char *name)
 			}
 		}
 	}
+	process_lock();
 	fclose(fin);
+	process_unlock();
 	return s;
 }
 
@@ -2357,7 +2418,10 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 		ERROR("path name too long");
 		return -1;
 	}
-	if (!(dir = opendir(snappath))) {
+	process_lock();
+	dir = opendir(snappath);
+	process_unlock();
+	if (!dir) {
 		INFO("failed to open %s - assuming no snapshots", snappath);
 		return 0;
 	}
@@ -2399,8 +2463,10 @@ static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **r
 		count++;
 	}
 
+	process_lock();
 	if (closedir(dir))
 		WARN("failed to close directory");
+	process_unlock();
 
 	*ret_snaps = snaps;
 	return count;

commit 4575a9f939a21e31231b2341dab2bffc341adcbd
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sat Sep 14 13:09:53 2013 -0500

    Revert "api_create and api_start: work toward making them thread-safe"
    
    This should deadlock with daemonized start due to af_unix changes.
    
    Do this later, but do it more carefully.
    
    This reverts commit 002f3cff4d83c0666cfda40599eded8e0d638c6c.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3c51c4a..79237df 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -665,9 +665,7 @@ static bool create_container_dir(struct lxc_container *c)
 		free(s);
 		return false;
 	}
-	process_lock();
 	ret = mkdir(s, 0755);
-	process_unlock();
 	if (ret) {
 		if (errno == EEXIST)
 			ret = 0;
@@ -1364,15 +1362,11 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	if (lret)
 		return false;
 
-	process_lock();
 	fout = fopen(alt_file, "w");
-	process_unlock();
 	if (!fout)
 		goto out;
 	write_config(fout, c->lxc_conf);
-	process_lock();
 	fclose(fout);
-	process_unlock();
 	ret = true;
 
 out:

commit 002f3cff4d83c0666cfda40599eded8e0d638c6c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 13 21:19:42 2013 -0500

    api_create and api_start: work toward making them thread-safe
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 79237df..3c51c4a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -665,7 +665,9 @@ static bool create_container_dir(struct lxc_container *c)
 		free(s);
 		return false;
 	}
+	process_lock();
 	ret = mkdir(s, 0755);
+	process_unlock();
 	if (ret) {
 		if (errno == EEXIST)
 			ret = 0;
@@ -1362,11 +1364,15 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	if (lret)
 		return false;
 
+	process_lock();
 	fout = fopen(alt_file, "w");
+	process_unlock();
 	if (!fout)
 		goto out;
 	write_config(fout, c->lxc_conf);
+	process_lock();
 	fclose(fout);
+	process_unlock();
 	ret = true;
 
 out:

commit 33ad9f1ab13de51d28aecbcbdac086ea009a1740
Author: Christian Seiler <christian@iwakd.de>
Date:   Sun Sep 8 20:50:03 2013 +0200

    cgroup: Major rewrite of cgroup logic
    
    This patch rewrites most of the cgroup logic. It creates a set of data
    structures to store the kernel state of the cgroup hierarchies and
    their mountpoints.
    
    Mainly, everything is now grouped with respect to the hierarchies of
    the system. Multiple controllers may be mounted together or separately
    to different hierarchies, the data structures reflect this.
    
    Each hierarchy may have multiple mount points (that were created
    previously using the bind mount method) and each of these mount points
    may point to a different prefix inside the cgroup tree. The current
    code does not make any assumptions regarding the mount points, it just
    parses /proc/self/mountinfo to acquire the relevant information.
    
    The only requirement is that the current cgroup of either init (if
    cgroup.pattern starts with '/' and the tools are executed as root) or
    the current process (otherwise) are accessible. The root cgroup need
    not be accessible.
    
    The configuration option cgroup.pattern is introduced. For
    root-executed containers, it specifies which format the cgroups should
    be in. Example values may include '/lxc/%n', 'lxc/%n', '%n' or
    '/machine/%n.lxc'. Any occurrence of '%n' is replaced with the name of
    the container (and if clashes occur in any hierarchy, -1, -2, etc. are
    appended globally). If the pattern starts with /, new containers'
    cgroups will be located relative to init's cgroup; if it doesn't, they
    will be located relative to the current process's cgroup.
    
    Some changes to the cgroup.h API have been done to make it more
    consistent, both with respect to naming and with respect to the
    parameters. This causes some changes in other parts of the code that
    are included in the patch.
    
    There has been some testing of this functionality, but there are
    probably still quite a few bugs in there, especially for people with
    different configurations.
    
    Signed-off-by: Christian Seiler <christian@iwakd.de>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 635c17e..79237df 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1673,7 +1673,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (container_disk_lock(c))
 		return false;
 
-	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
+	ret = lxc_cgroup_set(subsys, value, c->name, c->config_path);
 
 	container_disk_unlock(c);
 	return ret == 0;
@@ -1692,7 +1692,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	if (container_disk_lock(c))
 		return -1;
 
-	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);
+	ret = lxc_cgroup_get(subsys, retv, inlen, c->name, c->config_path);
 
 	container_disk_unlock(c);
 	return ret;

commit f5dd1d532a76a1b57cf341db821eae85ea1118c5
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 6 18:07:47 2013 -0500

    API support for container snapshots (v2)
    
    The api allows for creating, listing, and restoring of container
    snapshots.  Snapshots are created as snapshot clones of the
    original container - i.e. btrfs and lvm will be done as snapshot,
    a directory-backed container will have overlayfs snapshots.  A
    restore is a copy-clone, using the same backing store as the
    original container had.
    
    Changelog:
    
     . remove lxcapi_snap_open, which wasn't defined anyway.
     . rename get_comment to get_commentpath
     . if no newname is specified at restore, use c->name (as we meant to)
       rather than segving.
     . when choosing a snapshot index, use the correct path to check for.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3c657ca..635c17e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -27,6 +27,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sched.h>
+#include <dirent.h>
 #include "config.h"
 #include "lxc.h"
 #include "state.h"
@@ -68,6 +69,13 @@ static bool file_exists(char *f)
 	return stat(f, &statbuf) == 0;
 }
 
+static void remove_trailing_slashes(char *p)
+{
+	int l = strlen(p);
+	while (--l >= 0 && (p[l] == '/' || p[l] == '\n'))
+		p[l] = '\0';
+}
+
 /*
  * A few functions to help detect when a container creation failed.
  * If a container creation was killed partway through, then trying
@@ -2192,6 +2200,272 @@ static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t
 	return lxc_wait_for_pid_status(pid);
 }
 
+int get_next_index(const char *lxcpath, char *cname)
+{
+	char *fname;
+	struct stat sb;
+	int i = 0, ret;
+
+	fname = alloca(strlen(lxcpath) + 20);
+	while (1) {
+		sprintf(fname, "%s/snap%d", lxcpath, i);
+		ret = stat(fname, &sb);
+		if (ret != 0)
+			return i;
+		i++;
+	}
+}
+
+static int lxcapi_snapshot(struct lxc_container *c, char *commentfile)
+{
+	int i, flags, ret;
+	struct lxc_container *c2;
+	char snappath[MAXPATHLEN], newname[20];
+
+	// /var/lib/lxc -> /var/lib/lxcsnaps \0
+	ret = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return -1;
+	i = get_next_index(snappath, c->name);
+
+	if (mkdir_p(snappath, 0755) < 0) {
+		ERROR("Failed to create snapshot directory %s", snappath);
+		return -1;
+	}
+
+	ret = snprintf(newname, 20, "snap%d", i);
+	if (ret < 0 || ret >= 20)
+		return -1;
+
+	flags = LXC_CLONE_SNAPSHOT | LXC_CLONE_KEEPMACADDR | LXC_CLONE_KEEPNAME;
+	c2 = c->clone(c, newname, snappath, flags, NULL, NULL, 0, NULL);
+	if (!c2) {
+		ERROR("clone of %s:%s failed\n", c->config_path, c->name);
+		return -1;
+	}
+
+	lxc_container_put(c2);
+
+	// Now write down the creation time
+	time_t timer;
+	char buffer[25];
+	struct tm* tm_info;
+
+	time(&timer);
+	tm_info = localtime(&timer);
+
+	strftime(buffer, 25, "%Y:%m:%d %H:%M:%S", tm_info);
+
+	char *dfnam = alloca(strlen(snappath) + strlen(newname) + 5);
+	sprintf(dfnam, "%s/%s/ts", snappath, newname);
+	FILE *f = fopen(dfnam, "w");
+	if (!f) {
+		ERROR("Failed to open %s\n", dfnam);
+		return -1;
+	}
+	if (fprintf(f, "%s", buffer) < 0) {
+		SYSERROR("Writing timestamp");
+		fclose(f);
+		return -1;
+	}
+	if (fclose(f) != 0) {
+		SYSERROR("Writing timestamp");
+		return -1;
+	}
+
+	if (commentfile) {
+		// $p / $name / comment \0
+		int len = strlen(snappath) + strlen(newname) + 10;
+		char *path = alloca(len);
+		sprintf(path, "%s/%s/comment", snappath, newname);
+		return copy_file(commentfile, path) < 0 ? -1 : i;
+	}
+
+	return i;
+}
+
+static void lxcsnap_free(struct lxc_snapshot *s)
+{
+	if (s->name)
+		free(s->name);
+	if (s->comment_pathname)
+		free(s->comment_pathname);
+	if (s->timestamp)
+		free(s->timestamp);
+	if (s->lxcpath)
+		free(s->lxcpath);
+}
+
+static char *get_snapcomment_path(char* snappath, char *name)
+{
+	// $snappath/$name/comment
+	int ret, len = strlen(snappath) + strlen(name) + 10;
+	char *s = malloc(len);
+
+	if (s) {
+		ret = snprintf(s, len, "%s/%s/comment", snappath, name);
+		if (ret < 0 || ret >= len) {
+			free(s);
+			s = NULL;
+		}
+	}
+	return s;
+}
+
+static char *get_timestamp(char* snappath, char *name)
+{
+	char path[MAXPATHLEN], *s = NULL;
+	int ret, len;
+	FILE *fin;
+
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/ts", snappath, name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return NULL;
+	if ((fin = fopen(path, "r")) == NULL)
+		return NULL;
+	(void) fseek(fin, 0, SEEK_END);
+	len = ftell(fin);
+	(void) fseek(fin, 0, SEEK_SET);
+	if (len > 0) {
+		s = malloc(len+1);
+		if (s) {
+			s[len] = '\0';
+			if (fread(s, 1, len, fin) != len) {
+				SYSERROR("reading timestamp");
+				free(s);
+				s = NULL;
+			}
+		}
+	}
+	fclose(fin);
+	return s;
+}
+
+static int lxcapi_snapshot_list(struct lxc_container *c, struct lxc_snapshot **ret_snaps)
+{
+	char snappath[MAXPATHLEN], path2[MAXPATHLEN];
+	int dirlen, count = 0, ret;
+	struct dirent dirent, *direntp;
+	struct lxc_snapshot *snaps =NULL, *nsnaps;
+	DIR *dir;
+
+	if (!c || !lxcapi_is_defined(c))
+		return -1;
+	// snappath is ${lxcpath}snaps/${lxcname}/
+	dirlen = snprintf(snappath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (dirlen < 0 || dirlen >= MAXPATHLEN) {
+		ERROR("path name too long");
+		return -1;
+	}
+	if (!(dir = opendir(snappath))) {
+		INFO("failed to open %s - assuming no snapshots", snappath);
+		return 0;
+	}
+
+	while (!readdir_r(dir, &dirent, &direntp)) {
+		if (!direntp)
+			break;
+
+		if (!strcmp(direntp->d_name, "."))
+			continue;
+
+		if (!strcmp(direntp->d_name, ".."))
+			continue;
+
+		ret = snprintf(path2, MAXPATHLEN, "%s/%s/config", snappath, direntp->d_name);
+		if (ret < 0 || ret >= MAXPATHLEN) {
+			ERROR("pathname too long");
+			goto out_free;
+		}
+		if (!file_exists(path2))
+			continue;
+		nsnaps = realloc(snaps, (count + 1)*sizeof(*snaps));
+		if (!nsnaps) {
+			SYSERROR("Out of memory");
+			goto out_free;
+		}
+		snaps = nsnaps;
+		snaps[count].free = lxcsnap_free;
+		snaps[count].name = strdup(direntp->d_name);
+		if (!snaps[count].name)
+			goto out_free;
+		snaps[count].lxcpath = strdup(snappath);
+		if (!snaps[count].lxcpath) {
+			free(snaps[count].name);
+			goto out_free;
+		}
+		snaps[count].comment_pathname = get_snapcomment_path(snappath, direntp->d_name);
+		snaps[count].timestamp = get_timestamp(snappath, direntp->d_name);
+		count++;
+	}
+
+	if (closedir(dir))
+		WARN("failed to close directory");
+
+	*ret_snaps = snaps;
+	return count;
+
+out_free:
+	if (snaps) {
+		int i;
+		for (i=0; i<count; i++)
+			lxcsnap_free(&snaps[i]);
+		free(snaps);
+	}
+	return -1;
+}
+
+static bool lxcapi_snapshot_restore(struct lxc_container *c, char *snapname, char *newname)
+{
+	char clonelxcpath[MAXPATHLEN];
+	int ret;
+	struct lxc_container *snap, *rest;
+	struct bdev *bdev;
+	bool b = false;
+
+	if (!c || !c->name || !c->config_path)
+		return false;
+
+	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	if (!bdev) {
+		ERROR("Failed to find original backing store type");
+		return false;
+	}
+
+	if (!newname)
+		newname = c->name;
+	if (strcmp(c->name, newname) == 0) {
+		if (!lxcapi_destroy(c)) {
+			ERROR("Could not destroy existing container %s", newname);
+			bdev_put(bdev);
+			return false;
+		}
+	}
+	ret = snprintf(clonelxcpath, MAXPATHLEN, "%ssnaps/%s", c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN) {
+		bdev_put(bdev);
+		return false;
+	}
+	// how should we lock this?
+
+	snap = lxc_container_new(snapname, clonelxcpath);
+	if (!snap || !lxcapi_is_defined(snap)) {
+		ERROR("Could not open snapshot %s", snapname);
+		if (snap) lxc_container_put(snap);
+		bdev_put(bdev);
+		return false;
+	}
+
+	rest = lxcapi_clone(snap, newname, c->config_path, 0, bdev->type, NULL, 0, NULL);
+	bdev_put(bdev);
+	if (rest && lxcapi_is_defined(rest))
+		b = true;
+	if (rest)
+		lxc_container_put(rest);
+	lxc_container_put(snap);
+	return b;
+}
+
 static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
 {
 	va_list ap;
@@ -2237,6 +2511,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 		goto err;
 	}
 
+	remove_trailing_slashes(c->config_path);
 	c->name = malloc(strlen(name)+1);
 	if (!c->name) {
 		fprintf(stderr, "Error allocating lxc_container name\n");
@@ -2305,6 +2580,9 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->attach = lxcapi_attach;
 	c->attach_run_wait = lxcapi_attach_run_wait;
 	c->attach_run_waitl = lxcapi_attach_run_waitl;
+	c->snapshot = lxcapi_snapshot;
+	c->snapshot_list = lxcapi_snapshot_list;
+	c->snapshot_restore = lxcapi_snapshot_restore;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit eee59f9408398849e9b7fc58dbe68ec176de4d50
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Sep 5 18:05:34 2013 -0500

    clone: don't copy rdepends when not doing a snapshot clone
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5069f3e..3c657ca 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1935,7 +1935,8 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		ERROR("Out of memory while setting storage path");
 		return -1;
 	}
-	copy_rdepends(c, c0);
+	if (flags & LXC_CLONE_SNAPSHOT)
+		copy_rdepends(c, c0);
 	if (need_rdep) {
 		if (!add_rdepends(c, c0))
 			WARN("Error adding reverse dependency from %s to %s",

commit 2a2d36a42512160e7771b2472cb7922423523048
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Sep 5 17:59:28 2013 -0500

    fix typo
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a1a567b..5069f3e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1503,7 +1503,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	}
 
 	if (c->lxc_conf && has_snapshots(c)) {
-		ERROR("conatiner %s has dependent snapshots", c->name);
+		ERROR("container %s has dependent snapshots", c->name);
 		goto out;
 	}
 

commit 59d66af29da6ca8c5fa8cb63a5bbfc443811bb81
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Sep 5 16:56:54 2013 -0500

    bdev: free after bdev_init
    
    (Except in cases where we will immediately exit)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f4d1f8e..a1a567b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1511,9 +1511,11 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (r) {
 		if (r->ops->destroy(r) < 0) {
+			bdev_put(r);
 			ERROR("Error destroying rootfs for %s", c->name);
 			goto out;
 		}
+		bdev_put(r);
 	}
 
 	mod_all_rdeps(c, false);

commit d75462e4d663c58bde0787fdbe0ef3148e44cdde
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Aug 30 14:42:20 2013 -0500

    fix wrong license text for parts of liblxc library
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7172c00..f4d1f8e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -3,18 +3,19 @@
  * Copyright  2012 Serge Hallyn <serge.hallyn@ubuntu.com>.
  * Copyright  2012 Canonical Ltd.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2, as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 #define _GNU_SOURCE

commit dfb31b25e298d98ea80a699f019308019c6670d8
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Aug 21 14:43:52 2013 -0500

    Track snapshot dependencies (v2)
    
    (Will push in a bit barring any objections)
    
    lvm, btrfs, and zfs snapshots each do an ok job of handling deletions
    for us - a btrfs snapshot does fine after the original is removed,
    while zfs and lvm will both refuse to allow the original to be deleted
    while the snapshot exists.
    
    Overlayfs doesn't do this for us.  So, for overlayfs snapshots, track
    the dependencies.
    
    When c2 is created as an overlayfs snapshot of dir-backed c1, then
    
    1. c2's lxc_rdepends file will contain
    
    	c1_lxcpath
    	c1_lxcname
    
    2. c1's lxc_snapshots will contain "1"
    
    c1 cannot be deleted so long as lxc_snapshots exists and contains
    a non-zero number.
    
    The contents of lxc_snapshots and lxc_rdepends are protected by
    container_disk_lock() and at lxc_clone by the new container not yet
    being accessible.
    
    (Originally I was going to keep them in the container config, but the
    problem with using $lxcpath/$name/config is that api users could end up
    calling c->save_config() with a cached old value of snapshots/rdepends.)
    
    Changelog:
    	aug 21: check for fprintf and fclose failures
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index facf9a7..7172c00 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -52,6 +52,12 @@
 #include <../include/ifaddrs.h>
 #endif
 
+#ifndef HAVE_GETLINE
+#ifdef HAVE_FGETLN
+#include <../include/getline.h>
+#endif
+#endif
+
 lxc_log_define(lxc_container, lxc);
 
 static bool file_exists(char *f)
@@ -1362,6 +1368,121 @@ out:
 	return ret;
 }
 
+static bool mod_rdep(struct lxc_container *c, bool inc)
+{
+	char path[MAXPATHLEN];
+	int ret, v = 0;
+	FILE *f;
+	bool bret = false;
+
+	if (container_disk_lock(c))
+		return false;
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_snapshots", c->config_path,
+			c->name);
+	if (ret < 0 || ret > MAXPATHLEN)
+		goto out;
+	f = fopen(path, "r");
+	if (f) {
+		ret = fscanf(f, "%d", &v);
+		fclose(f);
+		if (ret != 1) {
+			ERROR("Corrupted file %s", path);
+			goto out;
+		}
+	}
+	v += inc ? 1 : -1;
+	f = fopen(path, "w");
+	if (!f)
+		goto out;
+	if (fprintf(f, "%d\n", v) < 0) {
+		ERROR("Error writing new snapshots value");
+		fclose(f);
+		goto out;
+	}
+	if (fclose(f) != 0) {
+		SYSERROR("Error writing to or closing snapshots file");
+		goto out;
+	}
+
+	bret = true;
+
+out:
+	container_disk_unlock(c);
+	return bret;
+}
+
+static void strip_newline(char *p)
+{
+	size_t len = strlen(p);
+	if (len < 1)
+		return;
+	if (p[len-1] == '\n')
+		p[len-1] = '\0';
+}
+
+static void mod_all_rdeps(struct lxc_container *c, bool inc)
+{
+	struct lxc_container *p;
+	char *lxcpath = NULL, *lxcname = NULL, path[MAXPATHLEN];
+	size_t pathlen = 0, namelen = 0;
+	FILE *f;
+	int ret;
+
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_rdepends",
+		c->config_path, c->name);
+	if (ret < 0 || ret >= MAXPATHLEN) {
+		ERROR("Path name too long");
+		return;
+	}
+	if ((f = fopen(path, "r")) == NULL)
+		return;
+	while (getline(&lxcpath, &pathlen, f) != -1) {
+		if (getline(&lxcname, &namelen, f) == -1) {
+			ERROR("badly formatted file %s\n", path);
+			goto out;
+		}
+		strip_newline(lxcpath);
+		strip_newline(lxcname);
+		if ((p = lxc_container_new(lxcname, lxcpath)) == NULL) {
+			ERROR("Unable to find dependent container %s:%s",
+				lxcpath, lxcname);
+			continue;
+		}
+		if (!mod_rdep(p, inc))
+			ERROR("Failed to increase numsnapshots for %s:%s",
+				lxcpath, lxcname);
+		lxc_container_put(p);
+	}
+out:
+	if (lxcpath) free(lxcpath);
+	if (lxcname) free(lxcname);
+	fclose(f);
+}
+
+static bool has_snapshots(struct lxc_container *c)
+{
+	char path[MAXPATHLEN];
+	int ret, v;
+	FILE *f;
+	bool bret = false;
+
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_snapshots", c->config_path,
+			c->name);
+	if (ret < 0 || ret > MAXPATHLEN)
+		goto out;
+	f = fopen(path, "r");
+	if (!f)
+		goto out;
+	ret = fscanf(f, "%d", &v);
+	fclose(f);
+	if (ret != 1)
+		goto out;
+	bret = v != 0;
+
+out:
+	return bret;
+}
+
 // do we want the api to support --force, or leave that to the caller?
 static bool lxcapi_destroy(struct lxc_container *c)
 {
@@ -1380,6 +1501,11 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
+	if (c->lxc_conf && has_snapshots(c)) {
+		ERROR("conatiner %s has dependent snapshots", c->name);
+		goto out;
+	}
+
 	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount)
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (r) {
@@ -1389,6 +1515,8 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		}
 	}
 
+	mod_all_rdeps(c, false);
+
 	const char *p1 = lxcapi_get_config_path(c);
 	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
 	sprintf(path, "%s/%s", p1, c->name);
@@ -1592,18 +1720,18 @@ static int copy_file(char *old, char *new)
 	}
 	ret = stat(old, &sbuf);
 	if (ret < 0) {
-		SYSERROR("stat'ing %s", old);
+		INFO("Error stat'ing %s", old);
 		return -1;
 	}
 
 	in = open(old, O_RDONLY);
 	if (in < 0) {
-		SYSERROR("opening original file %s", old);
+		SYSERROR("Error opening original file %s", old);
 		return -1;
 	}
 	out = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);
 	if (out < 0) {
-		SYSERROR("opening new file %s", new);
+		SYSERROR("Error opening new file %s", new);
 		close(in);
 		return -1;
 	}
@@ -1611,14 +1739,14 @@ static int copy_file(char *old, char *new)
 	while (1) {
 		len = read(in, buf, 8096);
 		if (len < 0) {
-			SYSERROR("reading old file %s", old);
+			SYSERROR("Error reading old file %s", old);
 			goto err;
 		}
 		if (len == 0)
 			break;
 		ret = write(out, buf, len);
 		if (ret < len) {  // should we retry?
-			SYSERROR("write to new file %s was interrupted", new);
+			SYSERROR("Error: write to new file %s was interrupted", new);
 			goto err;
 		}
 	}
@@ -1628,7 +1756,7 @@ static int copy_file(char *old, char *new)
 	// we set mode, but not owner/group
 	ret = chmod(new, sbuf.st_mode);
 	if (ret) {
-		SYSERROR("setting mode on %s", new);
+		SYSERROR("Error setting mode on %s", new);
 		return -1;
 	}
 
@@ -1738,28 +1866,81 @@ static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
 	return 0;
 }
 
+static void copy_rdepends(struct lxc_container *c, struct lxc_container *c0)
+{
+	char path0[MAXPATHLEN], path1[MAXPATHLEN];
+	int ret;
+
+	ret = snprintf(path0, MAXPATHLEN, "%s/%s/lxc_rdepends", c0->config_path,
+		c0->name);
+	if (ret < 0 || ret >= MAXPATHLEN) {
+		WARN("Error copying reverse dependencies");
+		return;
+	}
+	ret = snprintf(path1, MAXPATHLEN, "%s/%s/lxc_rdepends", c->config_path,
+		c->name);
+	if (ret < 0 || ret >= MAXPATHLEN) {
+		WARN("Error copying reverse dependencies");
+		return;
+	}
+	if (copy_file(path0, path1) < 0) {
+		INFO("Error copying reverse dependencies");
+		return;
+	}
+}
+
+static bool add_rdepends(struct lxc_container *c, struct lxc_container *c0)
+{
+	int ret;
+	char path[MAXPATHLEN];
+	FILE *f;
+	bool bret;
+
+	ret = snprintf(path, MAXPATHLEN, "%s/%s/lxc_rdepends", c->config_path,
+		c->name);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		return false;
+	f = fopen(path, "a");
+	if (!f)
+		return false;
+	bret = true;
+	// if anything goes wrong, just return an error
+	if (fprintf(f, "%s\n%s\n", c0->config_path, c0->name) < 0)
+		bret = false;
+	if (fclose(f) != 0)
+		bret = false;
+	return bret;
+}
+
 static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 		const char *newtype, int flags, const char *bdevdata, unsigned long newsize)
 {
 	struct bdev *bdev;
+	int need_rdep;
 
 	bdev = bdev_copy(c0->lxc_conf->rootfs.path, c0->name, c->name,
 			c0->config_path, c->config_path, newtype, !!(flags & LXC_CLONE_SNAPSHOT),
-			bdevdata, newsize);
+			bdevdata, newsize, &need_rdep);
 	if (!bdev) {
-		ERROR("error copying storage");
+		ERROR("Error copying storage");
 		return -1;
 	}
 	free(c->lxc_conf->rootfs.path);
 	c->lxc_conf->rootfs.path = strdup(bdev->src);
 	bdev_put(bdev);
-	if (!c->lxc_conf->rootfs.path)
+	if (!c->lxc_conf->rootfs.path) {
+		ERROR("Out of memory while setting storage path");
 		return -1;
-	// here we could also update all lxc.mount.entries or even
-	// items in the lxc.mount fstab list.  As discussed on m-l,
-	// we could do either any source paths starting with the
-	// lxcpath/oldname, or simply anythign which is not a virtual
-	// fs or a bind mount.
+	}
+	copy_rdepends(c, c0);
+	if (need_rdep) {
+		if (!add_rdepends(c, c0))
+			WARN("Error adding reverse dependency from %s to %s",
+				c->name, c0->name);
+	}
+
+	mod_all_rdeps(c, true);
+
 	return 0;
 }
 

commit a09295f841be8add0cbfc2932c59535f0d1365ed
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Aug 20 17:54:19 2013 -0500

    coverity: don't leak partial_fd
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f3efb00..facf9a7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1046,14 +1046,14 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		exit(0);
 	}
 	if (wait_for_pid(pid) != 0)
-		goto out;
+		goto out_unlock;
 
 	/* reload config to get the rootfs */
 	if (c->lxc_conf)
 		lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
 	if (!load_config_locked(c, c->configfile))
-		goto out;
+		goto out_unlock;
 
 	if (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))
 		goto out_unlock;

commit 01efd4d3d91713fc4f8ca55c7726b8216ed16fc6
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Aug 20 16:58:24 2013 -0500

    coverity: correctly handle tpath error case.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c68dc6e..f3efb00 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -910,7 +910,8 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 	}
 
 #if HAVE_LIBGNUTLS
-	if ((tpath = get_template_path(t)) < 0) {
+	tpath = get_template_path(t);
+	if (tpath == (char *) -1) {
 		ERROR("bad template: %s\n", t);
 		free(contents);
 		return false;
@@ -991,7 +992,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (!c)
 		return false;
 
-	if ((tpath = get_template_path(t)) < 0) {
+	tpath = get_template_path(t);
+	if (tpath == (char *) -1) {
 		ERROR("bad template: %s\n", t);
 		goto out;
 	}

commit 1fd9bd50ab0ccea0a6c069147a4bccb0751ca18f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Aug 20 16:50:25 2013 -0500

    coverity: ftell returns long, not size_t (which is unsigned)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7a0f657..c68dc6e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -862,7 +862,7 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 
 bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 {
-	size_t flen;
+	long flen;
 	char *contents;
 	FILE *f;
 #if HAVE_LIBGNUTLS

commit b4569e93217fe9a18af35b4475c8f8eac1436759
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Aug 20 16:29:29 2013 -0500

    coverity: don't bother getting template path if we're not going to measure it
    
    This should also fix a memory leak, since we were freeing it under ifdef
    but always allocating it.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 39789fd..7a0f657 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -863,11 +863,12 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 {
 	size_t flen;
-	char *contents, *tpath;
+	char *contents;
 	FILE *f;
 #if HAVE_LIBGNUTLS
 	int i, ret;
 	unsigned char md_value[SHA_DIGEST_LENGTH];
+	char *tpath;
 	bool have_tpath = false;
 #endif
 
@@ -908,13 +909,13 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 		return false;
 	}
 
+#if HAVE_LIBGNUTLS
 	if ((tpath = get_template_path(t)) < 0) {
 		ERROR("bad template: %s\n", t);
 		free(contents);
 		return false;
 	}
 
-#if HAVE_LIBGNUTLS
 	if (tpath) {
 		have_tpath = true;
 		ret = sha1sum_file(tpath, md_value);

commit e768f9c0f69df1f02f8252fead6d82648b410bd8
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Aug 16 16:42:39 2013 +0200

    Add missing namespace.h include
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a64babe..39789fd 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -42,6 +42,7 @@
 #include "attach.h"
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
+#include <lxc/namespace.h>
 #include <sched.h>
 #include <arpa/inet.h>
 

commit c32981c3fb1bf5191052fb1c348bdc8b9e7c1b15
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Aug 16 11:53:11 2013 +0200

    Replace all calls to rindex by strrchr
    
    The two functions are identical but strrchr also works on Bionic.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6cf3da6..a64babe 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1645,7 +1645,7 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 	for (i=0; i<NUM_LXC_HOOKS; i++) {
 		lxc_list_for_each(it, &c->lxc_conf->hooks[i]) {
 			char *hookname = it->elem;
-			char *fname = rindex(hookname, '/');
+			char *fname = strrchr(hookname, '/');
 			char tmppath[MAXPATHLEN];
 			if (!fname) // relative path - we don't support, but maybe we should
 				return 0;
@@ -1706,7 +1706,7 @@ static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
 	if (!oldpath)
 		return 0;
 
-	char *p = rindex(oldpath, '/');
+	char *p = strrchr(oldpath, '/');
 	if (!p)
 		return -1;
 	ret = snprintf(newpath, MAXPATHLEN, "%s/%s%s",
@@ -1845,7 +1845,7 @@ only rootfs gets converted (copied/snapshotted) on clone.
 
 static int create_file_dirname(char *path)
 {
-	char *p = rindex(path, '/');
+	char *p = strrchr(path, '/');
 	int ret;
 
 	if (!p)

commit 4ba0d9af63fbf7e9acfa068a1fe36b3d287b9c6b
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Aug 16 11:47:10 2013 +0200

    Add a local implementation of ifaddrs.h
    
    This adds a local ifaddrs implementation to be used on Bionic or other C
    libraries that don't come with a getifaddrs implementation.
    
    This code was written by Kenneth MacKay and is under a two-clause BSD
    license (copyright information in the file headers).
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 02e3766..6cf3da6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -44,7 +44,12 @@
 #include <lxc/monitor.h>
 #include <sched.h>
 #include <arpa/inet.h>
+
+#if HAVE_IFADDRS_H
 #include <ifaddrs.h>
+#else
+#include <../include/ifaddrs.h>
+#endif
 
 lxc_log_define(lxc_container, lxc);
 

commit d44e88c26690a56f9efac58f602dba06c9ec0c90
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Aug 15 12:55:50 2013 -0500

    bdev: support -B best and -B lvm,dir
    
    -B dev will check whether btrfs, zfs, or lvm can be used,
    in that order, and fall back to dir.
    
    -B lvm,btrfs will try lvm first, then btrfs, then fail.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1c77b63..02e3766 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -679,8 +679,11 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 		return NULL;
 
 	bdev = bdev_create(dest, type, c->name, specs);
-	if (!bdev)
+	if (!bdev) {
+		ERROR("Failed to create backing store type %s\n", type);
 		return NULL;
+	}
+
 	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
 	return bdev;
 }

commit a0e93eeb2293e15a18e6c56271d13907f082c4df
Author: Christian Seiler <christian@iwakd.de>
Date:   Tue May 21 14:57:06 2013 +0200

    Add attach support to container C API
    
    Signed-off-by: Christian Seiler <christian@iwakd.de>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3affe22..1c77b63 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -18,6 +18,7 @@
  */
 
 #define _GNU_SOURCE
+#include <stdarg.h>
 #include <pthread.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -38,6 +39,7 @@
 #include "log.h"
 #include "bdev.h"
 #include "utils.h"
+#include "attach.h"
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
 #include <sched.h>
@@ -583,51 +585,30 @@ reboot:
 static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 {
 	va_list ap;
-	char **inargs = NULL, **temp;
-	int n_inargs = 0;
+	char **inargs = NULL;
 	bool bret = false;
 
 	/* container exists */
 	if (!c)
 		return false;
 
-	/* build array of arguments if any */
 	va_start(ap, useinit);
-	while (1) {
-		char *arg;
-		arg = va_arg(ap, char *);
-		if (!arg)
-			break;
-		n_inargs++;
-		temp = realloc(inargs, n_inargs * sizeof(*inargs));
-		if (!temp) {
-			va_end(ap);
-			goto out;
-		}
-		inargs = temp;
-		inargs[n_inargs - 1] = strdup(arg);  // not sure if it's safe not to copy
-	}
+	inargs = lxc_va_arg_list_to_argv(ap, 0, 1);
 	va_end(ap);
 
-	/* add trailing NULL */
-	if (n_inargs) {
-		n_inargs++;
-		temp = realloc(inargs, n_inargs * sizeof(*inargs));
-		if (!temp)
-			goto out;
-		inargs = temp;
-		inargs[n_inargs - 1] = NULL;
+	if (!inargs) {
+		ERROR("Memory allocation error.");
+		goto out;
 	}
 
-	bret = lxcapi_start(c, useinit, inargs);
+	/* pass NULL if no arguments were supplied */
+	bret = lxcapi_start(c, useinit, *inargs ? inargs : NULL);
 
 out:
 	if (inargs) {
-		int i;
-		for (i = 0; i < n_inargs; i++) {
-			if (inargs[i])
-				free(inargs[i]);
-		}
+		char *arg;
+		for (arg = *inargs; arg; arg++)
+			free(arg);
 		free(inargs);
 	}
 
@@ -1133,9 +1114,8 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 		const char *bdevtype, struct bdev_specs *specs, int flags, ...)
 {
 	bool bret = false;
-	char **args = NULL, **temp;
+	char **args = NULL;
 	va_list ap;
-	int nargs = 0;
 
 	if (!c)
 		return false;
@@ -1145,29 +1125,17 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	 * need to get a copy of the arguments.
 	 */
 	va_start(ap, flags);
-	while (1) {
-		char *arg;
-		arg = va_arg(ap, char *);
-		if (!arg)
-			break;
-		nargs++;
-		temp = realloc(args, (nargs+1) * sizeof(*args));
-		if (!temp) {
-			va_end(ap);
-			goto out;
-		}
-		args = temp;
-		args[nargs - 1] = arg;
-	}
+	args = lxc_va_arg_list_to_argv(ap, 0, 0);
 	va_end(ap);
-	if (args)
-		args[nargs] = NULL;
+	if (!args) {
+		ERROR("Memory allocation error.");
+		goto out;
+	}
 
 	bret = c->create(c, t, bdevtype, specs, flags, args);
 
 out:
-	if (args)
-		free(args);
+	free(args);
 	return bret;
 }
 
@@ -2000,6 +1968,57 @@ out:
 	return NULL;
 }
 
+static int lxcapi_attach(struct lxc_container *c, lxc_attach_exec_t exec_function, void *exec_payload, lxc_attach_options_t *options, pid_t *attached_process)
+{
+	if (!c)
+		return -1;
+
+	return lxc_attach(c->name, c->config_path, exec_function, exec_payload, options, attached_process);
+}
+
+static int lxcapi_attach_run_wait(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char * const argv[])
+{
+	lxc_attach_command_t command;
+	pid_t pid;
+	int r;
+
+	if (!c)
+		return -1;
+
+	command.program = (char*)program;
+	command.argv = (char**)argv;
+	r = lxc_attach(c->name, c->config_path, lxc_attach_run_command, &command, options, &pid);
+	if (r < 0) {
+		ERROR("ups");
+		return r;
+	}
+	return lxc_wait_for_pid_status(pid);
+}
+
+static int lxcapi_attach_run_waitl(struct lxc_container *c, lxc_attach_options_t *options, const char *program, const char *arg, ...)
+{
+	va_list ap;
+	const char **argv;
+	int ret;
+
+	if (!c)
+		return -1;
+
+	va_start(ap, arg);
+	argv = lxc_va_arg_list_to_argv_const(ap, 1);
+	va_end(ap);
+
+	if (!argv) {
+		ERROR("Memory allocation error.");
+		return -1;
+	}
+	argv[0] = arg;
+
+	ret = lxcapi_attach_run_wait(c, options, program, (const char * const *)argv);
+	free((void*)argv);
+	return ret;
+}
+
 struct lxc_container *lxc_container_new(const char *name, const char *configpath)
 {
 	struct lxc_container *c;
@@ -2086,6 +2105,9 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->set_config_path = lxcapi_set_config_path;
 	c->clone = lxcapi_clone;
 	c->get_ips = lxcapi_get_ips;
+	c->attach = lxcapi_attach;
+	c->attach_run_wait = lxcapi_attach_run_wait;
+	c->attach_run_waitl = lxcapi_attach_run_waitl;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit 96532523ef90ea6ce3f08ec7d74c3c850b885e50
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Aug 5 15:20:29 2013 -0500

    lxc-clone: don't s/oldname/newname in the config file and hooks
    
    1. container hooks should use lxcpath and lxcname from the environment.
    2. the utsname now gets separately updated
    3. the rootfs path gets updated by the bdev backend.
    4. the fstab mount targets should be relative
    5. the fstab source directories could be separately updated if needed.
    
    This leaves one definate bug: the lxc.logfile does not get updated.
    This made me wonder why it was in the configuration file to begin with.
    Digging deeper, I realized that whatever '-o outfile' you give
    lxc-create gets set in log.c and gets used by the lxc_container object
    we create at write_config().  So if you say
    	lxc-create -t cirros -n c1 -o /tmp/out1
    then /var/lib/lxc/c1/config will have lxc.logfile=/tmp/out1 - which is
    clearly wrong.  Therefore I leave fixing that for later.
    
    I'm looking for candidates for $p/$n expansion.  Note we can't expand
    these at config_utsname() etc, because then lxc-clone would see the
    expanded variable.  So we want to read $p/$n verbatim at config_*(),
    and expand them only when they are used.  lxc.logfile is an obvious
    good use case.  lxc.utsname can do it too, in case you want container
    c1 to be called "c1-whatever".  I'm not sure that's worth it though.
    Are there any others, or is that it?
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b0695bc..3affe22 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1423,11 +1423,23 @@ out:
 	return ret;
 }
 
+static bool set_config_item_locked(struct lxc_container *c, const char *key, const char *v)
+{
+	struct lxc_config_t *config;
+
+	if (!c->lxc_conf)
+		c->lxc_conf = lxc_conf_init();
+	if (!c->lxc_conf)
+		return false;
+	config = lxc_getconfig(key);
+	if (!config)
+		return false;
+	return (0 == config->cb(key, v, c->lxc_conf));
+}
+
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
 {
-	int ret;
 	bool b = false;
-	struct lxc_config_t *config;
 
 	if (!c)
 		return false;
@@ -1435,18 +1447,8 @@ static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, con
 	if (container_mem_lock(c))
 		return false;
 
-	if (!c->lxc_conf)
-		c->lxc_conf = lxc_conf_init();
-	if (!c->lxc_conf)
-		goto err;
-	config = lxc_getconfig(key);
-	if (!config)
-		goto err;
-	ret = config->cb(key, v, c->lxc_conf);
-	if (!ret)
-		b = true;
+	b = set_config_item_locked(c, key, v);
 
-err:
 	container_mem_unlock(c);
 	return b;
 }
@@ -1658,153 +1660,6 @@ err:
 	return -1;
 }
 
-/*
- * we're being passed result of two strstrs(x, y).  We want to write
- * all data up to the first found string, or to end of the string if
- * neither string was found.
- * This function will return the earliest found string if any, or else
- * NULL
- */
-static const char *lowest_nonnull(const char *p1, const char *p2)
-{
-	if (!p1)
-		return p2;
-	if (!p2)
-		return p1;
-	return p1 < p2 ? p1 : p2;
-}
-
-static int is_word_sep(char c)
-{
-	switch(c) {
-	case '\0':
-	case '\n':
-	case '\r':
-	case '\t':
-	case ' ':
-	case '=':
-	case '.':
-	case ',':
-	case '_':
-	case '-':
-	case '/':
-		return 1;
-	default: return 0;
-	}
-}
-
-static const char *find_first_wholeword(const char *p0, const char *word)
-{
-	const char *p = p0;
-
-	if (!p)
-		return NULL;
-
-	while ((p = strstr(p, word)) != NULL) {
-		if ((p == p0 || is_word_sep(*(p-1))) &&
-		    is_word_sep(p[strlen(word)]))
-			return p;
-		p++;
-	}
-	return NULL;
-}
-
-static int update_name_and_paths(const char *path, struct lxc_container *oldc,
-		const char *newname, const char *newpath)
-{
-	FILE *f;
-	long flen;
-	char *contents;
-	const char *p0, *p1, *p2, *end;
-	const char *oldpath = oldc->get_config_path(oldc);
-	const char *oldname = oldc->name;
-
-	f = fopen(path, "r");
-	if (!f) {
-		SYSERROR("opening old config");
-		return -1;
-	}
-	if (fseek(f, 0, SEEK_END) < 0) {
-		SYSERROR("seeking to end of old config");
-		fclose(f);
-		return -1;
-	}
-	flen = ftell(f);
-	if (flen < 0) {
-		SYSERROR("telling size of old config");
-		fclose(f);
-		return -1;
-	}
-	if (fseek(f, 0, SEEK_SET) < 0) {
-		SYSERROR("rewinding old config");
-		fclose(f);
-		return -1;
-	}
-	contents = malloc(flen+1);
-	if (!contents) {
-		SYSERROR("out of memory");
-		fclose(f);
-		return -1;
-	}
-	if (fread(contents, 1, flen, f) != flen) {
-		SYSERROR("reading old config");
-		free(contents);
-		fclose(f);
-		return -1;
-	}
-	contents[flen] = '\0';
-	if (fclose(f) < 0) {
-		SYSERROR("closing old config");
-		free(contents);
-		return -1;
-	}
-
-	f = fopen(path, "w");
-	if (!f) {
-		SYSERROR("reopening config");
-		free(contents);
-		return -1;
-	}
-
-	p0 = contents;
-	end = contents + flen;
-	while (1) {
-		p1 = find_first_wholeword(p0, oldpath);
-		p2 = find_first_wholeword(p0, oldname);
-		if (!p1 && !p2) {
-			// write the rest and be done
-			if (fwrite(p0, 1, (end-p0), f) != (end-p0)) {
-				SYSERROR("writing new config");
-				free(contents);
-				fclose(f);
-				return -1;
-			}
-			free(contents);
-			fclose(f);
-			// success
-			return 0;
-		} else {
-			const char *p = lowest_nonnull(p1, p2);
-			const char *new = (p == p2) ? newname : newpath;
-			if (fwrite(p0, 1, (p-p0), f) != (p-p0)) {
-				SYSERROR("writing new config");
-				free(contents);
-				fclose(f);
-				return -1;
-			}
-			p0 = p;
-			// now write the newpath or newname
-			if (fwrite(new, 1, strlen(new), f) != strlen(new)) {
-				SYSERROR("writing new name or path in new config");
-				free(contents);
-				fclose(f);
-				return -1;
-			}
-			p0 += (p == p2) ? strlen(oldname) : strlen(oldpath);
-		}
-	}
-}
-
 static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 {
 	int i;
@@ -1832,7 +1687,6 @@ static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
 				ERROR("out of memory copying hook path");
 				return -1;
 			}
-			update_name_and_paths(it->elem, oldc, c->name, c->get_config_path(c));
 		}
 	}
 
@@ -2063,7 +1917,8 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		goto out;
 	}
 
-	if (create_file_dirname(newpath) < 0) {
+	ret = create_file_dirname(newpath);
+	if (ret < 0 && errno != EEXIST) {
 		ERROR("Error creating container dir for %s", newpath);
 		goto out;
 	}
@@ -2077,11 +1932,6 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	write_config(fout, c->lxc_conf);
 	fclose(fout);
 
-	if (update_name_and_paths(newpath, c, n, l) < 0) {
-		ERROR("Error updating name in cloned config");
-		goto out;
-	}
-
 	sprintf(newpath, "%s/%s/rootfs", l, n);
 	if (mkdir(newpath, 0755) < 0) {
 		SYSERROR("error creating %s", newpath);
@@ -2094,6 +1944,13 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		goto out;
 	}
 
+	// update utsname
+	if (!set_config_item_locked(c2, "lxc.utsname", newname)) {
+		ERROR("Error setting new hostname");
+		goto out;
+	}
+
+
 	// copy hooks if requested
 	if (flags & LXC_CLONE_COPYHOOKS) {
 		ret = copyhooks(c, c2);

commit 8058be395d46cfabf2dacd7df79e95309619986a
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Jul 16 10:35:02 2013 -0400

    clone: only update <rootfs>/etc/hostname if it exists
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c5aae99..b0695bc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1987,6 +1987,8 @@ static int clone_update_rootfs(struct lxc_container *c0,
 		ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
 		if (ret < 0 || ret >= MAXPATHLEN)
 			exit(1);
+		if (!file_exists(path))
+			exit(0);
 		if (!(fout = fopen(path, "w"))) {
 			SYSERROR("unable to open %s: ignoring\n", path);
 			exit(0);

commit 5202677243dcda16ab97c07d497174726198f7ab
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Jul 16 08:11:56 2013 -0500

    lxccontainer: don't define certain variables if !HAVE_GNUTLS
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0c13e06..c5aae99 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -874,10 +874,12 @@ bool prepend_lxc_header(char *path, const char *t, char *const argv[])
 {
 	size_t flen;
 	char *contents, *tpath;
-	int i, ret;
 	FILE *f;
+#if HAVE_LIBGNUTLS
+	int i, ret;
 	unsigned char md_value[SHA_DIGEST_LENGTH];
 	bool have_tpath = false;
+#endif
 
 	if ((f = fopen(path, "r")) == NULL) {
 		SYSERROR("Opening old config");

commit 3ce746862b2a2b33f3de65aeecda0bad1a5dd27c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jul 12 14:07:23 2013 -0500

    lxc_create: prepend pretty header to config file (v2)
    
    Define a sha1sum_file() function in utils.c.  Use that in lxcapi_create
    to write out the sha1sum of the template being used.  If libgnutls is
    not found, then the template sha1sum simply won't be printed into the
    container config.
    
    This patch also trivially fixes some cases where SYSERROR is used after
    a fclose (masking errno) and missing consts in mkdir_p.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 446827c..0c13e06 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -870,6 +870,107 @@ static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet
 	return true;
 }
 
+bool prepend_lxc_header(char *path, const char *t, char *const argv[])
+{
+	size_t flen;
+	char *contents, *tpath;
+	int i, ret;
+	FILE *f;
+	unsigned char md_value[SHA_DIGEST_LENGTH];
+	bool have_tpath = false;
+
+	if ((f = fopen(path, "r")) == NULL) {
+		SYSERROR("Opening old config");
+		return false;
+	}
+	if (fseek(f, 0, SEEK_END) < 0) {
+		SYSERROR("Seeking to end of old config file");
+		fclose(f);
+		return false;
+	}
+	if ((flen = ftell(f)) < 0) {
+		SYSERROR("telling size of old config");
+		fclose(f);
+		return false;
+	}
+	if (fseek(f, 0, SEEK_SET) < 0) {
+		SYSERROR("rewinding old config");
+		fclose(f);
+		return false;
+	}
+	if ((contents = malloc(flen + 1)) == NULL) {
+		SYSERROR("out of memory");
+		fclose(f);
+		return false;
+	}
+	if (fread(contents, 1, flen, f) != flen) {
+		SYSERROR("Reading old config");
+		free(contents);
+		fclose(f);
+		return false;
+	}
+	contents[flen] = '\0';
+	if (fclose(f) < 0) {
+		SYSERROR("closing old config");
+		free(contents);
+		return false;
+	}
+
+	if ((tpath = get_template_path(t)) < 0) {
+		ERROR("bad template: %s\n", t);
+		free(contents);
+		return false;
+	}
+
+#if HAVE_LIBGNUTLS
+	if (tpath) {
+		have_tpath = true;
+		ret = sha1sum_file(tpath, md_value);
+		if (ret < 0) {
+			ERROR("Error getting sha1sum of %s", tpath);
+			free(contents);
+			return false;
+		}
+		free(tpath);
+	}
+#endif
+
+	if ((f = fopen(path, "w")) == NULL) {
+		SYSERROR("reopening config for writing");
+		free(contents);
+		return false;
+	}
+	fprintf(f, "# Template used to create this container: %s\n", t);
+	if (argv) {
+		fprintf(f, "# Parameters passed to the template:");
+		while (*argv) {
+			fprintf(f, " %s", *argv);
+			argv++;
+		}
+		fprintf(f, "\n");
+	}
+#if HAVE_LIBGNUTLS
+	if (have_tpath) {
+		fprintf(f, "# Template script checksum (SHA-1): ");
+		for (i=0; i<SHA_DIGEST_LENGTH; i++)
+			fprintf(f, "%02x", md_value[i]);
+		fprintf(f, "\n");
+	}
+#endif
+	if (fwrite(contents, 1, flen, f) != flen) {
+		SYSERROR("Writing original contents");
+		free(contents);
+		fclose(f);
+		return false;
+	}
+	free(contents);
+	if (fclose(f) < 0) {
+		SYSERROR("Closing config file after write");
+		return false;
+	}
+	return true;
+}
+
 static bool lxcapi_destroy(struct lxc_container *c);
 /*
  * lxcapi_create:
@@ -967,6 +1068,11 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (c->lxc_conf)
 		lxc_conf_free(c->lxc_conf);
 	c->lxc_conf = NULL;
+
+	if (!prepend_lxc_header(c->configfile, tpath, argv)) {
+		ERROR("Error prepending header to configuration file");
+		goto out_unlock;
+	}
 	bret = load_config_locked(c, c->configfile);
 
 out_unlock:
@@ -1623,13 +1729,13 @@ static int update_name_and_paths(const char *path, struct lxc_container *oldc,
 	}
 	flen = ftell(f);
 	if (flen < 0) {
-		fclose(f);
 		SYSERROR("telling size of old config");
+		fclose(f);
 		return -1;
 	}
 	if (fseek(f, 0, SEEK_SET) < 0) {
-		fclose(f);
 		SYSERROR("rewinding old config");
+		fclose(f);
 		return -1;
 	}
 	contents = malloc(flen+1);
@@ -1639,15 +1745,15 @@ static int update_name_and_paths(const char *path, struct lxc_container *oldc,
 		return -1;
 	}
 	if (fread(contents, 1, flen, f) != flen) {
+		SYSERROR("reading old config");
 		free(contents);
 		fclose(f);
-		SYSERROR("reading old config");
 		return -1;
 	}
 	contents[flen] = '\0';
 	if (fclose(f) < 0) {
-		free(contents);
 		SYSERROR("closing old config");
+		free(contents);
 		return -1;
 	}
 

commit dc23c1c817da5c13529432270e51d0f7f3b1e95e
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jul 12 09:44:41 2013 -0500

    create: add a quiet flag
    
    If set, then fds 0,1,2 will be redirected while the creation
    template is executed.
    
    Note, as Dwight has pointed out, if fd 0 is redirected, then if
    templates ask for input there will be a problem.  We could simply
    not redirect fd 0, or we could require that templates work without
    interaction.  I'm assuming here that we want to do the latter, but
    I'm open to changing that.
    
    Reported-by: "S.alar Onur" <caglar@10ur.org>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1584a2b..446827c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -752,7 +752,7 @@ static char *lxcbasename(char *path)
 	return p;
 }
 
-static bool create_run_template(struct lxc_container *c, char *tpath,
+static bool create_run_template(struct lxc_container *c, char *tpath, bool quiet,
 				char *const argv[])
 {
 	pid_t pid;
@@ -773,6 +773,14 @@ static bool create_run_template(struct lxc_container *c, char *tpath,
 		int ret, len, nargs = 0;
 		char **newargv;
 
+		if (quiet) {
+			close(0);
+			close(1);
+			close(2);
+			open("/dev/zero", O_RDONLY);
+			open("/dev/null", O_RDWR);
+			open("/dev/null", O_RDWR);
+		}
 		if (unshare(CLONE_NEWNS) < 0) {
 			ERROR("error unsharing mounts");
 			exit(1);
@@ -878,7 +886,7 @@ static bool lxcapi_destroy(struct lxc_container *c);
  * arguments, you can just pass NULL.
  */
 static bool lxcapi_create(struct lxc_container *c, const char *t,
-		const char *bdevtype, struct bdev_specs *specs,
+		const char *bdevtype, struct bdev_specs *specs, int flags,
 		char *const argv[])
 {
 	bool bret = false;
@@ -951,7 +959,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 	if (!load_config_locked(c, c->configfile))
 		goto out;
 
-	if (!create_run_template(c, tpath, argv))
+	if (!create_run_template(c, tpath, !!(flags & LXC_CREATE_QUIET), argv))
 		goto out_unlock;
 
 	// now clear out the lxc_conf we have, reload from the created
@@ -1014,7 +1022,7 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 }
 
 static bool lxcapi_createl(struct lxc_container *c, const char *t,
-		const char *bdevtype, struct bdev_specs *specs, ...)
+		const char *bdevtype, struct bdev_specs *specs, int flags, ...)
 {
 	bool bret = false;
 	char **args = NULL, **temp;
@@ -1028,7 +1036,7 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	 * since we're going to wait for create to finish, I don't think we
 	 * need to get a copy of the arguments.
 	 */
-	va_start(ap, specs);
+	va_start(ap, flags);
 	while (1) {
 		char *arg;
 		arg = va_arg(ap, char *);
@@ -1047,7 +1055,7 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t,
 	if (args)
 		args[nargs] = NULL;
 
-	bret = c->create(c, t, bdevtype, specs, args);
+	bret = c->create(c, t, bdevtype, specs, flags, args);
 
 out:
 	if (args)

commit 283678ed2ccd88a6ba57fcb28516311adcdb6fac
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jul 5 19:34:55 2013 -0500

    Accomodate stricter devices cgroup rules
    
    3.10 kernel comes with proper hierarchical enforcement of devices
    cgroup.  To keep that code somewhat sane, certain things are not
    allowed.  Switching from default-allow to default-deny and vice versa
    are not allowed when there are children cgroups.  (This *could* be
    simplified in the kernel by checking that all child cgroups are
    unpopulated, but that has not yet been done and may be rejected)
    
    The mountcgroup hook causes lxc-start to break with 3.10 kernels, because
    you cannot write 'a' to devices.deny once you have a child cgroup.  With
    this patch, (a) lxcpath is passed to hooks, (b) the cgroup mount hook sets
    the container's devices cgroup, and (c) setup_cgroup() during lxc startup
    ignores failures to write to devices subsystem if we are already in a
    child of the container's new cgroup.
    
    ((a) is not really related to this bug, but is definately needed.
    The followup work of making the other hooks use the passed-in lxcpath
    is still to be done)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6326eb0..1584a2b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1861,7 +1861,7 @@ static int clone_update_rootfs(struct lxc_container *c0,
 			SYSERROR("failed to set environment variable for rootfs mount");
 		}
 
-		if (run_lxc_hooks(c->name, "clone", conf, hookargs)) {
+		if (run_lxc_hooks(c->name, "clone", conf, c->get_config_path(c), hookargs)) {
 			ERROR("Error executing clone hook for %s", c->name);
 			exit(1);
 		}

commit cbee8106e38f9ffa130c7bf8be325f7f203da67a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jul 10 23:30:29 2013 -0500

    lxcapi_create: fix template handling
    
    1. If no template is passed in, then do not try to execute it.  The user
    just wanted to write the configuration.
    
    2. If template is passed in as a full path, then use that instead of
    constructing '$templatedir/lxc-$template'.
    
    Reported-by: Wanlong Gao <gaowanlong@cn.fujitsu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 596c189..6326eb0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -646,17 +646,6 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
-static bool valid_template(char *t)
-{
-	struct stat statbuf;
-	int statret;
-
-	statret = stat(t, &statbuf);
-	if (statret == 0)
-		return true;
-	return false;
-}
-
 /*
  * create the standard expected container dir
  */
@@ -715,6 +704,46 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	return bdev;
 }
 
+/*
+ * Given the '-t' template option to lxc-create, figure out what to
+ * do.  If the template is a full executable path, use that.  If it
+ * is something like 'sshd', then return $templatepath/lxc-sshd.  If
+ * no template was passed in, return NULL  (this is ok).
+ * On error return (char *) -1.
+ */
+char *get_template_path(const char *t)
+{
+	int ret, len;
+	char *tpath;
+
+	if (!t)
+		return NULL;
+
+	if (t[0] == '/' && access(t, X_OK) == 0) {
+		tpath = strdup(t);
+		if (!tpath)
+			return (char *) -1;
+		return tpath;
+	}
+
+	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
+	tpath = malloc(len);
+	if (!tpath)
+		return (char *) -1;
+	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
+	if (ret < 0 || ret >= len) {
+		free(tpath);
+		return (char *) -1;
+	}
+	if (access(tpath, X_OK) < 0) {
+		SYSERROR("bad template: %s\n", t);
+		free(tpath);
+		return (char *) -1;
+	}
+
+	return tpath;
+}
+
 static char *lxcbasename(char *path)
 {
 	char *p = path + strlen(path) - 1;
@@ -854,20 +883,13 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 {
 	bool bret = false;
 	pid_t pid;
-	char *tpath = NULL;
-	int partial_fd, ret, len;
+	char *tpath;
+	int partial_fd;
 
 	if (!c)
 		return false;
 
-	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
-	tpath = malloc(len);
-	if (!tpath)
-		return false;
-	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
-	if (ret < 0 || ret >= len)
-		goto out;
-	if (!valid_template(tpath)) {
+	if ((tpath = get_template_path(t)) < 0) {
 		ERROR("bad template: %s\n", t);
 		goto out;
 	}

commit 96b3cb407c07915db2cd0542c313a4bff4d1d389
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jul 10 23:29:20 2013 -0500

    lxcapi_create: split out the template execution
    
    Make it its own function to make both more readable.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 245d5eb..596c189 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -715,115 +715,34 @@ static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
 	return bdev;
 }
 
-static bool lxcapi_destroy(struct lxc_container *c);
-/*
- * lxcapi_create:
- * create a container with the given parameters.
- * @c: container to be created.  It has the lxcpath, name, and a starting
- *     configuration already set
- * @t: the template to execute to instantiate the root filesystem and
- *     adjust the configuration.
- * @bdevtype: backing store type to use.  If NULL, dir will be used.
- * @specs: additional parameters for the backing store, i.e. LVM vg to
- *         use.
- *
- * @argv: the arguments to pass to the template, terminated by NULL.  If no
- * arguments, you can just pass NULL.
- */
-static bool lxcapi_create(struct lxc_container *c, const char *t,
-		const char *bdevtype, struct bdev_specs *specs,
-		char *const argv[])
+static char *lxcbasename(char *path)
 {
-	bool bret = false;
-	pid_t pid;
-	char *tpath = NULL, **newargv;
-	int partial_fd, ret, len, nargs = 0;
+	char *p = path + strlen(path) - 1;
+	while (*p != '/' && p > path)
+		p--;
+	return p;
+}
 
-	if (!c)
-		return false;
+static bool create_run_template(struct lxc_container *c, char *tpath,
+				char *const argv[])
+{
+	pid_t pid;
 
-	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
-	tpath = malloc(len);
 	if (!tpath)
-		return false;
-	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
-	if (ret < 0 || ret >= len)
-		goto out;
-	if (!valid_template(tpath)) {
-		ERROR("bad template: %s\n", t);
-		goto out;
-	}
-
-	if (!c->save_config(c, NULL)) {
-		ERROR("failed to save starting configuration for %s\n", c->name);
-		goto out;
-	}
-
-	/* container is already created if we have a config and rootfs.path is accessible */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0)
-		goto out;
-
-	/* Mark that this container is being created */
-	if ((partial_fd = create_partial(c)) < 0)
-		goto out;
-
-	/* no need to get disk lock bc we have the partial locked */
-
-	/*
-	 * Create the backing store
-	 * Note we can't do this in the same task as we use to execute the
-	 * template because of the way zfs works.
-	 * After you 'zfs create', zfs mounts the fs only in the initial
-	 * namespace.
-	 */
-	pid = fork();
-	if (pid < 0) {
-		SYSERROR("failed to fork task for container creation template\n");
-		goto out_unlock;
-	}
-
-	if (pid == 0) { // child
-		struct bdev *bdev = NULL;
-
-		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
-			ERROR("Error creating backing store type %s for %s",
-				bdevtype ? bdevtype : "(none)", c->name);
-			exit(1);
-		}
-
-		/* save config file again to store the new rootfs location */
-		if (!c->save_config(c, NULL)) {
-			ERROR("failed to save starting configuration for %s\n", c->name);
-			// parent task won't see bdev in config so we delete it
-			bdev->ops->umount(bdev);
-			bdev->ops->destroy(bdev);
-			exit(1);
-		}
-		exit(0);
-	}
-	if (wait_for_pid(pid) != 0)
-		goto out;
-
-	/* reload config to get the rootfs */
-	if (c->lxc_conf)
-		lxc_conf_free(c->lxc_conf);
-	c->lxc_conf = NULL;
-	if (!load_config_locked(c, c->configfile))
-		goto out;
+		return true;
 
-	/*
-	 * now execute the template
-	 */
 	pid = fork();
 	if (pid < 0) {
 		SYSERROR("failed to fork task for container creation template\n");
-		goto out_unlock;
+		return false;
 	}
 
 	if (pid == 0) { // child
 		char *patharg, *namearg, *rootfsarg, *src;
 		struct bdev *bdev = NULL;
 		int i;
+		int ret, len, nargs = 0;
+		char **newargv;
 
 		if (unshare(CLONE_NEWNS) < 0) {
 			ERROR("error unsharing mounts");
@@ -860,7 +779,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		newargv = malloc(nargs * sizeof(*newargv));
 		if (!newargv)
 			exit(1);
-		newargv[0] = (char *)t;
+		newargv[0] = lxcbasename(tpath);
 
 		len = strlen(c->config_path) + strlen(c->name) + strlen("--path=") + 2;
 		patharg = malloc(len);
@@ -908,9 +827,111 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 
 	if (wait_for_pid(pid) != 0) {
 		ERROR("container creation template for %s failed\n", c->name);
+		return false;
+	}
+
+	return true;
+}
+
+static bool lxcapi_destroy(struct lxc_container *c);
+/*
+ * lxcapi_create:
+ * create a container with the given parameters.
+ * @c: container to be created.  It has the lxcpath, name, and a starting
+ *     configuration already set
+ * @t: the template to execute to instantiate the root filesystem and
+ *     adjust the configuration.
+ * @bdevtype: backing store type to use.  If NULL, dir will be used.
+ * @specs: additional parameters for the backing store, i.e. LVM vg to
+ *         use.
+ *
+ * @argv: the arguments to pass to the template, terminated by NULL.  If no
+ * arguments, you can just pass NULL.
+ */
+static bool lxcapi_create(struct lxc_container *c, const char *t,
+		const char *bdevtype, struct bdev_specs *specs,
+		char *const argv[])
+{
+	bool bret = false;
+	pid_t pid;
+	char *tpath = NULL;
+	int partial_fd, ret, len;
+
+	if (!c)
+		return false;
+
+	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
+	tpath = malloc(len);
+	if (!tpath)
+		return false;
+	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
+	if (ret < 0 || ret >= len)
+		goto out;
+	if (!valid_template(tpath)) {
+		ERROR("bad template: %s\n", t);
+		goto out;
+	}
+
+	if (!c->save_config(c, NULL)) {
+		ERROR("failed to save starting configuration for %s\n", c->name);
+		goto out;
+	}
+
+	/* container is already created if we have a config and rootfs.path is accessible */
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0)
+		goto out;
+
+	/* Mark that this container is being created */
+	if ((partial_fd = create_partial(c)) < 0)
+		goto out;
+
+	/* no need to get disk lock bc we have the partial locked */
+
+	/*
+	 * Create the backing store
+	 * Note we can't do this in the same task as we use to execute the
+	 * template because of the way zfs works.
+	 * After you 'zfs create', zfs mounts the fs only in the initial
+	 * namespace.
+	 */
+	pid = fork();
+	if (pid < 0) {
+		SYSERROR("failed to fork task for container creation template\n");
 		goto out_unlock;
 	}
 
+	if (pid == 0) { // child
+		struct bdev *bdev = NULL;
+
+		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
+			ERROR("Error creating backing store type %s for %s",
+				bdevtype ? bdevtype : "(none)", c->name);
+			exit(1);
+		}
+
+		/* save config file again to store the new rootfs location */
+		if (!c->save_config(c, NULL)) {
+			ERROR("failed to save starting configuration for %s\n", c->name);
+			// parent task won't see bdev in config so we delete it
+			bdev->ops->umount(bdev);
+			bdev->ops->destroy(bdev);
+			exit(1);
+		}
+		exit(0);
+	}
+	if (wait_for_pid(pid) != 0)
+		goto out;
+
+	/* reload config to get the rootfs */
+	if (c->lxc_conf)
+		lxc_conf_free(c->lxc_conf);
+	c->lxc_conf = NULL;
+	if (!load_config_locked(c, c->configfile))
+		goto out;
+
+	if (!create_run_template(c, tpath, argv))
+		goto out_unlock;
+
 	// now clear out the lxc_conf we have, reload from the created
 	// container
 	if (c->lxc_conf)

commit 1143ed392d2760e8f7aeee88d570bb0ba151885f
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Jul 9 16:19:45 2013 -0400

    add clonehostname hook
    
    This hook script updates the hostname in various files under /etc in the
    cloned container. In order to do so, the old container name is passed in
    the LXC_SRC_NAME environment variable.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index aaa9f2a..245d5eb 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1770,7 +1770,9 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	return 0;
 }
 
-static int clone_update_rootfs(struct lxc_container *c, int flags, char **hookargs)
+static int clone_update_rootfs(struct lxc_container *c0,
+			       struct lxc_container *c, int flags,
+			       char **hookargs)
 {
 	int ret = -1;
 	char path[MAXPATHLEN];
@@ -1800,6 +1802,9 @@ static int clone_update_rootfs(struct lxc_container *c, int flags, char **hookar
 
 	if (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {
 		/* Start of environment variable setup for hooks */
+		if (setenv("LXC_SRC_NAME", c0->name, 1)) {
+			SYSERROR("failed to set environment variable for source container name");
+		}
 		if (setenv("LXC_NAME", c->name, 1)) {
 			SYSERROR("failed to set environment variable for container name");
 		}
@@ -1958,7 +1963,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (!c2->save_config(c2, NULL))
 		goto out;
 
-	if (clone_update_rootfs(c2, flags, hookargs) < 0)
+	if (clone_update_rootfs(c, c2, flags, hookargs) < 0)
 		goto out;
 
 	// TODO: update c's lxc.snapshot = count

commit 3327917f4a991a49ba1562b774c63c45139772eb
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Jul 9 18:07:26 2013 -0400

    fix potential out of bounds pointer deref
    
    I noticed that if find_first_wholeword() is called with word at the very
    beginning of p, we will deref *(p - 1) to see if it is a word boundary.
    Fix by considering p = p0 to be a word boundary.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4e71fb1..aaa9f2a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1534,13 +1534,16 @@ static int is_word_sep(char c)
 	}
 }
 
-static const char *find_first_wholeword(const char *p, const char *word)
+static const char *find_first_wholeword(const char *p0, const char *word)
 {
+	const char *p = p0;
+
 	if (!p)
 		return NULL;
 
 	while ((p = strstr(p, word)) != NULL) {
-		if (is_word_sep(*(p-1)) && is_word_sep(p[strlen(word)]))
+		if ((p == p0 || is_word_sep(*(p-1))) &&
+		    is_word_sep(p[strlen(word)]))
 			return p;
 		p++;
 	}

commit ef091cefca5082007678fe82ad01389f7057ca48
Author: Bogdan Purcareata <bogdan.purcareata@freescale.com>
Date:   Wed Jul 3 12:00:53 2013 -0400

    lxcapi_set_cgroup_item: remove duplicate == 0
    
    Signed-off-by: Bogdan Purcareata <bogdan.purcareata@freescale.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 677fa56..4e71fb1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1393,7 +1393,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (container_disk_lock(c))
 		return false;
 
-	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path) == 0;
+	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
 
 	container_disk_unlock(c);
 	return ret == 0;

commit 176d9acb2ec17211a0d69bd2bd99f914fad8d7ad
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jun 21 14:16:42 2013 -0500

    api_clone: don't remove storage if we haven't created it
    
    In the best case we'll get errors about failing to remove it.  In the
    worst case we'll be trying to delete the original container's rootfs.
    
    Reported-by: zoolook <nbensa+lxcusers@gmail.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b6d5b2f..677fa56 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1866,7 +1866,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 {
 	struct lxc_container *c2 = NULL;
 	char newpath[MAXPATHLEN];
-	int ret;
+	int ret, storage_copied = 0;
 	const char *n, *l;
 	FILE *fout;
 
@@ -1948,6 +1948,10 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (ret < 0)
 		goto out;
 
+	// We've now successfully created c2's storage, so clear it out if we
+	// fail after this
+	storage_copied = 1;
+
 	if (!c2->save_config(c2, NULL))
 		goto out;
 
@@ -1961,6 +1965,8 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 out:
 	container_mem_unlock(c);
 	if (c2) {
+		if (!storage_copied)
+			c2->lxc_conf->rootfs.path = NULL;
 		c2->destroy(c2);
 		lxc_container_put(c2);
 	}

commit ae3f8cf9a4a03c62c6c12968b38b2352388df91c
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Jun 21 14:15:42 2013 -0500

    Accept more word delimiters when updating hooks
    
    When updating container names in hook files during a container clone,
    we substitute the new container name for the old any time the old name
    shows up as a separate word.  This patch adds the four characters
    '.,_-' as additional delimiters.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b1a05b4..b6d5b2f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1524,6 +1524,10 @@ static int is_word_sep(char c)
 	case '\t':
 	case ' ':
 	case '=':
+	case '.':
+	case ',':
+	case '_':
+	case '-':
 	case '/':
 		return 1;
 	default: return 0;

commit b515981702133b9aaea1aff378493f054c14d46c
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Wed Jun 12 08:09:16 2013 -0700

    console API improvements
    
    Add a higher level console API that opens a tty/console and runs the
    mainloop as well. Rename existing API to console_getfd(). Use these in
    the python binding.
    
    Allow attaching a console peer after container bootup, including if the
    container was launched with -d. This is made possible by allocation of a
    "proxy" pty as the peer when the console is attached to.
    
    Improve handling of SIGWINCH, the pty size will be correctly set at the
    beginning of a session and future changes when using the lxc_console() API
    will be propagated to it as well.
    
    Refactor some common code between lxc_console.c and console.c. The variable
    wait4q (renamed to saw_escape) was static, making the mainloop callback not
    safe across threads. This wasn't a problem when the callback was in the
    non-threaded lxc-console, but now that it is internal to console.c, we have
    to take care of it. This is now contained in a per-tty state structure.
    
    Don't attempt to open /dev/null as the console peer since /dev/null cannot
    be added to the mainloop (epoll_ctl() fails with EPERM). This isn't needed
    to get the console setup (and the log to work) since the case of not having
    a peer at console init time has to be handled to allow for attaching to it
    later.
    
    Move signalfd libc wrapper/replacement to utils.h.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c8fc16f..b1a05b4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -31,6 +31,7 @@
 #include "lxccontainer.h"
 #include "conf.h"
 #include "confile.h"
+#include "console.h"
 #include "cgroup.h"
 #include "commands.h"
 #include "version.h"
@@ -350,16 +351,22 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	return true;
 }
 
-static int lxcapi_console(struct lxc_container *c, int *ttynum, int *masterfd)
+static int lxcapi_console_getfd(struct lxc_container *c, int *ttynum, int *masterfd)
 {
 	int ttyfd;
 	if (!c)
 		return -1;
 
-	ttyfd = lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);
+	ttyfd = lxc_console_getfd(c, ttynum, masterfd);
 	return ttyfd;
 }
 
+static int lxcapi_console(struct lxc_container *c, int ttynum, int stdinfd,
+			  int stdoutfd, int stderrfd, int escape)
+{
+	return lxc_console(c, ttynum, stdinfd, stdoutfd, stderrfd, escape);
+}
+
 static pid_t lxcapi_init_pid(struct lxc_container *c)
 {
 	if (!c)
@@ -2018,6 +2025,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->freeze = lxcapi_freeze;
 	c->unfreeze = lxcapi_unfreeze;
 	c->console = lxcapi_console;
+	c->console_getfd = lxcapi_console_getfd;
 	c->init_pid = lxcapi_init_pid;
 	c->load_config = lxcapi_load_config;
 	c->want_daemonize = lxcapi_want_daemonize;

commit f02abefef9a59658c813e08f86a91fbe09eabf00
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Fri Jun 7 10:07:36 2013 -0400

    fix check for lock acquired
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index cf5252b..c8fc16f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -418,7 +418,7 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 {
 	if (!c)
 		return;
-	if (!container_mem_lock(c)) {
+	if (container_mem_lock(c)) {
 		ERROR("Error getting mem lock");
 		return;
 	}

commit 93dc5327aa0c2b13d619b8bedf893eea983d4d68
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Jun 5 11:56:30 2013 -0500

    lxclock and lxccontainer: switch from flock to fcntl
    
    flock is not supported on nfs.  fcntl is at least supported on newer
    (v3 and above) nfs.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Tested-by: zoolook <nbensa+lxcusers@gmail.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2edf749..cf5252b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -23,6 +23,7 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <sched.h>
 #include "config.h"
 #include "lxc.h"
@@ -39,7 +40,6 @@
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
 #include <sched.h>
-#include <fcntl.h>
 #include <arpa/inet.h>
 #include <ifaddrs.h>
 
@@ -66,6 +66,8 @@ int ongoing_create(struct lxc_container *c)
 	int len = strlen(c->config_path) + strlen(c->name) + 10;
 	char *path = alloca(len);
 	int fd, ret;
+	struct flock lk;
+
 	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		ERROR("Error writing partial pathname");
@@ -82,8 +84,12 @@ int ongoing_create(struct lxc_container *c)
 		process_unlock();
 		return 0;
 	}
-	if ((ret = flock(fd, LOCK_EX | LOCK_NB)) == -1 &&
-			errno == EWOULDBLOCK) {
+	lk.l_type = F_WRLCK;
+	lk.l_whence = SEEK_SET;
+	lk.l_start = 0;
+	lk.l_len = 0;
+	lk.l_pid = -1;
+	if (fcntl(fd, F_GETLK, &lk) == 0 && lk.l_pid != -1) {
 		// create is still ongoing
 		close(fd);
 		process_unlock();
@@ -101,6 +107,8 @@ int create_partial(struct lxc_container *c)
 	int len = strlen(c->config_path) + strlen(c->name) + 10;
 	char *path = alloca(len);
 	int fd, ret;
+	struct flock lk;
+
 	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		ERROR("Error writing partial pathname");
@@ -108,12 +116,16 @@ int create_partial(struct lxc_container *c)
 	}
 	if (process_lock())
 		return -1;
-	if ((fd=open(path, O_CREAT | O_EXCL, 0755)) < 0) {
+	if ((fd=open(path, O_RDWR | O_CREAT | O_EXCL, 0755)) < 0) {
 		SYSERROR("Erorr creating partial file");
 		process_unlock();
 		return -1;
 	}
-	if (flock(fd, LOCK_EX) < 0) {
+	lk.l_type = F_WRLCK;
+	lk.l_whence = SEEK_SET;
+	lk.l_start = 0;
+	lk.l_len = 0;
+	if (fcntl(fd, F_SETLKW, &lk) < 0) {
 		SYSERROR("Error locking partial file %s", path);
 		close(fd);
 		process_unlock();

commit eddaaafd1a9b02ba39e5b6b13d40b4a5d37a04e1
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sun Jun 2 15:39:35 2013 -0500

    implement loopback backing store
    
    Create a loopfile backed container by doing:
    
    	lxc-create -B loop -t template -n name
    
    or
    
    	lxc-clone -B loop -o dir1 -n loop1
    
    The rootfs in the configuration file will be
    
    	loop:/var/lib/lxc/loop1/rootdev
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3764923..2edf749 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -534,7 +534,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		close(0);
 		close(1);
 		close(2);
-		open("/dev/null", O_RDONLY);
+		open("/dev/zero", O_RDONLY);
 		open("/dev/null", O_RDWR);
 		open("/dev/null", O_RDWR);
 		setsid();

commit 44ef0c0c7200ef4e8783387d886d3748da3d50fd
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Jun 3 10:47:21 2013 -0500

    lxcapi_create: don't close stdin/out/err
    
    Otherwise we can't see template progress.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 61e1327..3764923 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -806,13 +806,6 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 		struct bdev *bdev = NULL;
 		int i;
 
-		close(0);
-		close(1);
-		close(2);
-		open("/dev/null", O_RDONLY);
-		open("/dev/null", O_RDWR);
-		open("/dev/null", O_RDWR);
-
 		if (unshare(CLONE_NEWNS) < 0) {
 			ERROR("error unsharing mounts");
 			exit(1);

commit 0a18b5458b6d0fcad9a82b96f99035254af50c7a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 31 16:09:14 2013 +0200

    Define LXC_DEFAULT_CONFIG
    
    And use it in place of the various ways we were deducing /etc/lxc/default.conf.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 24b6008..61e1327 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1158,9 +1158,6 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 	return ret;
 }
 
-
-/* default config file - should probably come through autoconf */
-#define LXC_DEFAULT_CONFIG "/etc/lxc/default.conf"
 static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	FILE *fout;

commit 3bc449ed24edc4b754cbe0af19fe878d29731f59
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 31 07:55:14 2013 -0500

    lxccontainer: update locking comment
    
    Update the LOCKING comment.
    
    Take mem_lock in want_daemonize.
    
    convert lxcapi_destroy to not use privlock/slock by hand.
    
    Fix a coverity-found potential dereference of NULL c->lxc_conf.
    
    api_cgroup_get_item() and api_cgroup_set_item(): use disklock,
    not memlock, since the values are set through the cgroup fs on
    the running container.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9bc1caf..24b6008 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -145,11 +145,11 @@ void remove_partial(struct lxc_container *c, int fd)
 }
 
 /* LOCKING
- * 1. c->privlock protects the struct lxc_container from multiple threads.
- * 2. c->slock protects the on-disk container data
- * 3. thread_mutex protects process data (ex: fd table) from multiple threads
- * slock is an flock, which does not exclude threads.  Therefore slock should
- * always be wrapped inside privlock.
+ * 1. container_mem_lock(c) protects the struct lxc_container from multiple threads.
+ * 2. container_disk_lock(c) protects the on-disk container data - in particular the
+ *    container configuration file.
+ *    The container_disk_lock also takes the container_mem_lock.
+ * 3. thread_mutex protects process data (ex: fd table) from multiple threads.
  * NOTHING mutexes two independent programs with their own struct
  * lxc_container for the same c->name, between API calls.  For instance,
  * c->config_read(); c->start();  Between those calls, data on disk
@@ -160,7 +160,7 @@ void remove_partial(struct lxc_container *c, int fd)
  * due to hung callers.  So I prefer to keep the locks only within our own
  * functions, not across functions.
  *
- * If you're going to fork while holding a lxccontainer, increment
+ * If you're going to clone while holding a lxccontainer, increment
  * c->numthreads (under privlock) before forking.  When deleting,
  * decrement numthreads under privlock, then if it hits 0 you can delete.
  * Do not ever use a lxccontainer whose numthreads you did not bump.
@@ -406,7 +406,12 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 {
 	if (!c)
 		return;
+	if (!container_mem_lock(c)) {
+		ERROR("Error getting mem lock");
+		return;
+	}
 	c->daemonize = 1;
+	container_mem_unlock(c);
 }
 
 static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
@@ -1218,12 +1223,8 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	if (!c || !lxcapi_is_defined(c))
 		return false;
 
-	if (lxclock(c->privlock, 0))
-		return false;
-	if (lxclock(c->slock, 0)) {
-		lxcunlock(c->privlock);
+	if (container_disk_lock(c))
 		return false;
-	}
 
 	if (!is_stopped(c)) {
 		// we should queue some sort of error - in c->error_string?
@@ -1231,7 +1232,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	if (c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount)
+	if (c->lxc_conf && c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount)
 		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (r) {
 		if (r->ops->destroy(r) < 0) {
@@ -1250,8 +1251,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	ret = true;
 
 out:
-	lxcunlock(c->privlock);
-	lxcunlock(c->slock);
+	container_disk_unlock(c);
 	return ret;
 }
 
@@ -1374,42 +1374,38 @@ err:
 static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
 {
 	int ret;
-	bool b = false;
 
 	if (!c)
 		return false;
 
-	if (container_mem_lock(c))
+	if (is_stopped(c))
 		return false;
 
-	if (is_stopped(c))
-		goto err;
+	if (container_disk_lock(c))
+		return false;
 
-	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
-	if (!ret)
-		b = true;
-err:
-	container_mem_unlock(c);
-	return b;
+	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path) == 0;
+
+	container_disk_unlock(c);
+	return ret == 0;
 }
 
 static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
 {
-	int ret = -1;
+	int ret;
 
 	if (!c || !c->lxc_conf)
 		return -1;
 
-	if (container_mem_lock(c))
+	if (is_stopped(c))
 		return -1;
 
-	if (is_stopped(c))
-		goto out;
+	if (container_disk_lock(c))
+		return -1;
 
 	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);
 
-out:
-	container_mem_unlock(c);
+	container_disk_unlock(c);
 	return ret;
 }
 

commit 39dc698cb4025516a3428a68e19da05feb6fc0e9
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed May 29 12:26:25 2013 -0500

    lxccontainer: don't lock around getstate and freeze/unfreeze (v2)
    
    Those go through commands.c and are already mutex'ed that way.
    
    Also remove a unmatched container_disk_unlock in lxcapi_create.
    
    Since is_stopped uses getstate which is no longer locked, rename
    it to drop the _locked suffix.
    
    And convert save_config to taking the disk lock.  This way the
    save_ and load_config are mutexing each other, as they should.
    
    Changelog: May 29:
       Per Dwight's comment, take the lock before opening the config
          FILE *.
       Only take disklock at load and save_config when we're using the
       container's config file, not when read/writing from/to another
       file.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5a9cdf1..9bc1caf 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -287,21 +287,15 @@ out:
 
 static const char *lxcapi_state(struct lxc_container *c)
 {
-	const char *ret;
 	lxc_state_t s;
 
 	if (!c)
 		return NULL;
-	if (container_disk_lock(c))
-		return NULL;
 	s = lxc_getstate(c->name, c->config_path);
-	ret = lxc_state2str(s);
-	container_disk_unlock(c);
-
-	return ret;
+	return lxc_state2str(s);
 }
 
-static bool is_stopped_locked(struct lxc_container *c)
+static bool is_stopped(struct lxc_container *c)
 {
 	lxc_state_t s;
 	s = lxc_getstate(c->name, c->config_path);
@@ -326,10 +320,7 @@ static bool lxcapi_freeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (container_disk_lock(c))
-		return false;
 	ret = lxc_freeze(c->name, c->config_path);
-	container_disk_unlock(c);
 	if (ret)
 		return false;
 	return true;
@@ -341,10 +332,7 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (container_disk_lock(c))
-		return false;
 	ret = lxc_unfreeze(c->name, c->config_path);
-	container_disk_unlock(c);
 	if (ret)
 		return false;
 	return true;
@@ -379,7 +367,8 @@ static bool load_config_locked(struct lxc_container *c, const char *fname)
 
 static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 {
-	bool ret = false;
+	bool ret = false, need_disklock = false;
+	int lret;
 	const char *fname;
 	if (!c)
 		return false;
@@ -389,10 +378,27 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 		fname = alt_file;
 	if (!fname)
 		return false;
-	if (container_disk_lock(c))
+	/*
+	 * If we're reading something other than the container's config,
+	 * we only need to lock the in-memory container.  If loading the
+	 * container's config file, take the disk lock.
+	 */
+	if (strcmp(fname, c->configfile) == 0)
+		need_disklock = true;
+
+	if (need_disklock)
+		lret = container_disk_lock(c);
+	else
+		lret = container_mem_lock(c);
+	if (lret)
 		return false;
+
 	ret = load_config_locked(c, fname);
-	container_disk_unlock(c);
+
+	if (need_disklock)
+		container_disk_unlock(c);
+	else
+		container_mem_unlock(c);
 	return ret;
 }
 
@@ -898,7 +904,6 @@ static bool lxcapi_create(struct lxc_container *c, const char *t,
 out_unlock:
 	if (partial_fd >= 0)
 		remove_partial(c, partial_fd);
-	container_disk_unlock(c);
 out:
 	if (tpath)
 		free(tpath);
@@ -1153,30 +1158,55 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 #define LXC_DEFAULT_CONFIG "/etc/lxc/default.conf"
 static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
+	FILE *fout;
+	bool ret = false, need_disklock = false;
+	int lret;
+
 	if (!alt_file)
 		alt_file = c->configfile;
 	if (!alt_file)
 		return false;  // should we write to stdout if no file is specified?
-	if (!c->lxc_conf)
+
+	// If we haven't yet loaded a config, load the stock config
+	if (!c->lxc_conf) {
 		if (!c->load_config(c, LXC_DEFAULT_CONFIG)) {
 			ERROR("Error loading default configuration file %s while saving %s\n", LXC_DEFAULT_CONFIG, c->name);
 			return false;
 		}
+	}
 
 	if (!create_container_dir(c))
 		return false;
 
-	FILE *fout = fopen(alt_file, "w");
-	if (!fout)
-		return false;
-	if (container_mem_lock(c)) {
-		fclose(fout);
+	/*
+	 * If we're writing to the container's config file, take the
+	 * disk lock.  Otherwise just take the memlock to protect the
+	 * struct lxc_container while we're traversing it.
+	 */
+	if (strcmp(c->configfile, alt_file) == 0)
+		need_disklock = true;
+
+	if (need_disklock)
+		lret = container_disk_lock(c);
+	else
+		lret = container_mem_lock(c);
+
+	if (lret)
 		return false;
-	}
+
+	fout = fopen(alt_file, "w");
+	if (!fout)
+		goto out;
 	write_config(fout, c->lxc_conf);
 	fclose(fout);
-	container_mem_unlock(c);
-	return true;
+	ret = true;
+
+out:
+	if (need_disklock)
+		container_disk_unlock(c);
+	else
+		container_mem_unlock(c);
+	return ret;
 }
 
 // do we want the api to support --force, or leave that to the caller?
@@ -1195,7 +1225,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		return false;
 	}
 
-	if (!is_stopped_locked(c)) {
+	if (!is_stopped(c)) {
 		// we should queue some sort of error - in c->error_string?
 		ERROR("container %s is not stopped", c->name);
 		goto out;
@@ -1352,7 +1382,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (container_mem_lock(c))
 		return false;
 
-	if (is_stopped_locked(c))
+	if (is_stopped(c))
 		goto err;
 
 	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
@@ -1373,7 +1403,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	if (container_mem_lock(c))
 		return -1;
 
-	if (is_stopped_locked(c))
+	if (is_stopped(c))
 		goto out;
 
 	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);
@@ -1837,7 +1867,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (container_mem_lock(c))
 		return NULL;
 
-	if (!is_stopped_locked(c)) {
+	if (!is_stopped(c)) {
 		ERROR("error: Original container (%s) is running", c->name);
 		goto out;
 	}

commit 0115f8fd27b1a31d367bb161a121694f92b45e62
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue May 28 15:25:41 2013 -0400

    add console to lxc api
    
    Make lxc_cmd_console() return the fd from the socket connection to the
    caller. This fd keeps the tty slot allocated until the caller closes
    it. Returning the fd allows for a long lived process to close the fd
    and reuse consoles.
    
    Add API function for console allocation.
    
    Create test program for console API.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index b34b8e8..5a9cdf1 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -350,6 +350,16 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	return true;
 }
 
+static int lxcapi_console(struct lxc_container *c, int *ttynum, int *masterfd)
+{
+	int ttyfd;
+	if (!c)
+		return -1;
+
+	ttyfd = lxc_cmd_console(c->name, ttynum, masterfd, c->config_path);
+	return ttyfd;
+}
+
 static pid_t lxcapi_init_pid(struct lxc_container *c)
 {
 	if (!c)
@@ -1979,6 +1989,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->is_running = lxcapi_is_running;
 	c->freeze = lxcapi_freeze;
 	c->unfreeze = lxcapi_unfreeze;
+	c->console = lxcapi_console;
 	c->init_pid = lxcapi_init_pid;
 	c->load_config = lxcapi_load_config;
 	c->want_daemonize = lxcapi_want_daemonize;

commit 5790f7b7a76b9ccff662fdd6ff0013b8f218d020
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 28 15:27:42 2013 -0500

    api_clone: call is_stopped_locked() to avoid deadlock.
    
    Technically as Dwight has mentioned we should probably drop the locking
    from api_state() altogether, since those are protected through the
    lxc command system.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2ea9556..b34b8e8 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1827,7 +1827,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (container_mem_lock(c))
 		return NULL;
 
-	if (c->is_running(c)) {
+	if (!is_stopped_locked(c)) {
 		ERROR("error: Original container (%s) is running", c->name);
 		goto out;
 	}

commit 1897e3bcd36af9f3fe6d3649910a9adb93e5e988
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 17 23:23:17 2013 +0200

    Move container creation fully into the api
    
    1. implement bdev->create:
    
    python and lua: send NULL for bdevtype and bdevspecs.
    They'll want to be updated to pass those in in a way that makes
    sense, but I can't think about that right now.
    
    2. templates: pass --rootfs
    
    If the container is backed by a device which must be mounted (i.e.
    lvm) then pass the actual rootfs mount destination to the
    templates.
    
    Note that the lxc.rootfs can be a mounted block device.  The template
    should actually be installing the rootfs under the path where the
    lxc.rootfs is *mounted*.
    
    Still, some people like to run templates by hand and assume purely
    directory backed containers, so continue to support that use case
    (i.e. if no --rootfs is listed).
    
    Make sure the templates don't re-write lxc.rootfs if it is
    already in the config.  (Most were already checking for that)
    
    3. Replace lxc-create script with lxc_create.c program.
    
    Changelog:
    May 24: when creating a container, create $lxcpath/$name/partial,
    and flock it.  When done, close that file and unlink it.  In
    lxc_container_new() and lxcapi_start(), check for this file.  If
    it is locked, create is ongoing.  If it exists but is not locked,
    create() was killed - remove the container.
    
    May 24: dont disk-lock during lxcapi_create.  The partial lock
    is sufficient.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1d11742..2ea9556 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -106,7 +106,7 @@ int create_partial(struct lxc_container *c)
 		ERROR("Error writing partial pathname");
 		return -1;
 	}
-	if (process_lock() < 0)
+	if (process_lock())
 		return -1;
 	if ((fd=open(path, O_CREAT | O_EXCL, 0755)) < 0) {
 		SYSERROR("Erorr creating partial file");
@@ -645,12 +645,54 @@ static bool create_container_dir(struct lxc_container *c)
 	return ret == 0;
 }
 
+static const char *lxcapi_get_config_path(struct lxc_container *c);
+static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v);
+
 /*
- * backing stores not (yet) supported
- * for ->create, argv contains the arguments to pass to the template,
- * terminated by NULL.  If no arguments, you can just pass NULL.
+ * do_bdev_create: thin wrapper around bdev_create().  Like bdev_create(),
+ * it returns a mounted bdev on success, NULL on error.
  */
-static bool lxcapi_create(struct lxc_container *c, const char *t, char *const argv[])
+static struct bdev *do_bdev_create(struct lxc_container *c, const char *type,
+			 struct bdev_specs *specs)
+{
+	char *dest;
+	const char *lxcpath = lxcapi_get_config_path(c);
+	size_t len;
+	struct bdev *bdev;
+	int ret;
+
+	/* lxcpath/lxcname/rootfs */
+	len = strlen(c->name) + strlen(lxcpath) + 9;
+	dest = alloca(len);
+	ret = snprintf(dest, len, "%s/%s/rootfs", lxcpath, c->name);
+	if (ret < 0 || ret >= len)
+		return NULL;
+
+	bdev = bdev_create(dest, type, c->name, specs);
+	if (!bdev)
+		return NULL;
+	lxcapi_set_config_item(c, "lxc.rootfs", bdev->src);
+	return bdev;
+}
+
+static bool lxcapi_destroy(struct lxc_container *c);
+/*
+ * lxcapi_create:
+ * create a container with the given parameters.
+ * @c: container to be created.  It has the lxcpath, name, and a starting
+ *     configuration already set
+ * @t: the template to execute to instantiate the root filesystem and
+ *     adjust the configuration.
+ * @bdevtype: backing store type to use.  If NULL, dir will be used.
+ * @specs: additional parameters for the backing store, i.e. LVM vg to
+ *         use.
+ *
+ * @argv: the arguments to pass to the template, terminated by NULL.  If no
+ * arguments, you can just pass NULL.
+ */
+static bool lxcapi_create(struct lxc_container *c, const char *t,
+		const char *bdevtype, struct bdev_specs *specs,
+		char *const argv[])
 {
 	bool bret = false;
 	pid_t pid;
@@ -685,12 +727,53 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	if ((partial_fd = create_partial(c)) < 0)
 		goto out;
 
-	/* we're going to fork.  but since we'll wait for our child, we
-	 * don't need to lxc_container_get */
+	/* no need to get disk lock bc we have the partial locked */
 
-	if (container_disk_lock(c))
+	/*
+	 * Create the backing store
+	 * Note we can't do this in the same task as we use to execute the
+	 * template because of the way zfs works.
+	 * After you 'zfs create', zfs mounts the fs only in the initial
+	 * namespace.
+	 */
+	pid = fork();
+	if (pid < 0) {
+		SYSERROR("failed to fork task for container creation template\n");
+		goto out_unlock;
+	}
+
+	if (pid == 0) { // child
+		struct bdev *bdev = NULL;
+
+		if (!(bdev = do_bdev_create(c, bdevtype, specs))) {
+			ERROR("Error creating backing store type %s for %s",
+				bdevtype ? bdevtype : "(none)", c->name);
+			exit(1);
+		}
+
+		/* save config file again to store the new rootfs location */
+		if (!c->save_config(c, NULL)) {
+			ERROR("failed to save starting configuration for %s\n", c->name);
+			// parent task won't see bdev in config so we delete it
+			bdev->ops->umount(bdev);
+			bdev->ops->destroy(bdev);
+			exit(1);
+		}
+		exit(0);
+	}
+	if (wait_for_pid(pid) != 0)
+		goto out;
+
+	/* reload config to get the rootfs */
+	if (c->lxc_conf)
+		lxc_conf_free(c->lxc_conf);
+	c->lxc_conf = NULL;
+	if (!load_config_locked(c, c->configfile))
 		goto out;
 
+	/*
+	 * now execute the template
+	 */
 	pid = fork();
 	if (pid < 0) {
 		SYSERROR("failed to fork task for container creation template\n");
@@ -698,7 +781,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	}
 
 	if (pid == 0) { // child
-		char *patharg, *namearg;
+		char *patharg, *namearg, *rootfsarg, *src;
+		struct bdev *bdev = NULL;
 		int i;
 
 		close(0);
@@ -708,13 +792,38 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 		open("/dev/null", O_RDWR);
 		open("/dev/null", O_RDWR);
 
+		if (unshare(CLONE_NEWNS) < 0) {
+			ERROR("error unsharing mounts");
+			exit(1);
+		}
+
+		src = c->lxc_conf->rootfs.path;
+		/*
+		 * for an overlayfs create, what the user wants is the template to fill
+		 * in what will become the readonly lower layer.  So don't mount for
+		 * the template
+		 */
+		if (strncmp(src, "overlayfs:", 10) == 0) {
+			src = overlayfs_getlower(src+10);
+		}
+		bdev = bdev_init(src, c->lxc_conf->rootfs.mount, NULL);
+		if (!bdev) {
+			ERROR("Error opening rootfs");
+			exit(1);
+		}
+
+		if (bdev->ops->mount(bdev) < 0) {
+			ERROR("Error mounting rootfs");
+			exit(1);
+		}
+
 		/*
 		 * create our new array, pre-pend the template name and
 		 * base args
 		 */
 		if (argv)
-			for (; argv[nargs]; nargs++) ;
-		nargs += 3;  // template, path and name args
+			for (nargs = 0; argv[nargs]; nargs++) ;
+		nargs += 4;  // template, path, rootfs and name args
 		newargv = malloc(nargs * sizeof(*newargv));
 		if (!newargv)
 			exit(1);
@@ -737,10 +846,19 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 			exit(1);
 		newargv[2] = namearg;
 
+		len = strlen("--rootfs=") + 1 + strlen(bdev->dest);
+		rootfsarg = malloc(len);
+		if (!rootfsarg)
+			exit(1);
+		ret = snprintf(rootfsarg, len, "--rootfs=%s", bdev->dest);
+		if (ret < 0 || ret >= len)
+			exit(1);
+		newargv[3] = rootfsarg;
+
 		/* add passed-in args */
 		if (argv)
-			for (i = 3; i < nargs; i++)
-				newargv[i] = argv[i-3];
+			for (i = 4; i < nargs; i++)
+				newargv[i] = argv[i-4];
 
 		/* add trailing NULL */
 		nargs++;
@@ -774,6 +892,8 @@ out_unlock:
 out:
 	if (tpath)
 		free(tpath);
+	if (!bret && c)
+		lxcapi_destroy(c);
 	return bret;
 }
 
@@ -818,7 +938,8 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	return retv;
 }
 
-static bool lxcapi_createl(struct lxc_container *c, const char *t, ...)
+static bool lxcapi_createl(struct lxc_container *c, const char *t,
+		const char *bdevtype, struct bdev_specs *specs, ...)
 {
 	bool bret = false;
 	char **args = NULL, **temp;
@@ -832,7 +953,7 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t, ...)
 	 * since we're going to wait for create to finish, I don't think we
 	 * need to get a copy of the arguments.
 	 */
-	va_start(ap, t);
+	va_start(ap, specs);
 	while (1) {
 		char *arg;
 		arg = va_arg(ap, char *);
@@ -851,7 +972,7 @@ static bool lxcapi_createl(struct lxc_container *c, const char *t, ...)
 	if (args)
 		args[nargs] = NULL;
 
-	bret = c->create(c, t, args);
+	bret = c->create(c, t, bdevtype, specs, args);
 
 out:
 	if (args)
@@ -1048,15 +1169,13 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	return true;
 }
 
-static const char *lxcapi_get_config_path(struct lxc_container *c);
 // do we want the api to support --force, or leave that to the caller?
 static bool lxcapi_destroy(struct lxc_container *c)
 {
-	struct bdev *r;
+	struct bdev *r = NULL;
 	bool ret = false;
 
-	/* container is already destroyed if we don't have a config and rootfs.path is not accessible */
-	if (!c || !lxcapi_is_defined(c) || !c->lxc_conf || !c->lxc_conf->rootfs.path)
+	if (!c || !lxcapi_is_defined(c))
 		return false;
 
 	if (lxclock(c->privlock, 0))
@@ -1072,7 +1191,8 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		goto out;
 	}
 
-	r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	if (c->lxc_conf->rootfs.path && c->lxc_conf->rootfs.mount)
+		r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
 	if (r) {
 		if (r->ops->destroy(r) < 0) {
 			ERROR("Error destroying rootfs for %s", c->name);
@@ -1848,8 +1968,9 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 
 	if (ongoing_create(c) == 2) {
 		ERROR("Error: %s creation was not completed", c->name);
-		c->destroy(c);
-		goto err;
+		lxcapi_destroy(c);
+		lxc_conf_free(c->lxc_conf);
+		c->lxc_conf = NULL;
 	}
 
 	// assign the member functions

commit 60bf62d4ae36a48342fb8aee680fbd4b423810b1
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 17 07:20:10 2013 +0200

    destroy: implement in the api
    
    This requires implementing bdev->ops->destroy() for each of the backing
    store types.  Then implementing lxcapi_clone(), writing lxc_destroy.c
    using the api, and removing the lxc-destroy.in script.
    
    (this also has a few other cleanups, like marking some functions
    static)
    
    Changelog:
    	fold into destroy: fix zfs destroy
    	destroy: use correct program name in help
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a1c156c..1d11742 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -301,7 +301,7 @@ static const char *lxcapi_state(struct lxc_container *c)
 	return ret;
 }
 
-static bool is_stopped_nolock(struct lxc_container *c)
+static bool is_stopped_locked(struct lxc_container *c)
 {
 	lxc_state_t s;
 	s = lxc_getstate(c->name, c->config_path);
@@ -1048,32 +1048,51 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	return true;
 }
 
+static const char *lxcapi_get_config_path(struct lxc_container *c);
+// do we want the api to support --force, or leave that to the caller?
 static bool lxcapi_destroy(struct lxc_container *c)
 {
-	pid_t pid;
-
-	if (!c)
-		return false;
+	struct bdev *r;
+	bool ret = false;
 
 	/* container is already destroyed if we don't have a config and rootfs.path is not accessible */
-	if (!lxcapi_is_defined(c) && (!c->lxc_conf || !c->lxc_conf->rootfs.path || access(c->lxc_conf->rootfs.path, F_OK) != 0))
+	if (!c || !lxcapi_is_defined(c) || !c->lxc_conf || !c->lxc_conf->rootfs.path)
 		return false;
 
-	pid = fork();
-	if (pid < 0)
+	if (lxclock(c->privlock, 0))
+		return false;
+	if (lxclock(c->slock, 0)) {
+		lxcunlock(c->privlock);
 		return false;
-	if (pid == 0) { // child
-		execlp("lxc-destroy", "lxc-destroy", "-n", c->name, "-P", c->config_path, NULL);
-		perror("execl");
-		exit(1);
 	}
 
-	if (wait_for_pid(pid) < 0) {
-		ERROR("Error destroying container %s", c->name);
-		return false;
+	if (!is_stopped_locked(c)) {
+		// we should queue some sort of error - in c->error_string?
+		ERROR("container %s is not stopped", c->name);
+		goto out;
 	}
 
-	return true;
+	r = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	if (r) {
+		if (r->ops->destroy(r) < 0) {
+			ERROR("Error destroying rootfs for %s", c->name);
+			goto out;
+		}
+	}
+
+	const char *p1 = lxcapi_get_config_path(c);
+	char *path = alloca(strlen(p1) + strlen(c->name) + 2);
+	sprintf(path, "%s/%s", p1, c->name);
+	if (lxc_rmdir_onedev(path) < 0) {
+		ERROR("Error destroying container directory for %s", c->name);
+		goto out;
+	}
+	ret = true;
+
+out:
+	lxcunlock(c->privlock);
+	lxcunlock(c->slock);
+	return ret;
 }
 
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
@@ -1203,7 +1222,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (container_mem_lock(c))
 		return false;
 
-	if (is_stopped_nolock(c))
+	if (is_stopped_locked(c))
 		goto err;
 
 	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
@@ -1224,7 +1243,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	if (container_mem_lock(c))
 		return -1;
 
-	if (is_stopped_nolock(c))
+	if (is_stopped_locked(c))
 		goto out;
 
 	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);

commit 3e625e2d2e12b919dd9590b97badc6108ee67b1a
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu May 16 23:03:47 2013 +0200

    lxc-stop: use api, remove lxc_shutdown, extend lxc-stop functionality
    
    implement c->reboot(c) in the api.
    
    Also if the container is not running, return -2.  Currently
    lxc-stop will return 0, so you cannot tell the difference
    between successfull stopping and noop.
    
    Per stgraber's email:
    
     - Remove lxc-shutdown
     - Change lxc-stop so that:
       * Default behaviour is to call shutdown(), wait 15s for STOPPED, if
    not STOPPED, print a message to the user and call stop() [ NOTE:
    actually 60 seconds per followup thread]
       * We have a -r option to reboot the container (with proper check that
    the container indeed rebooted within the next 15s)
       * We have a -s option to shutdown the container without the automatic
    fallback to stop()
       * Add a -k option allowing a user to just kill a container
    (equivalent to old lxc-stop, no shutdown() call and no delay).
    
    and update manpages.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2a45c1f..a1c156c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -45,6 +45,105 @@
 
 lxc_log_define(lxc_container, lxc);
 
+static bool file_exists(char *f)
+{
+	struct stat statbuf;
+
+	return stat(f, &statbuf) == 0;
+}
+
+/*
+ * A few functions to help detect when a container creation failed.
+ * If a container creation was killed partway through, then trying
+ * to actually start that container could harm the host.  We detect
+ * this by creating a 'partial' file under the container directory,
+ * and keeping an advisory lock.  When container creation completes,
+ * we remove that file.  When we load or try to start a container, if
+ * we find that file, without a flock, we remove the container.
+ */
+int ongoing_create(struct lxc_container *c)
+{
+	int len = strlen(c->config_path) + strlen(c->name) + 10;
+	char *path = alloca(len);
+	int fd, ret;
+	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
+	if (ret < 0 || ret >= len) {
+		ERROR("Error writing partial pathname");
+		return -1;
+	}
+
+	if (!file_exists(path))
+		return 0;
+	if (process_lock())
+		return -1;
+	if ((fd = open(path, O_RDWR)) < 0) {
+		// give benefit of the doubt
+		SYSERROR("Error opening partial file");
+		process_unlock();
+		return 0;
+	}
+	if ((ret = flock(fd, LOCK_EX | LOCK_NB)) == -1 &&
+			errno == EWOULDBLOCK) {
+		// create is still ongoing
+		close(fd);
+		process_unlock();
+		return 1;
+	}
+	// create completed but partial is still there.
+	close(fd);
+	process_unlock();
+	return 2;
+}
+
+int create_partial(struct lxc_container *c)
+{
+	// $lxcpath + '/' + $name + '/partial' + \0
+	int len = strlen(c->config_path) + strlen(c->name) + 10;
+	char *path = alloca(len);
+	int fd, ret;
+	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
+	if (ret < 0 || ret >= len) {
+		ERROR("Error writing partial pathname");
+		return -1;
+	}
+	if (process_lock() < 0)
+		return -1;
+	if ((fd=open(path, O_CREAT | O_EXCL, 0755)) < 0) {
+		SYSERROR("Erorr creating partial file");
+		process_unlock();
+		return -1;
+	}
+	if (flock(fd, LOCK_EX) < 0) {
+		SYSERROR("Error locking partial file %s", path);
+		close(fd);
+		process_unlock();
+		return -1;
+	}
+	process_unlock();
+
+	return fd;
+}
+
+void remove_partial(struct lxc_container *c, int fd)
+{
+	// $lxcpath + '/' + $name + '/partial' + \0
+	int len = strlen(c->config_path) + strlen(c->name) + 10;
+	char *path = alloca(len);
+	int ret;
+
+	close(fd);
+	ret = snprintf(path, len, "%s/%s/partial", c->config_path, c->name);
+	if (ret < 0 || ret >= len) {
+		ERROR("Error writing partial pathname");
+		return;
+	}
+	if (process_lock())
+		return;
+	if (unlink(path) < 0)
+		SYSERROR("Error unlink partial file %s", path);
+	process_unlock();
+}
+
 /* LOCKING
  * 1. c->privlock protects the struct lxc_container from multiple threads.
  * 2. c->slock protects the on-disk container data
@@ -163,13 +262,6 @@ int lxc_container_put(struct lxc_container *c)
 	return 0;
 }
 
-static bool file_exists(char *f)
-{
-	struct stat statbuf;
-
-	return stat(f, &statbuf) == 0;
-}
-
 static bool lxcapi_is_defined(struct lxc_container *c)
 {
 	struct stat statbuf;
@@ -349,6 +441,19 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	if (!c->lxc_conf)
 		return false;
 
+	if ((ret = ongoing_create(c)) < 0) {
+		ERROR("Error checking for incomplete creation");
+		return false;
+	}
+	if (ret == 2) {
+		ERROR("Error: %s creation was not completed", c->name);
+		c->destroy(c);
+		return false;
+	} else if (ret == 1) {
+		ERROR("Error: creation of %s is ongoing", c->name);
+		return false;
+	}
+
 	/* is this app meant to be run through lxcinit, as in lxc-execute? */
 	if (useinit && !argv)
 		return false;
@@ -550,7 +655,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	bool bret = false;
 	pid_t pid;
 	char *tpath = NULL, **newargv;
-	int ret, len, nargs = 0;
+	int partial_fd, ret, len, nargs = 0;
 
 	if (!c)
 		return false;
@@ -576,6 +681,10 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0)
 		goto out;
 
+	/* Mark that this container is being created */
+	if ((partial_fd = create_partial(c)) < 0)
+		goto out;
+
 	/* we're going to fork.  but since we'll wait for our child, we
 	 * don't need to lxc_container_get */
 
@@ -659,6 +768,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	bret = load_config_locked(c, c->configfile);
 
 out_unlock:
+	if (partial_fd >= 0)
+		remove_partial(c, partial_fd);
 	container_disk_unlock(c);
 out:
 	if (tpath)
@@ -666,6 +777,23 @@ out:
 	return bret;
 }
 
+static bool lxcapi_reboot(struct lxc_container *c)
+{
+	pid_t pid;
+
+	if (!c)
+		return false;
+	if (!c->is_running(c))
+		return false;
+	pid = c->init_pid(c);
+	if (pid <= 0)
+		return false;
+	if (kill(pid, SIGINT) < 0)
+		return false;
+	return true;
+
+}
+
 static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 {
 	bool retv;
@@ -1699,6 +1827,12 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	if (file_exists(c->configfile))
 		lxcapi_load_config(c, NULL);
 
+	if (ongoing_create(c) == 2) {
+		ERROR("Error: %s creation was not completed", c->name);
+		c->destroy(c);
+		goto err;
+	}
+
 	// assign the member functions
 	c->is_defined = lxcapi_is_defined;
 	c->state = lxcapi_state;
@@ -1720,6 +1854,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->create = lxcapi_create;
 	c->createl = lxcapi_createl;
 	c->shutdown = lxcapi_shutdown;
+	c->reboot = lxcapi_reboot;
 	c->clear_config_item = lxcapi_clear_config_item;
 	c->get_config_item = lxcapi_get_config_item;
 	c->get_cgroup_item = lxcapi_get_cgroup_item;

commit 5cee8c5040661f9875bf41cfffd641c87afae8af
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri May 24 16:03:22 2013 -0500

    locking: update per Dwight's comment
    
    Create three pairs of functions:
    	int process_lock(void);
    	void process_unlock(void);
    	int container_mem_lock(struct lxc_container *c)
    	void container_mem_unlock(struct lxc_container *c)
    	int container_disk_lock(struct lxc_container *c);
    	void container_disk_unlock(struct lxc_container *c);
    
    and use those in lxccontainer.c
    
    process_lock() is to protect the process state among multiple threads.
    container_mem_lock() is to protect a struct container among multiple
    threads.  container_disk_lock is to protect a container on disk.
    
    Also remove the lock in lxcapi_init_pid() as Dwight suggested.
    
    Fix a typo (s/container/contain) spotted by Dwight.
    
    More locking fixes are needed, but let's first the the fundamentals
    right.  How close does this get us?
    
    Changelog: v2:
    	fix lxclock compile
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 0ec23e8..2a45c1f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -43,8 +43,6 @@
 #include <arpa/inet.h>
 #include <ifaddrs.h>
 
-extern pthread_mutex_t thread_mutex;
-
 lxc_log_define(lxc_container, lxc);
 
 /* LOCKING
@@ -138,7 +136,7 @@ int lxc_container_get(struct lxc_container *c)
 	if (c->numthreads < 1)
 		return 0;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return 0;
 	if (c->numthreads < 1) {
 		// bail without trying to unlock, bc the privlock is now probably
@@ -146,7 +144,7 @@ int lxc_container_get(struct lxc_container *c)
 		return 0;
 	}
 	c->numthreads++;
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return 1;
 }
 
@@ -154,14 +152,14 @@ int lxc_container_put(struct lxc_container *c)
 {
 	if (!c)
 		return -1;
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return -1;
 	if (--c->numthreads < 1) {
-		lxcunlock(c->privlock);
+		container_mem_unlock(c);
 		lxc_container_free(c);
 		return 1;
 	}
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return 0;
 }
 
@@ -181,7 +179,7 @@ static bool lxcapi_is_defined(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return false;
 	if (!c->configfile)
 		goto out;
@@ -191,7 +189,7 @@ static bool lxcapi_is_defined(struct lxc_container *c)
 	ret = true;
 
 out:
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return ret;
 }
 
@@ -202,15 +200,11 @@ static const char *lxcapi_state(struct lxc_container *c)
 
 	if (!c)
 		return NULL;
-	if (lxclock(c->privlock, 0))
+	if (container_disk_lock(c))
 		return NULL;
-	if (lxclock(c->slock, 0))
-		goto bad;
 	s = lxc_getstate(c->name, c->config_path);
 	ret = lxc_state2str(s);
-	lxcunlock(c->slock);
-bad:
-	lxcunlock(c->privlock);
+	container_disk_unlock(c);
 
 	return ret;
 }
@@ -240,15 +234,10 @@ static bool lxcapi_freeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (lxclock(c->privlock, 0))
-		return false;
-	if (lxclock(c->slock, 0)) {
-		lxcunlock(c->privlock);
+	if (container_disk_lock(c))
 		return false;
-	}
 	ret = lxc_freeze(c->name, c->config_path);
-	lxcunlock(c->slock);
-	lxcunlock(c->privlock);
+	container_disk_unlock(c);
 	if (ret)
 		return false;
 	return true;
@@ -260,15 +249,10 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (lxclock(c->privlock, 0))
-		return false;
-	if (lxclock(c->slock, 0)) {
-		lxcunlock(c->privlock);
+	if (container_disk_lock(c))
 		return false;
-	}
 	ret = lxc_unfreeze(c->name, c->config_path);
-	lxcunlock(c->slock);
-	lxcunlock(c->privlock);
+	container_disk_unlock(c);
 	if (ret)
 		return false;
 	return true;
@@ -276,20 +260,10 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 
 static pid_t lxcapi_init_pid(struct lxc_container *c)
 {
-	pid_t ret;
 	if (!c)
 		return -1;
 
-	if (lxclock(c->privlock, 0))
-		return -1;
-	if (lxclock(c->slock, 0)) {
-		lxcunlock(c->privlock);
-		return -1;
-	}
-	ret = lxc_cmd_get_init_pid(c->name, c->config_path);
-	lxcunlock(c->slock);
-	lxcunlock(c->privlock);
-	return ret;
+	return lxc_cmd_get_init_pid(c->name, c->config_path);
 }
 
 static bool load_config_locked(struct lxc_container *c, const char *fname)
@@ -313,15 +287,10 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 		fname = alt_file;
 	if (!fname)
 		return false;
-	if (lxclock(c->privlock, 0))
-		return false;
-	if (lxclock(c->slock, 0)) {
-		lxcunlock(c->privlock);
+	if (container_disk_lock(c))
 		return false;
-	}
 	ret = load_config_locked(c, fname);
-	lxcunlock(c->slock);
-	lxcunlock(c->privlock);
+	container_disk_unlock(c);
 	return ret;
 }
 
@@ -384,11 +353,11 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	if (useinit && !argv)
 		return false;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return false;
 	conf = c->lxc_conf;
 	daemonize = c->daemonize;
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 
 	if (useinit) {
 		ret = lxc_execute(c->name, argv, 1, conf, c->config_path);
@@ -409,23 +378,20 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 			return false;
 		lxc_monitord_spawn(c->config_path);
 
-		ret = pthread_mutex_lock(&thread_mutex);
-		if (ret != 0) {
-			ERROR("pthread_mutex_lock returned:%d %s", ret, strerror(ret));
+		if (process_lock())
 			return false;
-		}
 		pid_t pid = fork();
 		if (pid < 0) {
 			lxc_container_put(c);
-			pthread_mutex_unlock(&thread_mutex);
+			process_unlock();
 			return false;
 		}
 		if (pid != 0) {
 			ret = wait_on_daemonized_start(c);
-			pthread_mutex_unlock(&thread_mutex);
+			process_unlock();
 			return ret;
 		}
-		pthread_mutex_unlock(&thread_mutex);
+		process_unlock();
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {
@@ -613,13 +579,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	/* we're going to fork.  but since we'll wait for our child, we
 	 * don't need to lxc_container_get */
 
-	if (lxclock(c->privlock, 0))
+	if (container_disk_lock(c))
 		goto out;
-	if (lxclock(c->slock, 0)) {
-		ERROR("failed to grab global container lock for %s\n", c->name);
-		lxcunlock(c->privlock);
-		goto out_unlock1;
-	}
 
 	pid = fork();
 	if (pid < 0) {
@@ -698,9 +659,7 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	bret = load_config_locked(c, c->configfile);
 
 out_unlock:
-	lxcunlock(c->slock);
-out_unlock1:
-	lxcunlock(c->privlock);
+	container_disk_unlock(c);
 out:
 	if (tpath)
 		free(tpath);
@@ -778,11 +737,10 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 
 	if (!c || !c->lxc_conf)
 		return false;
-	if (lxclock(c->privlock, 0)) {
+	if (container_mem_lock(c))
 		return false;
-	}
 	ret = lxc_clear_config_item(c->lxc_conf, key);
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return ret == 0;
 }
 
@@ -904,11 +862,10 @@ static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char
 
 	if (!c || !c->lxc_conf)
 		return -1;
-	if (lxclock(c->privlock, 0)) {
+	if (container_mem_lock(c))
 		return -1;
-	}
 	ret = lxc_get_config_item(c->lxc_conf, key, retv, inlen);
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return ret;
 }
 
@@ -923,12 +880,12 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 	 */
 	if (!c || !c->lxc_conf)
 		return -1;
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return -1;
 	int ret = -1;
 	if (strncmp(key, "lxc.network.", 12) == 0)
 		ret =  lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return ret;
 }
 
@@ -953,13 +910,13 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 	FILE *fout = fopen(alt_file, "w");
 	if (!fout)
 		return false;
-	if (lxclock(c->privlock, 0)) {
+	if (container_mem_lock(c)) {
 		fclose(fout);
 		return false;
 	}
 	write_config(fout, c->lxc_conf);
 	fclose(fout);
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return true;
 }
 
@@ -1000,7 +957,7 @@ static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, con
 	if (!c)
 		return false;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return false;
 
 	if (!c->lxc_conf)
@@ -1015,7 +972,7 @@ static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, con
 		b = true;
 
 err:
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return b;
 }
 
@@ -1076,7 +1033,7 @@ static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 	if (!c)
 		return b;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return b;
 
 	p = strdup(path);
@@ -1102,7 +1059,7 @@ static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 err:
 	if (oldpath)
 		free(oldpath);
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return b;
 }
 
@@ -1115,7 +1072,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (!c)
 		return false;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return false;
 
 	if (is_stopped_nolock(c))
@@ -1125,7 +1082,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (!ret)
 		b = true;
 err:
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return b;
 }
 
@@ -1136,7 +1093,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	if (!c || !c->lxc_conf)
 		return -1;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return -1;
 
 	if (is_stopped_nolock(c))
@@ -1145,7 +1102,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);
 
 out:
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return ret;
 }
 
@@ -1600,7 +1557,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (!c || !c->is_defined(c))
 		return NULL;
 
-	if (lxclock(c->privlock, 0))
+	if (container_mem_lock(c))
 		return NULL;
 
 	if (c->is_running(c)) {
@@ -1682,11 +1639,11 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		goto out;
 
 	// TODO: update c's lxc.snapshot = count
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	return c2;
 
 out:
-	lxcunlock(c->privlock);
+	container_mem_unlock(c);
 	if (c2) {
 		c2->destroy(c2);
 		lxc_container_put(c2);

commit df271a59cbfcfbe98fa4bd7af3ae595633539a12
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed May 22 16:24:00 2013 -0500

    lxclock: Replace named sempahore with flock
    
    The problem: if a task is killed while holding a posix semaphore,
    there appears to be no way to have the semaphore be reliably
    autmoatically released.  The only trick which seemed promising
    is to store the pid of the lock holder in some file and have
    later lock seekers check whether that task has died.
    
    Instead of going down that route, this patch switches from a
    named posix semaphore to flock.  The advantage is that when
    the task is killed, its fds are closed and locks are automatically
    released.
    
    The disadvantage of flock is that we can't rely on it to exclude
    threads.  Therefore c->slock must now always be wrapped inside
    c->privlock.
    
    This patch survived basic testing with the lxcapi_create patchset,
    where now killing lxc-create while it was holding the lock did
    not lock up future api commands.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1c0b7b2..0ec23e8 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -43,14 +43,16 @@
 #include <arpa/inet.h>
 #include <ifaddrs.h>
 
-static pthread_mutex_t thread_mutex = PTHREAD_MUTEX_INITIALIZER;
+extern pthread_mutex_t thread_mutex;
 
 lxc_log_define(lxc_container, lxc);
 
 /* LOCKING
- * c->privlock protects the struct lxc_container from multiple threads.
- * c->slock protects the on-disk container data
- * thread_mutex protects process data (ex: fd table) from multiple threads
+ * 1. c->privlock protects the struct lxc_container from multiple threads.
+ * 2. c->slock protects the on-disk container data
+ * 3. thread_mutex protects process data (ex: fd table) from multiple threads
+ * slock is an flock, which does not exclude threads.  Therefore slock should
+ * always be wrapped inside privlock.
  * NOTHING mutexes two independent programs with their own struct
  * lxc_container for the same c->name, between API calls.  For instance,
  * c->config_read(); c->start();  Between those calls, data on disk
@@ -81,14 +83,12 @@ static void lxc_container_free(struct lxc_container *c)
 		c->error_string = NULL;
 	}
 	if (c->slock) {
-		sem_close(c->slock);
+		lxc_putlock(c->slock);
 		c->slock = NULL;
 	}
 	if (c->privlock) {
-		sem_t *l = c->privlock;
+		lxc_putlock(c->privlock);
 		c->privlock = NULL;
-		sem_destroy(l);
-		free(l);
 	}
 	if (c->name) {
 		free(c->name);
@@ -202,11 +202,15 @@ static const char *lxcapi_state(struct lxc_container *c)
 
 	if (!c)
 		return NULL;
-	if (lxclock(c->slock, 0))
+	if (lxclock(c->privlock, 0))
 		return NULL;
+	if (lxclock(c->slock, 0))
+		goto bad;
 	s = lxc_getstate(c->name, c->config_path);
 	ret = lxc_state2str(s);
 	lxcunlock(c->slock);
+bad:
+	lxcunlock(c->privlock);
 
 	return ret;
 }
@@ -236,10 +240,15 @@ static bool lxcapi_freeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (lxclock(c->slock, 0))
+	if (lxclock(c->privlock, 0))
 		return false;
+	if (lxclock(c->slock, 0)) {
+		lxcunlock(c->privlock);
+		return false;
+	}
 	ret = lxc_freeze(c->name, c->config_path);
 	lxcunlock(c->slock);
+	lxcunlock(c->privlock);
 	if (ret)
 		return false;
 	return true;
@@ -251,10 +260,15 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	if (lxclock(c->slock, 0))
+	if (lxclock(c->privlock, 0))
 		return false;
+	if (lxclock(c->slock, 0)) {
+		lxcunlock(c->privlock);
+		return false;
+	}
 	ret = lxc_unfreeze(c->name, c->config_path);
 	lxcunlock(c->slock);
+	lxcunlock(c->privlock);
 	if (ret)
 		return false;
 	return true;
@@ -266,10 +280,15 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 	if (!c)
 		return -1;
 
-	if (lxclock(c->slock, 0))
+	if (lxclock(c->privlock, 0))
 		return -1;
+	if (lxclock(c->slock, 0)) {
+		lxcunlock(c->privlock);
+		return -1;
+	}
 	ret = lxc_cmd_get_init_pid(c->name, c->config_path);
 	lxcunlock(c->slock);
+	lxcunlock(c->privlock);
 	return ret;
 }
 
@@ -294,10 +313,15 @@ static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 		fname = alt_file;
 	if (!fname)
 		return false;
-	if (lxclock(c->slock, 0))
+	if (lxclock(c->privlock, 0))
+		return false;
+	if (lxclock(c->slock, 0)) {
+		lxcunlock(c->privlock);
 		return false;
+	}
 	ret = load_config_locked(c, fname);
 	lxcunlock(c->slock);
+	lxcunlock(c->privlock);
 	return ret;
 }
 
@@ -589,9 +613,12 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 	/* we're going to fork.  but since we'll wait for our child, we
 	 * don't need to lxc_container_get */
 
+	if (lxclock(c->privlock, 0))
+		goto out;
 	if (lxclock(c->slock, 0)) {
 		ERROR("failed to grab global container lock for %s\n", c->name);
-		goto out;
+		lxcunlock(c->privlock);
+		goto out_unlock1;
 	}
 
 	pid = fork();
@@ -672,6 +699,8 @@ static bool lxcapi_create(struct lxc_container *c, const char *t, char *const ar
 
 out_unlock:
 	lxcunlock(c->slock);
+out_unlock1:
+	lxcunlock(c->privlock);
 out:
 	if (tpath)
 		free(tpath);
@@ -1695,14 +1724,12 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	strcpy(c->name, name);
 
 	c->numthreads = 1;
-	c->slock = lxc_newlock(name);
-	if (!c->slock) {
+	if (!(c->slock = lxc_newlock(c->config_path, name))) {
 		fprintf(stderr, "failed to create lock\n");
 		goto err;
 	}
 
-	c->privlock = lxc_newlock(NULL);
-	if (!c->privlock) {
+	if (!(c->privlock = lxc_newlock(NULL, NULL))) {
 		fprintf(stderr, "failed to alloc privlock\n");
 		goto err;
 	}

commit 2acf77955239ec0046451fa16812d2884e6bd19b
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Thu May 23 15:44:39 2013 -0400

    fix memory leaks in cgroup functions
    
    There were several memory leaks in the cgroup functions, notably in the
    success cases.
    
    The cgpath test program was refactored and additional tests added to it.
    It was used in various modes under valgrind to test that the leaks were
    fixed.
    
    Simplify lxc_cgroup_path_get() and cgroup_path_get by having them return a
    char * instead of an int and an output char * argument. The only return
    values ever used were -1 and 0, which are now handled with NULL and non-NULL
    returns respectively.
    
    Use consistent variable names of cgabspath when refering to an absolute path
    to a cgroup subsystem or file, and cgrelpath when refering to a container
    "group/name" within the cgroup heirarchy.
    
    Remove unused subsystem argument to lxc_cmd_get_cgroup_path().
    
    Remove unused #define MAXPRIOLEN
    
    Make template arg to lxcapi_create() const
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 60b77b9..1c0b7b2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -555,7 +555,7 @@ static bool create_container_dir(struct lxc_container *c)
  * for ->create, argv contains the arguments to pass to the template,
  * terminated by NULL.  If no arguments, you can just pass NULL.
  */
-static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
+static bool lxcapi_create(struct lxc_container *c, const char *t, char *const argv[])
 {
 	bool bret = false;
 	pid_t pid;
@@ -621,7 +621,7 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 		newargv = malloc(nargs * sizeof(*newargv));
 		if (!newargv)
 			exit(1);
-		newargv[0] = t;
+		newargv[0] = (char *)t;
 
 		len = strlen(c->config_path) + strlen(c->name) + strlen("--path=") + 2;
 		patharg = malloc(len);
@@ -702,7 +702,7 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 	return retv;
 }
 
-static bool lxcapi_createl(struct lxc_container *c, char *t, ...)
+static bool lxcapi_createl(struct lxc_container *c, const char *t, ...)
 {
 	bool bret = false;
 	char **args = NULL, **temp;

commit 6a44839f5973f41553349f1b5e77d8db809e60eb
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Thu May 23 15:39:03 2013 -0400

    consolidate missing C library functions into utils.h
    
    This fixes the build of lxccontainer.c on systems that have __NR_setns
    but not HAVE_SETNS.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 2934afa..60b77b9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -35,6 +35,7 @@
 #include "version.h"
 #include "log.h"
 #include "bdev.h"
+#include "utils.h"
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
 #include <sched.h>
@@ -44,22 +45,6 @@
 
 static pthread_mutex_t thread_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-/* Define unshare() if missing from the C library */
-/* this is also in attach.c and lxccontainer.c: commonize it in utils.c */
-#ifndef HAVE_UNSHARE
-static int unshare(int flags)
-{
-#ifdef __NR_unshare
-	return syscall(__NR_unshare, flags);
-#else
-	errno = ENOSYS;
-	return -1;
-#endif
-}
-#else
-int unshare(int);
-#endif
-
 lxc_log_define(lxc_container, lxc);
 
 /* LOCKING

commit fca3080f6a46f856c54218a8e478a174382b4c15
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue May 21 13:15:53 2013 -0400

    fix minor gcc 4.7.2 error
    
    lxccontainer.c:874:4: error: for loop initial declarations are only
    allowed in C99 mode
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 7ce25c6..2934afa 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -871,7 +871,8 @@ out:
 		count++;
 		temp = realloc(addresses, count * sizeof(*addresses));
 		if (!temp) {
-			for (int i = 0; i < count-1; i++)
+			int i;
+			for (i = 0; i < count-1; i++)
 				free(addresses[i]);
 			free(addresses);
 			return NULL;

commit ef6e34eec8d5a9f1447462d6080facb674b3ccdb
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Fri May 17 18:29:12 2013 -0400

    extend command processor to handle generic data
    
    Motivation for this change is to have the ability to get the run-time
    configuration items from a container, which may differ from its current
    on disk configuration, or might not be available any other way (for
    example lxc.network.0.veth.pair). In adding this ability it seemed there
    was room for refactoring improvements.
    
    Genericize the command infrastructure so that both command requests and
    responses can have arbitrary data. Consolidate all commands into command.c
    and name them consistently. This allows all the callback routines to be
    made static, reducing exposure.
    
    Return the actual allocated tty for the console command. Don't print the
    init pid in lxc_info if the container isn't actually running. Command
    processing was made more thread safe by removing the static buffer from
    receive_answer(). Refactored command response code to a common routine.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 4a6f774..7ce25c6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -283,7 +283,7 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 
 	if (lxclock(c->slock, 0))
 		return -1;
-	ret = get_init_pid(c->name, c->config_path);
+	ret = lxc_cmd_get_init_pid(c->name, c->config_path);
 	lxcunlock(c->slock);
 	return ret;
 }
@@ -521,7 +521,7 @@ static bool lxcapi_stop(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	ret = lxc_stop(c->name, c->config_path);
+	ret = lxc_cmd_stop(c->name, c->config_path);
 
 	return ret == 0;
 }

commit 9c83a661397456e1455d739bcadfa38f05ce2fe6
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Fri Apr 26 16:01:58 2013 +0200

    lxcapi: Add new get_ips() call
    
    This adds a new get_ips call which takes a family (inet, inet6 or NULL),
    a network interface (or NULL for all) and a scope (0 for global) and returns
    a char** of all the IPs in the container.
    
    This also adds a matching python3 binding (function result is a tuple) and
    deprecates the previous pure-python get_ips() implementation.
    
    WARNING: The python get_ips() call is quite different from the previous
    implementation. The timeout argument has been removed, the family names are
    slightly different (inet/inet6 vs ipv4/ipv6) and an extra scope parameter
    has been added.
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 23db6f2..4a6f774 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -37,6 +37,10 @@
 #include "bdev.h"
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
+#include <sched.h>
+#include <fcntl.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
 
 static pthread_mutex_t thread_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -768,6 +772,117 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 	return ret == 0;
 }
 
+char** lxcapi_get_ips(struct lxc_container *c, char* interface, char* family, int scope)
+{
+	int count = 0;
+	struct ifaddrs *interfaceArray = NULL, *tempIfAddr = NULL;
+	char addressOutputBuffer[INET6_ADDRSTRLEN];
+	void *tempAddrPtr = NULL;
+	char **addresses = NULL, **temp;
+	char *address = NULL;
+	char new_netns_path[MAXPATHLEN];
+	int old_netns = -1, new_netns = -1, ret = 0;
+
+	if (!c->is_running(c))
+		goto out;
+
+	/* Save reference to old netns */
+	old_netns = open("/proc/self/ns/net", O_RDONLY);
+	if (old_netns < 0) {
+		SYSERROR("failed to open /proc/self/ns/net");
+		goto out;
+	}
+
+	/* Switch to new netns */
+	ret = snprintf(new_netns_path, MAXPATHLEN, "/proc/%d/ns/net", c->init_pid(c));
+	if (ret < 0 || ret >= MAXPATHLEN)
+		goto out;
+
+	new_netns = open(new_netns_path, O_RDONLY);
+	if (new_netns < 0) {
+		SYSERROR("failed to open %s", new_netns_path);
+		goto out;
+	}
+
+	if (setns(new_netns, CLONE_NEWNET)) {
+		SYSERROR("failed to setns");
+		goto out;
+	}
+
+	/* Grab the list of interfaces */
+	if (getifaddrs(&interfaceArray)) {
+		SYSERROR("failed to get interfaces list");
+		goto out;
+	}
+
+	/* Iterate through the interfaces */
+	for (tempIfAddr = interfaceArray; tempIfAddr != NULL; tempIfAddr = tempIfAddr->ifa_next) {
+		if(tempIfAddr->ifa_addr->sa_family == AF_INET) {
+			if (family && strcmp(family, "inet"))
+				continue;
+			tempAddrPtr = &((struct sockaddr_in *)tempIfAddr->ifa_addr)->sin_addr;
+		}
+		else {
+			if (family && strcmp(family, "inet6"))
+				continue;
+
+			if (((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_scope_id != scope)
+				continue;
+
+			tempAddrPtr = &((struct sockaddr_in6 *)tempIfAddr->ifa_addr)->sin6_addr;
+		}
+
+		if (interface && strcmp(interface, tempIfAddr->ifa_name))
+			continue;
+		else if (!interface && strcmp("lo", tempIfAddr->ifa_name) == 0)
+			continue;
+
+		address = (char *)inet_ntop(tempIfAddr->ifa_addr->sa_family,
+					   tempAddrPtr,
+					   addressOutputBuffer,
+					   sizeof(addressOutputBuffer));
+		if (!address)
+			continue;
+
+		count += 1;
+		temp = realloc(addresses, count * sizeof(*addresses));
+		if (!temp) {
+			count--;
+			goto out;
+		}
+		addresses = temp;
+		addresses[count - 1] = strdup(address);
+	}
+
+out:
+	if(interfaceArray)
+		freeifaddrs(interfaceArray);
+
+	/* Switch back to original netns */
+	if (old_netns >= 0 && setns(old_netns, CLONE_NEWNET))
+		SYSERROR("failed to setns");
+	if (new_netns >= 0)
+		close(new_netns);
+	if (old_netns >= 0)
+		close(old_netns);
+
+	/* Append NULL to the array */
+	if (count) {
+		count++;
+		temp = realloc(addresses, count * sizeof(*addresses));
+		if (!temp) {
+			for (int i = 0; i < count-1; i++)
+				free(addresses[i]);
+			free(addresses);
+			return NULL;
+		}
+		addresses = temp;
+		addresses[count - 1] = NULL;
+	}
+
+	return addresses;
+}
+
 static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	int ret;
@@ -1642,6 +1757,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->get_config_path = lxcapi_get_config_path;
 	c->set_config_path = lxcapi_set_config_path;
 	c->clone = lxcapi_clone;
+	c->get_ips = lxcapi_get_ips;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit 148e91f56799f03c868deca8dcad473983a1a2bf
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue May 14 16:10:37 2013 -0500

    lxc: add clone hook.
    
    Add a clone hook called from api_clone.  Pass arguments to it from
    lxc_clone.c.
    
    The clone update hook is called while the container's bdev is mounted.
    Information about the container is passed in through environment
    variables LXC_ROOTFS_PATH, LXC_NAME, The LXC_ROOTFS_MOUNT, and
    LXC_CONFIG_FILE.
    
    LXC_ROOTFS_MOUNT=/usr/lib/x86_64-linux-gnu/lxc
    LXC_CONFIG_FILE=/var/lib/lxc/demo3/config
    LXC_ROOTFS_PATH=/var/lib/lxc/demo3/rootfs
    LXC_NAME=demo3
    
    So from the hook, updates to the container should be made under
    $LXC_ROOTFS_MOUNT/ .
    
    The hook also receives command line arguments as follows:
    First argument is container name, second is always 'lxc', third
    is the hook name (always clone), then come the arguments which
    were passed to lxc-clone.  I.e. when I did:
    
    sudo lxc-clone demo2 demo3 -- hey there dude
    
    the arguments passed in were "demo3 lxc clone hey there dude"
    
    I personally would like to drop the first two arguments.  The
    name is available as $LXC_NAME, and the section argument ('lxc')
    is meaningless.  However, doing so risks invalidating existing
    hooks.
    
    Soon analogous create and destroy hooks will be added as well.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index bac94c2..23db6f2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1364,16 +1364,14 @@ static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
 	return 0;
 }
 
-static int clone_update_rootfs(struct lxc_container *c, int flags)
+static int clone_update_rootfs(struct lxc_container *c, int flags, char **hookargs)
 {
 	int ret = -1;
 	char path[MAXPATHLEN];
 	struct bdev *bdev;
 	FILE *fout;
 	pid_t pid;
-
-	if (flags & LXC_CLONE_KEEPNAME)
-		return 0;
+	struct lxc_conf *conf = c->lxc_conf;
 
 	/* update hostname in rootfs */
 	/* we're going to mount, so run in a clean namespace to simplify cleanup */
@@ -1393,17 +1391,41 @@ static int clone_update_rootfs(struct lxc_container *c, int flags)
 		exit(1);
 	if (bdev->ops->mount(bdev) < 0)
 		exit(1);
-	ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
-	if (ret < 0 || ret >= MAXPATHLEN)
-		exit(1);
-	if (!(fout = fopen(path, "w"))) {
-		SYSERROR("unable to open %s: ignoring\n", path);
-		exit(0);
+
+	if (!lxc_list_empty(&conf->hooks[LXCHOOK_CLONE])) {
+		/* Start of environment variable setup for hooks */
+		if (setenv("LXC_NAME", c->name, 1)) {
+			SYSERROR("failed to set environment variable for container name");
+		}
+		if (setenv("LXC_CONFIG_FILE", conf->rcfile, 1)) {
+			SYSERROR("failed to set environment variable for config path");
+		}
+		if (setenv("LXC_ROOTFS_MOUNT", conf->rootfs.mount, 1)) {
+			SYSERROR("failed to set environment variable for rootfs mount");
+		}
+		if (setenv("LXC_ROOTFS_PATH", conf->rootfs.path, 1)) {
+			SYSERROR("failed to set environment variable for rootfs mount");
+		}
+
+		if (run_lxc_hooks(c->name, "clone", conf, hookargs)) {
+			ERROR("Error executing clone hook for %s", c->name);
+			exit(1);
+		}
+	}
+
+	if (!(flags & LXC_CLONE_KEEPNAME)) {
+		ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
+		if (ret < 0 || ret >= MAXPATHLEN)
+			exit(1);
+		if (!(fout = fopen(path, "w"))) {
+			SYSERROR("unable to open %s: ignoring\n", path);
+			exit(0);
+		}
+		if (fprintf(fout, "%s", c->name) < 0)
+			exit(1);
+		if (fclose(fout) < 0)
+			exit(1);
 	}
-	if (fprintf(fout, "%s", c->name) < 0)
-		exit(1);
-	if (fclose(fout) < 0)
-		exit(1);
 	exit(0);
 }
 
@@ -1436,7 +1458,8 @@ static int create_file_dirname(char *path)
 
 struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		const char *lxcpath, int flags,
-		const char *bdevtype, const char *bdevdata, unsigned long newsize)
+		const char *bdevtype, const char *bdevdata, unsigned long newsize,
+		char **hookargs)
 {
 	struct lxc_container *c2 = NULL;
 	char newpath[MAXPATHLEN];
@@ -1525,7 +1548,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	if (!c2->save_config(c2, NULL))
 		goto out;
 
-	if (clone_update_rootfs(c2, flags) < 0)
+	if (clone_update_rootfs(c2, flags, hookargs) < 0)
 		goto out;
 
 	// TODO: update c's lxc.snapshot = count

commit 714540763b8b1ac12c029d7760b4e4fe13a69b43
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon May 13 12:03:14 2013 -0400

    serialize multiple threads doing lxcapi_start()
    
    The problem is that the fd table is shared between threads and if a thread
    forks() while another thread has an open fd to the monitor, the duped fd
    in the fork()ed child will not get closed, thus causing monitord to stay
    around since it thinks it still has a client. This only happened when
    calling lxcapi_start() in the daemonized case since that is the only time
    we try to get the status from the monitor.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 04a9208..bac94c2 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -18,6 +18,7 @@
  */
 
 #define _GNU_SOURCE
+#include <pthread.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -37,6 +38,8 @@
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
 
+static pthread_mutex_t thread_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 /* Define unshare() if missing from the C library */
 /* this is also in attach.c and lxccontainer.c: commonize it in utils.c */
 #ifndef HAVE_UNSHARE
@@ -58,6 +61,7 @@ lxc_log_define(lxc_container, lxc);
 /* LOCKING
  * c->privlock protects the struct lxc_container from multiple threads.
  * c->slock protects the on-disk container data
+ * thread_mutex protects process data (ex: fd table) from multiple threads
  * NOTHING mutexes two independent programs with their own struct
  * lxc_container for the same c->name, between API calls.  For instance,
  * c->config_read(); c->start();  Between those calls, data on disk
@@ -391,13 +395,24 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		if (!lxc_container_get(c))
 			return false;
 		lxc_monitord_spawn(c->config_path);
+
+		ret = pthread_mutex_lock(&thread_mutex);
+		if (ret != 0) {
+			ERROR("pthread_mutex_lock returned:%d %s", ret, strerror(ret));
+			return false;
+		}
 		pid_t pid = fork();
 		if (pid < 0) {
 			lxc_container_put(c);
+			pthread_mutex_unlock(&thread_mutex);
 			return false;
 		}
-		if (pid != 0)
-			return wait_on_daemonized_start(c);
+		if (pid != 0) {
+			ret = wait_on_daemonized_start(c);
+			pthread_mutex_unlock(&thread_mutex);
+			return ret;
+		}
+		pthread_mutex_unlock(&thread_mutex);
 		/* second fork to be reparented by init */
 		pid = fork();
 		if (pid < 0) {

commit a747894428ea38c4a908acacb610fc3de714e0c0
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Fri May 3 13:41:40 2013 -0400

    coverity: ftell returns a signed value
    
    The check for flen < 0 could never have been true since flen was declared
    to be size_t (unsigned). Declare flen to be long since that is what ftell
    returns.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 73c347d..04a9208 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1133,7 +1133,7 @@ static int update_name_and_paths(const char *path, struct lxc_container *oldc,
 		const char *newname, const char *newpath)
 {
 	FILE *f;
-	size_t flen;
+	long flen;
 	char *contents;
 	const char *p0, *p1, *p2, *end;
 	const char *oldpath = oldc->get_config_path(oldc);

commit a2eea3c1974d70bdef74a0af6a14ca3a6fa41704
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Fri May 3 11:29:39 2013 -0400

    coverity: ensure string is null terminated, return in
    
     error case
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 452323c..73c347d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1160,10 +1160,11 @@ static int update_name_and_paths(const char *path, struct lxc_container *oldc,
 		SYSERROR("rewinding old config");
 		return -1;
 	}
-	contents = malloc(flen);
+	contents = malloc(flen+1);
 	if (!contents) {
 		SYSERROR("out of memory");
 		fclose(f);
+		return -1;
 	}
 	if (fread(contents, 1, flen, f) != flen) {
 		free(contents);
@@ -1171,6 +1172,7 @@ static int update_name_and_paths(const char *path, struct lxc_container *oldc,
 		SYSERROR("reading old config");
 		return -1;
 	}
+	contents[flen] = '\0';
 	if (fclose(f) < 0) {
 		free(contents);
 		SYSERROR("closing old config");

commit 375c2258b24b233832c9ec43ab9c7b3f5dce25fb
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed May 1 23:37:05 2013 -0500

    clone: a few fixes
    
    clean up error case in clone, which in particular could cause double
    lxc_container_put(c2)
    
    for overlayfs, handle (with error message) all bdev types.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 10f188e..452323c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1477,7 +1477,7 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 	}
 
 	c2 = lxc_container_new(n, l);
-	if (!c) {
+	if (!c2) {
 		ERROR("clone: failed to create new container (%s %s)", n, l);
 		goto out;
 	}
@@ -1487,16 +1487,12 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 		ret = copyhooks(c, c2);
 		if (ret < 0) {
 			ERROR("error copying hooks");
-			c2->destroy(c2);
-			lxc_container_put(c2);
 			goto out;
 		}
 	}
 
 	if (copy_fstab(c, c2) < 0) {
 		ERROR("error copying fstab");
-		c2->destroy(c2);
-		lxc_container_put(c2);
 		goto out;
 	}
 
@@ -1506,23 +1502,14 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 
 	// copy/snapshot rootfs's
 	ret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);
-	if (ret < 0) {
-		c2->destroy(c2);
-		lxc_container_put(c2);
+	if (ret < 0)
 		goto out;
-	}
 
-	if (!c2->save_config(c2, NULL)) {
-		c2->destroy(c2);
-		lxc_container_put(c2);
+	if (!c2->save_config(c2, NULL))
 		goto out;
-	}
 
-	if (clone_update_rootfs(c2, flags) < 0) {
-		//c2->destroy(c2);
-		lxc_container_put(c2);
+	if (clone_update_rootfs(c2, flags) < 0)
 		goto out;
-	}
 
 	// TODO: update c's lxc.snapshot = count
 	lxcunlock(c->privlock);
@@ -1530,8 +1517,10 @@ struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
 
 out:
 	lxcunlock(c->privlock);
-	if (c2)
+	if (c2) {
+		c2->destroy(c2);
 		lxc_container_put(c2);
+	}
 
 	return NULL;
 }

commit a8428dfa2c6a43ee195f4be3e04a519ca1fc6ec0
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Apr 29 22:09:06 2013 +0200

    introduce lxc_config
    
    It's a tiny program (exported through the api) wrapping the util.c
    helpers for reading /etc/lxc/lxc.conf variables, and replaces
    the kludgy shell duplication in lxc.functions.in
    
    Changelog: Apr 30: address feedback from Dwight
    	(exit error on failure, and use 'lxcpath' as name, not
    	'default_path').
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Dwight Engen <dwight.engen@oracle.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 312cc99..10f188e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1009,6 +1009,16 @@ const char *lxc_get_default_config_path(void)
 	return default_lxc_path();
 }
 
+const char *lxc_get_default_lvm_vg(void)
+{
+	return default_lvm_vg();
+}
+
+const char *lxc_get_default_zfs_root(void)
+{
+	return default_zfs_root();
+}
+
 const char *lxc_get_version(void)
 {
 	return lxc_version();

commit 9be53773792fc9e8bd173edc3b7ac7e144875387
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Apr 16 08:07:05 2013 -0500

    implement backend drivers and container clone API (v3)
    
    1. commonize waitpid users to use a single helper.  We frequently want
    to run something in a clean namespace, or fork off a script.  This
    lets us keep the function doing fork:(1)exec(2)waitpid simpler.
    
    2. start a blockdev backend implementation.  This will be used for
    mounting, copying, and snapshotting container filesystems.
    
    3. implement btrfs, lvm, directory, and overlayfs backends.
    
    4. For overlayfs, support a new lxc.rootfs format of
    'bdevtype:<extra>'.  This means you can now use overlayfs-based
    containers without using lxc-start-ephemeral, by using
    lxc.rootfs = overlayfs:/readonly-dir:writeable-dir
    
    5. add a set of simple clone testcases
    
    6. Write a new lxc_clone.c based on api clone.
    
    Still to do (there's more, but off top of my head):
    
    1. support zfs, aufs
    2. have clone handle other mount entries (right now it only clones
    the rootfs)
    3. python, lua, and go bindings (not me :)
    4. lxc-destroy: if lvm backing store, check for snapshots of it.
       (what about directories which have overlayfs clones?)
    
    Changes since v2:
    	Initialize random generator when picking new macaddr (reported
    	  by caglar@10ur.org)
    	Fix wrong use of bitmask flags
    	On copy-clone of btrfs, create a subvolume
    	lxc_clone.c: respect the command line usage of the old script
    	lxc-clone(1): update documentation
    	Refuse to try changing backing stores expect to overlayfs, as
    	  it is not implemented (yet) anyway.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    
    Conflicts:
    	src/lxc/utils.h

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 740a8d9..312cc99 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -17,23 +17,42 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <sched.h>
+#include "config.h"
 #include "lxc.h"
 #include "state.h"
 #include "lxccontainer.h"
 #include "conf.h"
-#include "config.h"
 #include "confile.h"
 #include "cgroup.h"
 #include "commands.h"
 #include "version.h"
 #include "log.h"
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <errno.h>
+#include "bdev.h"
 #include <lxc/utils.h>
 #include <lxc/monitor.h>
 
+/* Define unshare() if missing from the C library */
+/* this is also in attach.c and lxccontainer.c: commonize it in utils.c */
+#ifndef HAVE_UNSHARE
+static int unshare(int flags)
+{
+#ifdef __NR_unshare
+	return syscall(__NR_unshare, flags);
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+#else
+int unshare(int);
+#endif
+
 lxc_log_define(lxc_container, lxc);
 
 /* LOCKING
@@ -536,10 +555,8 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 {
 	bool bret = false;
 	pid_t pid;
-	int ret, status;
-	char *tpath = NULL;
-	int len, nargs = 0;
-	char **newargv;
+	char *tpath = NULL, **newargv;
+	int ret, len, nargs = 0;
 
 	if (!c)
 		return false;
@@ -566,7 +583,7 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 		goto out;
 
 	/* we're going to fork.  but since we'll wait for our child, we
-	   don't need to lxc_container_get */
+	 * don't need to lxc_container_get */
 
 	if (lxclock(c->slock, 0)) {
 		ERROR("failed to grab global container lock for %s\n", c->name);
@@ -637,26 +654,8 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 		exit(1);
 	}
 
-again:
-	ret = waitpid(pid, &status, 0);
-	if (ret == -1) {
-		if (errno == -EINTR)
-			goto again;
-		SYSERROR("waitpid failed");
-		goto out_unlock;
-	}
-	if (ret != pid)
-		goto again;
-	if (!WIFEXITED(status))  { // did not exit normally
-		// we could set an error code and string inside the
-		// container_struct here if we like
-		ERROR("container creation template exited abnormally\n");
-		goto out_unlock;
-	}
-
-	if (WEXITSTATUS(status) != 0) {
-		ERROR("container creation template for %s exited with %d\n",
-		      c->name, WEXITSTATUS(status));
+	if (wait_for_pid(pid) != 0) {
+		ERROR("container creation template for %s failed\n", c->name);
 		goto out_unlock;
 	}
 
@@ -822,7 +821,6 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 static bool lxcapi_destroy(struct lxc_container *c)
 {
 	pid_t pid;
-	int ret, status;
 
 	if (!c)
 		return false;
@@ -840,23 +838,12 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		exit(1);
 	}
 
-again:
-	ret = waitpid(pid, &status, 0);
-	if (ret == -1) {
-		if (errno == -EINTR)
-			goto again;
-		perror("waitpid");
-		return false;
-	}
-	if (ret != pid)
-		goto again;
-	if (!WIFEXITED(status))  { // did not exit normally
-		// we could set an error code and string inside the
-		// container_struct here if we like
+	if (wait_for_pid(pid) < 0) {
+		ERROR("Error destroying container %s", c->name);
 		return false;
 	}
 
-	return WEXITSTATUS(status) == 0;
+	return true;
 }
 
 static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
@@ -1027,6 +1014,518 @@ const char *lxc_get_version(void)
 	return lxc_version();
 }
 
+static int copy_file(char *old, char *new)
+{
+	int in, out;
+	ssize_t len, ret;
+	char buf[8096];
+	struct stat sbuf;
+
+	if (file_exists(new)) {
+		ERROR("copy destination %s exists", new);
+		return -1;
+	}
+	ret = stat(old, &sbuf);
+	if (ret < 0) {
+		SYSERROR("stat'ing %s", old);
+		return -1;
+	}
+
+	in = open(old, O_RDONLY);
+	if (in < 0) {
+		SYSERROR("opening original file %s", old);
+		return -1;
+	}
+	out = open(new, O_CREAT | O_EXCL | O_WRONLY, 0644);
+	if (out < 0) {
+		SYSERROR("opening new file %s", new);
+		close(in);
+		return -1;
+	}
+
+	while (1) {
+		len = read(in, buf, 8096);
+		if (len < 0) {
+			SYSERROR("reading old file %s", old);
+			goto err;
+		}
+		if (len == 0)
+			break;
+		ret = write(out, buf, len);
+		if (ret < len) {  // should we retry?
+			SYSERROR("write to new file %s was interrupted", new);
+			goto err;
+		}
+	}
+	close(in);
+	close(out);
+
+	// we set mode, but not owner/group
+	ret = chmod(new, sbuf.st_mode);
+	if (ret) {
+		SYSERROR("setting mode on %s", new);
+		return -1;
+	}
+
+	return 0;
+
+err:
+	close(in);
+	close(out);
+	return -1;
+}
+
+/*
+ * we're being passed result of two strstrs(x, y).  We want to write
+ * all data up to the first found string, or to end of the string if
+ * neither string was found.
+ * This function will return the earliest found string if any, or else
+ * NULL
+ */
+static const char *lowest_nonnull(const char *p1, const char *p2)
+{
+	if (!p1)
+		return p2;
+	if (!p2)
+		return p1;
+	return p1 < p2 ? p1 : p2;
+}
+
+static int is_word_sep(char c)
+{
+	switch(c) {
+	case '\0':
+	case '\n':
+	case '\r':
+	case '\t':
+	case ' ':
+	case '=':
+	case '/':
+		return 1;
+	default: return 0;
+	}
+}
+
+static const char *find_first_wholeword(const char *p, const char *word)
+{
+	if (!p)
+		return NULL;
+
+	while ((p = strstr(p, word)) != NULL) {
+		if (is_word_sep(*(p-1)) && is_word_sep(p[strlen(word)]))
+			return p;
+		p++;
+	}
+	return NULL;
+}
+
+static int update_name_and_paths(const char *path, struct lxc_container *oldc,
+		const char *newname, const char *newpath)
+{
+	FILE *f;
+	size_t flen;
+	char *contents;
+	const char *p0, *p1, *p2, *end;
+	const char *oldpath = oldc->get_config_path(oldc);
+	const char *oldname = oldc->name;
+
+	f = fopen(path, "r");
+	if (!f) {
+		SYSERROR("opening old config");
+		return -1;
+	}
+	if (fseek(f, 0, SEEK_END) < 0) {
+		SYSERROR("seeking to end of old config");
+		fclose(f);
+		return -1;
+	}
+	flen = ftell(f);
+	if (flen < 0) {
+		fclose(f);
+		SYSERROR("telling size of old config");
+		return -1;
+	}
+	if (fseek(f, 0, SEEK_SET) < 0) {
+		fclose(f);
+		SYSERROR("rewinding old config");
+		return -1;
+	}
+	contents = malloc(flen);
+	if (!contents) {
+		SYSERROR("out of memory");
+		fclose(f);
+	}
+	if (fread(contents, 1, flen, f) != flen) {
+		free(contents);
+		fclose(f);
+		SYSERROR("reading old config");
+		return -1;
+	}
+	if (fclose(f) < 0) {
+		free(contents);
+		SYSERROR("closing old config");
+		return -1;
+	}
+
+	f = fopen(path, "w");
+	if (!f) {
+		SYSERROR("reopening config");
+		free(contents);
+		return -1;
+	}
+
+	p0 = contents;
+	end = contents + flen;
+	while (1) {
+		p1 = find_first_wholeword(p0, oldpath);
+		p2 = find_first_wholeword(p0, oldname);
+		if (!p1 && !p2) {
+			// write the rest and be done
+			if (fwrite(p0, 1, (end-p0), f) != (end-p0)) {
+				SYSERROR("writing new config");
+				free(contents);
+				fclose(f);
+				return -1;
+			}
+			free(contents);
+			fclose(f);
+			// success
+			return 0;
+		} else {
+			const char *p = lowest_nonnull(p1, p2);
+			const char *new = (p == p2) ? newname : newpath;
+			if (fwrite(p0, 1, (p-p0), f) != (p-p0)) {
+				SYSERROR("writing new config");
+				free(contents);
+				fclose(f);
+				return -1;
+			}
+			p0 = p;
+			// now write the newpath or newname
+			if (fwrite(new, 1, strlen(new), f) != strlen(new)) {
+				SYSERROR("writing new name or path in new config");
+				free(contents);
+				fclose(f);
+				return -1;
+			}
+			p0 += (p == p2) ? strlen(oldname) : strlen(oldpath);
+		}
+	}
+}
+
+static int copyhooks(struct lxc_container *oldc, struct lxc_container *c)
+{
+	int i;
+	int ret;
+	struct lxc_list *it;
+
+	for (i=0; i<NUM_LXC_HOOKS; i++) {
+		lxc_list_for_each(it, &c->lxc_conf->hooks[i]) {
+			char *hookname = it->elem;
+			char *fname = rindex(hookname, '/');
+			char tmppath[MAXPATHLEN];
+			if (!fname) // relative path - we don't support, but maybe we should
+				return 0;
+			// copy the script, and change the entry in confile
+			ret = snprintf(tmppath, MAXPATHLEN, "%s/%s/%s",
+					c->config_path, c->name, fname+1);
+			if (ret < 0 || ret >= MAXPATHLEN)
+				return -1;
+			ret = copy_file(it->elem, tmppath);
+			if (ret < 0)
+				return -1;
+			free(it->elem);
+			it->elem = strdup(tmppath);
+			if (!it->elem) {
+				ERROR("out of memory copying hook path");
+				return -1;
+			}
+			update_name_and_paths(it->elem, oldc, c->name, c->get_config_path(c));
+		}
+	}
+
+	c->save_config(c, NULL);
+	return 0;
+}
+
+static void new_hwaddr(char *hwaddr)
+{
+	FILE *f = fopen("/dev/urandom", "r");
+	if (f) {
+		unsigned int seed;
+		int ret = fread(&seed, sizeof(seed), 1, f);
+		if (ret != 1)
+			seed = time(NULL);
+		fclose(f);
+		srand(seed);
+	} else
+		srand(time(NULL));
+	snprintf(hwaddr, 18, "00:16:3e:%02x:%02x:%02x",
+			rand() % 255, rand() % 255, rand() % 255);
+}
+
+static void network_new_hwaddrs(struct lxc_container *c)
+{
+	struct lxc_list *it;
+
+	lxc_list_for_each(it, &c->lxc_conf->network) {
+		struct lxc_netdev *n = it->elem;
+		if (n->hwaddr)
+			new_hwaddr(n->hwaddr);
+	}
+}
+
+static int copy_fstab(struct lxc_container *oldc, struct lxc_container *c)
+{
+	char newpath[MAXPATHLEN];
+	char *oldpath = oldc->lxc_conf->fstab;
+	int ret;
+
+	if (!oldpath)
+		return 0;
+
+	char *p = rindex(oldpath, '/');
+	if (!p)
+		return -1;
+	ret = snprintf(newpath, MAXPATHLEN, "%s/%s%s",
+			c->config_path, c->name, p);
+	if (ret < 0 || ret >= MAXPATHLEN) {
+		ERROR("error printing new path for %s", oldpath);
+		return -1;
+	}
+	if (file_exists(newpath)) {
+		ERROR("error: fstab file %s exists", newpath);
+		return -1;
+	}
+
+	if (copy_file(oldpath, newpath) < 0) {
+		ERROR("error: copying %s to %s", oldpath, newpath);
+		return -1;
+	}
+	free(c->lxc_conf->fstab);
+	c->lxc_conf->fstab = strdup(newpath);
+	if (!c->lxc_conf->fstab) {
+		ERROR("error: allocating pathname");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int copy_storage(struct lxc_container *c0, struct lxc_container *c,
+		const char *newtype, int flags, const char *bdevdata, unsigned long newsize)
+{
+	struct bdev *bdev;
+
+	bdev = bdev_copy(c0->lxc_conf->rootfs.path, c0->name, c->name,
+			c0->config_path, c->config_path, newtype, !!(flags & LXC_CLONE_SNAPSHOT),
+			bdevdata, newsize);
+	if (!bdev) {
+		ERROR("error copying storage");
+		return -1;
+	}
+	free(c->lxc_conf->rootfs.path);
+	c->lxc_conf->rootfs.path = strdup(bdev->src);
+	bdev_put(bdev);
+	if (!c->lxc_conf->rootfs.path)
+		return -1;
+	// here we could also update all lxc.mount.entries or even
+	// items in the lxc.mount fstab list.  As discussed on m-l,
+	// we could do either any source paths starting with the
+	// lxcpath/oldname, or simply anythign which is not a virtual
+	// fs or a bind mount.
+	return 0;
+}
+
+static int clone_update_rootfs(struct lxc_container *c, int flags)
+{
+	int ret = -1;
+	char path[MAXPATHLEN];
+	struct bdev *bdev;
+	FILE *fout;
+	pid_t pid;
+
+	if (flags & LXC_CLONE_KEEPNAME)
+		return 0;
+
+	/* update hostname in rootfs */
+	/* we're going to mount, so run in a clean namespace to simplify cleanup */
+
+	pid = fork();
+	if (pid < 0)
+		return -1;
+	if (pid > 0)
+		return wait_for_pid(pid);
+
+	if (unshare(CLONE_NEWNS) < 0) {
+		ERROR("error unsharing mounts");
+		exit(1);
+	}
+	bdev = bdev_init(c->lxc_conf->rootfs.path, c->lxc_conf->rootfs.mount, NULL);
+	if (!bdev)
+		exit(1);
+	if (bdev->ops->mount(bdev) < 0)
+		exit(1);
+	ret = snprintf(path, MAXPATHLEN, "%s/etc/hostname", bdev->dest);
+	if (ret < 0 || ret >= MAXPATHLEN)
+		exit(1);
+	if (!(fout = fopen(path, "w"))) {
+		SYSERROR("unable to open %s: ignoring\n", path);
+		exit(0);
+	}
+	if (fprintf(fout, "%s", c->name) < 0)
+		exit(1);
+	if (fclose(fout) < 0)
+		exit(1);
+	exit(0);
+}
+
+/*
+ * We want to support:
+sudo lxc-clone -o o1 -n n1 -s -L|-fssize fssize -v|--vgname vgname \
+        -p|--lvprefix lvprefix -t|--fstype fstype  -B backingstore
+
+-s [ implies overlayfs]
+-s -B overlayfs
+-s -B aufs
+
+only rootfs gets converted (copied/snapshotted) on clone.
+*/
+
+static int create_file_dirname(char *path)
+{
+	char *p = rindex(path, '/');
+	int ret;
+
+	if (!p)
+		return -1;
+	*p = '\0';
+	ret = mkdir(path, 0755);
+	if (ret && errno != EEXIST)
+		SYSERROR("creating container path %s\n", path);
+	*p = '/';
+	return ret;
+}
+
+struct lxc_container *lxcapi_clone(struct lxc_container *c, const char *newname,
+		const char *lxcpath, int flags,
+		const char *bdevtype, const char *bdevdata, unsigned long newsize)
+{
+	struct lxc_container *c2 = NULL;
+	char newpath[MAXPATHLEN];
+	int ret;
+	const char *n, *l;
+	FILE *fout;
+
+	if (!c || !c->is_defined(c))
+		return NULL;
+
+	if (lxclock(c->privlock, 0))
+		return NULL;
+
+	if (c->is_running(c)) {
+		ERROR("error: Original container (%s) is running", c->name);
+		goto out;
+	}
+
+	// Make sure the container doesn't yet exist.
+	n = newname ? newname : c->name;
+	l = lxcpath ? lxcpath : c->get_config_path(c);
+	ret = snprintf(newpath, MAXPATHLEN, "%s/%s/config", l, n);
+	if (ret < 0  || ret >= MAXPATHLEN) {
+		SYSERROR("clone: failed making config pathname");
+		goto out;
+	}
+	if (file_exists(newpath)) {
+		ERROR("error: clone: %s exists", newpath);
+		goto out;
+	}
+
+	if (create_file_dirname(newpath) < 0) {
+		ERROR("Error creating container dir for %s", newpath);
+		goto out;
+	}
+
+	// copy the configuration, tweak it as needed,
+	fout = fopen(newpath, "w");
+	if (!fout) {
+		SYSERROR("open %s", newpath);
+		goto out;
+	}
+	write_config(fout, c->lxc_conf);
+	fclose(fout);
+
+	if (update_name_and_paths(newpath, c, n, l) < 0) {
+		ERROR("Error updating name in cloned config");
+		goto out;
+	}
+
+	sprintf(newpath, "%s/%s/rootfs", l, n);
+	if (mkdir(newpath, 0755) < 0) {
+		SYSERROR("error creating %s", newpath);
+		goto out;
+	}
+
+	c2 = lxc_container_new(n, l);
+	if (!c) {
+		ERROR("clone: failed to create new container (%s %s)", n, l);
+		goto out;
+	}
+
+	// copy hooks if requested
+	if (flags & LXC_CLONE_COPYHOOKS) {
+		ret = copyhooks(c, c2);
+		if (ret < 0) {
+			ERROR("error copying hooks");
+			c2->destroy(c2);
+			lxc_container_put(c2);
+			goto out;
+		}
+	}
+
+	if (copy_fstab(c, c2) < 0) {
+		ERROR("error copying fstab");
+		c2->destroy(c2);
+		lxc_container_put(c2);
+		goto out;
+	}
+
+	// update macaddrs
+	if (!(flags & LXC_CLONE_KEEPMACADDR))
+		network_new_hwaddrs(c2);
+
+	// copy/snapshot rootfs's
+	ret = copy_storage(c, c2, bdevtype, flags, bdevdata, newsize);
+	if (ret < 0) {
+		c2->destroy(c2);
+		lxc_container_put(c2);
+		goto out;
+	}
+
+	if (!c2->save_config(c2, NULL)) {
+		c2->destroy(c2);
+		lxc_container_put(c2);
+		goto out;
+	}
+
+	if (clone_update_rootfs(c2, flags) < 0) {
+		//c2->destroy(c2);
+		lxc_container_put(c2);
+		goto out;
+	}
+
+	// TODO: update c's lxc.snapshot = count
+	lxcunlock(c->privlock);
+	return c2;
+
+out:
+	lxcunlock(c->privlock);
+	if (c2)
+		lxc_container_put(c2);
+
+	return NULL;
+}
+
 struct lxc_container *lxc_container_new(const char *name, const char *configpath)
 {
 	struct lxc_container *c;
@@ -1103,6 +1602,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
 	c->get_config_path = lxcapi_get_config_path;
 	c->set_config_path = lxcapi_set_config_path;
+	c->clone = lxcapi_clone;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {

commit ab1bf971d2db43777cbf3892fb887bf71ce7d155
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Apr 29 14:54:08 2013 -0400

    Create log file in lxcpath for non-system containers
    
    On Fri, 26 Apr 2013 10:18:12 -0500
    Serge Hallyn <serge.hallyn@ubuntu.com> wrote:
    
    > Quoting Dwight Engen (dwight.engen@oracle.com):
    > > On Fri, 26 Apr 2013 09:37:49 -0500
    > > Serge Hallyn <serge.hallyn@ubuntu.com> wrote:
    > >
    > > > Quoting Dwight Engen (dwight.engen@oracle.com):
    > > > > Using lxc configured with --enable-configpath-log, and
    > > > > specifying a path to the lxc commands with -P, the log file
    > > > > path is generated with a basename of LOGPATH instead of the
    > > > > lxcpath. This means for example if you do
    > > > >
    > > > > lxc-start -P /tmp/containers -n test01 -l INFO
    > > > >
    > > > > your log file will be
    > > > >
    > > > > /var/lib/lxc/test01/test01.log
    > > > >
    > > > > I was expecting the log to be /tmp/containers/test01/test01.log.
    > > > > This is particularly confusing if you also have test01 on the
    > > > > regular lxcpath. The patch below changes the log file path to be
    > > > > based on lxcpath rather than LOGPATH when lxc is configured with
    > > > > --enable-configpath-log.
    > > > >
    > > > > I think that even in the normal non --enable-configpath-log case
    > > > > we should consider using lxcpath as the base and not having
    > > > > LOGPATH at all, as attempting to create the log files
    > > > > in /var/log is not going to work for regular users on their own
    > > > > lxcpath. If we want that, I'll update the patch to do that as
    > > > > well.
    > > >
    > > >
    > > > Perhaps we should do:
    > > >
    > > > 	1. If lxcpath == default_lxc_path(), then first choice is
    > > > 	   LOGPATH, second is lxcpath/container.log
    > > > 	2. when opening, if first choice fails, use second choice
    > > > 	   if there is any.
    > > >
    > > > That way 'system' containers will go to /var/log/lxc, as I think
    > > > they should.  Custom-lxcpath containers should never go
    > > > to /var/log/lxc, since their names could be dups of containers in
    > > > default_lxc_path(). And if the system is a weird one where
    > > > default_lxc_path is set up so that an unprivileged user can use
    > > > it, then we should log into $lxcpath.
    > >
    > > That sounds good to me. So these rules would apply in both the
    > > regular and --enable-configpath-log cases.
    
    I updated the patch to try to open the log file according to the
    choices given above. Along the way I cleaned up log.c a bit, making
    some things static, grouping external interfaces together, etc...
    Hopefully that doesn't add too much noise.
    
    > > > (Note this patch will trivially conflict with my new lxc_clone.c
    > > > causing it to fail to build - unfortunate result of timing)
    > >
    > > Yeah unfortunately this touches every lxc_log_init() caller. I can
    > > work on the above logic and re-submit after your new lxc_clone
    > > stuff goes in.
    >
    > No no, I'll just need to remember to update mine.  Don't hold up on
    > mine, this is just the nature of such collaboration  :)
    >
    > > Did you have any thoughts on the XXX what to pass in for lxcpath in
    > > lxc_init? Right now it just falls back to LOGPATH.
    >
    > No - that's a weird one, since lxc_init runs in the container.  If
    > there were only system containers I'd say always use LOGPATH.
    > However there are people (apparently :) who use container sharing the
    > host's rootfs...
    >
    > lxc-execute does know the lxcpath.  Perhaps we can simply have
    > src/lxc/execute.c:execute_start() look at handler->conf to see if a
    > rootfs is set.  If rootfs is NOT set, then pass lxcpath along to
    > lxc-init.  Then lxc-init can mostly do the same as the others?  (It
    > doesn't use src/lxc/arguments.c, so you'd have to add lxcpath to
    > options[] in lxc-init.c)
    
    So I did this, only to realize that lxc-init is passing "none" for the
    file anyway, so it currently doesn't intend to log. This makes me
    think that passing NULL for lxcpath is the right thing to do in
    this patch. If you want me to make it so lxc-init can log, I can do
    that but I think it should be in a different change :)
    
    --
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 53765b0..740a8d9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -1105,7 +1105,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	c->set_config_path = lxcapi_set_config_path;
 
 	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0)) {
+	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0, c->config_path)) {
 		fprintf(stderr, "failed to open log\n");
 		goto err;
 	}

commit e51d4895129209cec1c15bda2322136a03ec94b2
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Wed Apr 24 15:06:20 2013 -0400

    Allow multiple monitor clients
    
    This fixes a long standing issue that there could only be a single
    lxc-monitor per container.
    
    With this change, a new lxc-monitord daemon is spawned the first time
    lxc-monitor is called against the container and will accept connections
    from any subsequent lxc-monitor.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1df6a98..53765b0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -32,6 +32,7 @@
 #include <sys/wait.h>
 #include <errno.h>
 #include <lxc/utils.h>
+#include <lxc/monitor.h>
 
 lxc_log_define(lxc_container, lxc);
 
@@ -370,6 +371,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	if (daemonize) {
 		if (!lxc_container_get(c))
 			return false;
+		lxc_monitord_spawn(c->config_path);
 		pid_t pid = fork();
 		if (pid < 0) {
 			lxc_container_put(c);
@@ -560,7 +562,7 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 	}
 
 	/* container is already created if we have a config and rootfs.path is accessible */
-	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) 
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0)
 		goto out;
 
 	/* we're going to fork.  but since we'll wait for our child, we
@@ -826,7 +828,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 		return false;
 
 	/* container is already destroyed if we don't have a config and rootfs.path is not accessible */
-	if (!lxcapi_is_defined(c) && (!c->lxc_conf || !c->lxc_conf->rootfs.path || access(c->lxc_conf->rootfs.path, F_OK) != 0)) 
+	if (!lxcapi_is_defined(c) && (!c->lxc_conf || !c->lxc_conf->rootfs.path || access(c->lxc_conf->rootfs.path, F_OK) != 0))
 		return false;
 
 	pid = fork();

commit e6a19d2683629888175371ed2eeb8a49a7b44873
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Apr 15 15:59:12 2013 -0400

    fortify: minor cleanups for unused variables, stricter types
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ce751ea..1df6a98 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -630,7 +630,7 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 		newargv[nargs - 1] = NULL;
 
 		/* execute */
-		ret = execv(tpath, newargv);
+		execv(tpath, newargv);
 		SYSERROR("failed to execute template %s", tpath);
 		exit(1);
 	}
@@ -833,7 +833,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	if (pid < 0)
 		return false;
 	if (pid == 0) { // child
-		ret = execlp("lxc-destroy", "lxc-destroy", "-n", c->name, "-P", c->config_path, NULL);
+		execlp("lxc-destroy", "lxc-destroy", "-n", c->name, "-P", c->config_path, NULL);
 		perror("execl");
 		exit(1);
 	}

commit a741a85d8e241e9ca773f3cd7575d720837fcb51
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sun Apr 14 21:45:00 2013 -0500

    lxcapi_create: fix leak of tpath when a container already exists
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 27e86f9..ce751ea 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -561,7 +561,7 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 
 	/* container is already created if we have a config and rootfs.path is accessible */
 	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) 
-		return false;
+		goto out;
 
 	/* we're going to fork.  but since we'll wait for our child, we
 	   don't need to lxc_container_get */

commit 416707883893211a15c031b1f3589bc7cde9bf2b
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sun Apr 14 21:17:09 2013 -0500

    lxccontaienr: fix missing va_end in error case.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 926f089..27e86f9 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -719,8 +719,10 @@ static bool lxcapi_createl(struct lxc_container *c, char *t, ...)
 			break;
 		nargs++;
 		temp = realloc(args, (nargs+1) * sizeof(*args));
-		if (!temp)
+		if (!temp) {
+			va_end(ap);
 			goto out;
+		}
 		args = temp;
 		args[nargs - 1] = arg;
 	}

commit 586d4e9be1eb13cd9cb77cf6c56ce57e24623c44
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Sun Apr 14 21:12:58 2013 -0500

    lxcccontainer: add missing va_end found by coverity
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e09b3fb..926f089 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -440,8 +440,10 @@ static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
 			break;
 		n_inargs++;
 		temp = realloc(inargs, n_inargs * sizeof(*inargs));
-		if (!temp)
+		if (!temp) {
+			va_end(ap);
 			goto out;
+		}
 		inargs = temp;
 		inargs[n_inargs - 1] = strdup(arg);  // not sure if it's safe not to copy
 	}

commit 43d1aa34aab1c43bce8f083d024bf54f0246a884
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Apr 11 11:43:31 2013 -0500

    Fix up struct lxc_container locking
    
    1. in container_free, set c->privlock to NULL before calling
    sem_destroy, to prevent a window where another thread could call
    sem_wait(c->privlock) while c->privlock is not NULL but is already
    destroyed.
    
    2. in container_get, check for numthreads < 0 before calling lxclock.
    Once numthreads is 0, it never goes back up.
    
    Following is a comment added to lxccontainer.c:
    
    /*
     * Consider the following case:
    freer                         |    racing get()er
    ==================================================================
    lxc_container_put()           |   lxc_container_get()
    \ lxclock(c->privlock)        |   c->numthreads < 1? (no)
    \ c->numthreads = 0           |   \ lxclock(c->privlock) -> waits
    \ lxcunlock()                 |   \
    \ lxc_container_free()        |   \ lxclock() returns
                                  |   \ c->numthreads < 1 -> return 0
    \ \ (free stuff)              |
    \ \ sem_destroy(privlock)     |
    
     * When the get()er checks numthreads the first time, one of the following
     * is true:
     * 1. freer has set numthreads = 0.  get() returns 0
     * 2. freer is between lxclock and setting numthreads to 0.  get()er will
     *    sem_wait on privlock, get lxclock after freer() drops it, then see
     *    numthreads is 0 and exit without touching lxclock again..
     * 3. freer has not yet locked privlock.  If get()er runs first, then put()er
     *    will see --numthreads = 1 and not call lxc_container_free().
    */
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Seth Arnold <seth.arnold@canonical.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index a4376b4..e09b3fb 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -72,9 +72,10 @@ static void lxc_container_free(struct lxc_container *c)
 		c->slock = NULL;
 	}
 	if (c->privlock) {
-		sem_destroy(c->privlock);
-		free(c->privlock);
+		sem_t *l = c->privlock;
 		c->privlock = NULL;
+		sem_destroy(l);
+		free(l);
 	}
 	if (c->name) {
 		free(c->name);
@@ -91,11 +92,39 @@ static void lxc_container_free(struct lxc_container *c)
 	free(c);
 }
 
+/*
+ * Consider the following case:
+freer                         |    racing get()er
+==================================================================
+lxc_container_put()           |   lxc_container_get()
+\ lxclock(c->privlock)        |   c->numthreads < 1? (no)
+\ c->numthreads = 0           |   \ lxclock(c->privlock) -> waits
+\ lxcunlock()                 |   \
+\ lxc_container_free()        |   \ lxclock() returns
+                              |   \ c->numthreads < 1 -> return 0
+\ \ (free stuff)              |
+\ \ sem_destroy(privlock)     |
+
+ * When the get()er checks numthreads the first time, one of the following
+ * is true:
+ * 1. freer has set numthreads = 0.  get() returns 0
+ * 2. freer is between lxclock and setting numthreads to 0.  get()er will
+ *    sem_wait on privlock, get lxclock after freer() drops it, then see
+ *    numthreads is 0 and exit without touching lxclock again..
+ * 3. freer has not yet locked privlock.  If get()er runs first, then put()er
+ *    will see --numthreads = 1 and not call lxc_container_free().
+*/
+
 int lxc_container_get(struct lxc_container *c)
 {
 	if (!c)
 		return 0;
 
+	// if someone else has already started freeing the container, don't
+	// try to take the lock, which may be invalid
+	if (c->numthreads < 1)
+		return 0;
+
 	if (lxclock(c->privlock, 0))
 		return 0;
 	if (c->numthreads < 1) {

commit 5a3d2e1efa652ed68d1125c688bb1b9b91889778
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Apr 1 10:36:29 2013 -0400

    API shouldn't be calling create for already defined containers or destroy for non defined ones
    
    Currently it always calls create/destroy which might be confusing for the code
    that checks the return value of those calls to determine whether operation
    completed successfully or not.
    
    >>> c = lxc.Container("r")
    >>> c.create("ubuntu")
    True
    >>> c.create("ubuntu")
    True
    >>> c.create("ubuntu")
    True
    >>> c.create("ubuntu")
    True
    >>> c.create("ubuntu")
    >>> c.destroy()
    True
    >>> c.destroy()
    lxc-destroy: 'r' does not exist
    False
    >>> c.destroy()
    lxc-destroy: 'r' does not exist
    False
    
    New behaviour
    
    >>> c = lxc.Container("r")
    >>> c.create('ubuntu')
    True
    >>> c.create('ubuntu')
    False
    >>> c.destroy()
    True
    >>> c.destroy()
    False
    >>>
    
    Tested with following script;
    
    import lxc
    c = lxc.Container("abcdef")
    print ("set", c.set_config_item("lxc.utsname", "abcdef"))
    print ("save", c.save_config())
    print ("create", c.create("ubuntu"))
    print ("create", c.create("ubuntu"))
    print ("destroy", c.destroy())
    print ("destroy", c.destroy())
    print ("set", c.set_config_item("lxc.utsname", "abcdef"))
    print ("save", c.save_config())
    print ("destroy", c.destroy())
    print ("destroy", c.destroy())
    
    Signed-off-by: S.alar Onur <caglar@10ur.org>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 480c4f5..a4376b4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -523,14 +523,15 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 		goto out;
 	}
 
-	if (!create_container_dir(c))
-		goto out;
-
 	if (!c->save_config(c, NULL)) {
 		ERROR("failed to save starting configuration for %s\n", c->name);
 		goto out;
 	}
 
+	/* container is already created if we have a config and rootfs.path is accessible */
+	if (lxcapi_is_defined(c) && c->lxc_conf && c->lxc_conf->rootfs.path && access(c->lxc_conf->rootfs.path, F_OK) == 0) 
+		return false;
+
 	/* we're going to fork.  but since we'll wait for our child, we
 	   don't need to lxc_container_get */
 
@@ -767,6 +768,9 @@ static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 			return false;
 		}
 
+	if (!create_container_dir(c))
+		return false;
+
 	FILE *fout = fopen(alt_file, "w");
 	if (!fout)
 		return false;
@@ -788,6 +792,10 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	if (!c)
 		return false;
 
+	/* container is already destroyed if we don't have a config and rootfs.path is not accessible */
+	if (!lxcapi_is_defined(c) && (!c->lxc_conf || !c->lxc_conf->rootfs.path || access(c->lxc_conf->rootfs.path, F_OK) != 0)) 
+		return false;
+
 	pid = fork();
 	if (pid < 0)
 		return false;

commit b6b918a1d4f91da7bb41da202112ac8fddf947f7
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Mar 11 11:57:51 2013 -0400

    API: export lxc_get_version()
    
    Signed-off-by: Stphane Graber <stgraber@ubuntu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6569071..480c4f5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -25,6 +25,7 @@
 #include "confile.h"
 #include "cgroup.h"
 #include "commands.h"
+#include "version.h"
 #include "log.h"
 #include <unistd.h>
 #include <sys/types.h>
@@ -978,6 +979,11 @@ const char *lxc_get_default_config_path(void)
 	return default_lxc_path();
 }
 
+const char *lxc_get_version(void)
+{
+	return lxc_version();
+}
+
 struct lxc_container *lxc_container_new(const char *name, const char *configpath)
 {
 	struct lxc_container *c;

commit ae5c8b8ed5feb9a47c5007c986ce01ea39b5075f
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Mar 1 14:53:20 2013 -0600

    cgroup: improve support for multiple lxcpaths (v3)
    
    Add a monitor command to get the cgroup for a running container.  This
    allows container r1 started from /var/lib/lxc and container r1 started
    from /home/ubuntu/lxcbase to pick unique cgroup directories (which
    will be /sys/fs/cgroup/$subsys/lxc/r1 and .../r1-1), and all the lxc-*
    tools to get that path over the monitor at lxcpath.
    
    Rework the cgroup code.  Before, if /sys/fs/cgroup/$subsys/lxc/r1
    already existed, it would be moved to 'deadXXXXX', and a new r1 created.
    Instead, if r1 exists, use r1-1, r1-2, etc.
    
    I ended up removing both the use of cgroup.clone_children and support
    for ns cgroup.  Presumably we'll want to put support for ns cgroup
    back in for older kernels.  Instead of guessing whether or not we
    have clone_children support, just always explicitly do the only thing
    that feature buys us - set cpuset.{cpus,mems} for newly created cgroups.
    
    Note that upstream kernel is working toward strict hierarchical
    limit enforcements, which will be good for us.
    
    NOTE - I am changing the lxc_answer struct size.  This means that
    upgrades to this version while containers are running will result
    in lxc_* commands on pre-running containers will fail.
    
    Changelog: (v3)
       implement cgroup attach
       fix a subtle bug arising when we lxc_get_cgpath() returned
         STOPPED rather than -1 (STOPPED is 0, and 0 meant success).
       Rename some functions and add detailed comments above most.
       Drop all my lxc_attach changes in favor of those by Christian
         Seiler (which are mostly the same, but improved).
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 404f60a..6569071 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -945,7 +945,7 @@ static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys,
 	if (is_stopped_nolock(c))
 		goto err;
 
-	ret = lxc_cgroup_set(c->name, subsys, value);
+	ret = lxc_cgroup_set(c->name, subsys, value, c->config_path);
 	if (!ret)
 		b = true;
 err:
@@ -966,7 +966,7 @@ static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, c
 	if (is_stopped_nolock(c))
 		goto out;
 
-	ret = lxc_cgroup_get(c->name, subsys, retv, inlen);
+	ret = lxc_cgroup_get(c->name, subsys, retv, inlen, c->config_path);
 
 out:
 	lxcunlock(c->privlock);

commit 7f597314cdc6efe530f733e6caef6c6490af5ea2
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Mar 4 14:11:36 2013 -0600

    c api: send lxcpath to destroy command
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3eaf41e..404f60a 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -791,7 +791,7 @@ static bool lxcapi_destroy(struct lxc_container *c)
 	if (pid < 0)
 		return false;
 	if (pid == 0) { // child
-		ret = execlp("lxc-destroy", "lxc-destroy", "-n", c->name, NULL);
+		ret = execlp("lxc-destroy", "lxc-destroy", "-n", c->name, "-P", c->config_path, NULL);
 		perror("execl");
 		exit(1);
 	}

commit 63e414f8c128cdf391ae95c547509eb14c59f826
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Mar 4 13:29:52 2013 -0600

    c api -> createl: correctly handle 0 template args
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index bcfc8b6..3eaf41e 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -692,7 +692,8 @@ static bool lxcapi_createl(struct lxc_container *c, char *t, ...)
 		args[nargs - 1] = arg;
 	}
 	va_end(ap);
-	args[nargs] = NULL;
+	if (args)
+		args[nargs] = NULL;
 
 	bret = c->create(c, t, args);
 

commit 91e065ec331416b9d0941da86792bdbc8f10fadf
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Feb 19 14:39:31 2013 -0600

    remove redundant, too-early call to clearenv in api_start call.
    
    Ok, took a look, what happened was the clearenv calls used to be
    in lxc_start and lxccontainer and lxc_execute (do lxc_start() callers)
    themselves.  I moved those into do_start(), but the calls in
    lxccontainer.c were never removed.
    
    They should simply be removed altogether.  Trivial patch follows.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f24c39f..bcfc8b6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -369,21 +369,6 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		setsid();
 	}
 
-	if (clearenv()) {
-		SYSERROR("failed to clear environment");
-		/* don't error out though */
-	}
-
-	if (putenv("container=lxc")) {
-		fprintf(stderr, "failed to set environment variable");
-		if (daemonize) {
-			lxc_container_put(c);
-			exit(1);
-		} else {
-			return false;
-		}
-	}
-
 reboot:
 	conf->reboot = 0;
 	ret = lxc_start(c->name, argv, conf, c->config_path);

commit 9123e4718d0db98de2a2935cb2d0bcca1997a333
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Feb 14 10:30:55 2013 -0600

    lxc_monitor_open: prepend lxcpath
    
    This is needed for lxc_wait and lxc_monitor to handle lxcpath.  However,
    the full path name is limited to 108 bytes.  Should we use a md5sum of
    the lxcpath instead of the path itself?
    
    In any case, with this patch, lxc-wait and lxc-monitor work right with
    respect to multiple lxcpaths.
    
    The lxcpath is added to the lxc_handler to make it available most of the
    places we need it.
    
    I also remove function prototypes in monitor.h for two functions which
    are not defined or used anywhere.
    
    TODO: make cgroups tolerate multiple same-named containers.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1e257c0..f24c39f 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -195,7 +195,7 @@ static bool lxcapi_freeze(struct lxc_container *c)
 
 	if (lxclock(c->slock, 0))
 		return false;
-	ret = lxc_freeze(c->name);
+	ret = lxc_freeze(c->name, c->config_path);
 	lxcunlock(c->slock);
 	if (ret)
 		return false;
@@ -210,7 +210,7 @@ static bool lxcapi_unfreeze(struct lxc_container *c)
 
 	if (lxclock(c->slock, 0))
 		return false;
-	ret = lxc_unfreeze(c->name);
+	ret = lxc_unfreeze(c->name, c->config_path);
 	lxcunlock(c->slock);
 	if (ret)
 		return false;

commit 67e571de63a8e465dc8f1b17e16744a1d3fb552c
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Tue Feb 19 11:48:56 2013 -0500

    Introduce --lxcpath cmdline option, and make default_lxc_path() return const char *
    
    For the lxc-* C binaries, introduce a -P|--lxcpath command line option
    to override the system default.
    
    With this, I can
    
        lxc-create -t ubuntu -n r1
        lxc-create -t ubuntu -n r1 -P /home/ubuntu/lxcbase
        lxc-start -n r1 -d
        lxc-start -n r1 -d -P /home/ubuntu/lxcbase
        lxc-console -n r1 -d -P /home/ubuntu/lxcbase
        lxc-stop -n r1
    
    all working with the right containers (module cgroup stuff).
    
    To do:
        * lxc monitor needs to be made to handle cgroups.
          This is another very invasive one.  I started doing this as
          a part of this set, but that gets hairy, so I'm sending this
          separately.  Note that lxc-wait and lxc-monitor don't work
          without this, and there may be niggles in what I said works
          above - since start.c is doing lxc_monitor_send_state etc
          to the shared abstract unix domain socket.
        * Need to handle the cgroup conflicts.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3633047..1e257c0 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -272,7 +272,7 @@ static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 	if (!c)
 		return false;
 
-	ret = lxc_wait(c->name, state, timeout);
+	ret = lxc_wait(c->name, state, timeout, c->config_path);
 	return ret == 0;
 }
 
@@ -987,7 +987,7 @@ out:
 	return ret;
 }
 
-char *lxc_get_default_config_path(void)
+const char *lxc_get_default_config_path(void)
 {
 	return default_lxc_path();
 }
@@ -1006,7 +1006,7 @@ struct lxc_container *lxc_container_new(const char *name, const char *configpath
 	if (configpath)
 		c->config_path = strdup(configpath);
 	else
-		c->config_path = default_lxc_path();
+		c->config_path = strdup(default_lxc_path());
 
 	if (!c->config_path) {
 		fprintf(stderr, "Out of memory");

commit 83c98d825e4e644b18276dde5deaa555ee36b629
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Feb 11 17:31:39 2013 -0500

    Update Lua API
    
    Add [gs]et_config_path from API to Lua binding. Add additional optional
    parameter to container_new(). Add tests for these new Lua API bindings.
    Commit 2a59a681 changed the meaning of lxc_path_get() in the binding,
    causing lua script breakage. Reinstate original behavior of
    lxc_path_get() and rename it to lxc_default_config_path_get() to make
    its intent clearer.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 3b816e5..3633047 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -987,6 +987,10 @@ out:
 	return ret;
 }
 
+char *lxc_get_default_config_path(void)
+{
+	return default_lxc_path();
+}
 
 struct lxc_container *lxc_container_new(const char *name, const char *configpath)
 {

commit 13f5be6276100761eaeddd77b7b55fbec6b0c9ab
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Feb 11 14:43:41 2013 -0600

    pass lxcpath to lxc_command
    
    The previous lxcpath patches added support for a custom LXCPATH set
    through a system-wide configuration file.
    
    This was also exposed through the C api, so that a custom lxcpath could
    be set at the container object instanciation time, or set at runtime.
    
    However the command sock filename was always located under the global
    lxcpath, which could be confusing, and would be a problem for users
    with insufficient perms to the system-wide lxc path (i.e. if setting
    lxcpath to $HOME/lxcbase).  This patch changes that by passing the
    lxcpath to all callers of lxc_command().
    
    It remains to add an lxcpath command line argument to most of the
    command line tools (which are not using the C api) - lxc-start,
    lxc-info, lxc-stop, etc.
    
    At this point it becomes tempting to do something like
    
    	c = lxc.Container("r1", "/var/lib/lxc")
    	c2 = lxc.Container("r1", "$HOME/lxcbase")
    
    However, that's problematic - those two will use the same directory
    names for cgroup directories.
    
    What would be the best way to handle this?  One way (which I kind
    of like) is to give up on naming the cgroups after the container.
    use mkstemp for the cgroup name, let lxc keep track of the cgroup
    name based on the command socket, and make users use lxc-cgroup to get
    and change settings.
    
    Other ideas?
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 733cbb6..3b816e5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -161,7 +161,7 @@ static const char *lxcapi_state(struct lxc_container *c)
 		return NULL;
 	if (lxclock(c->slock, 0))
 		return NULL;
-	s = lxc_getstate(c->name);
+	s = lxc_getstate(c->name, c->config_path);
 	ret = lxc_state2str(s);
 	lxcunlock(c->slock);
 
@@ -171,7 +171,7 @@ static const char *lxcapi_state(struct lxc_container *c)
 static bool is_stopped_nolock(struct lxc_container *c)
 {
 	lxc_state_t s;
-	s = lxc_getstate(c->name);
+	s = lxc_getstate(c->name, c->config_path);
 	return (s == STOPPED);
 }
 
@@ -225,7 +225,7 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 
 	if (lxclock(c->slock, 0))
 		return -1;
-	ret = get_init_pid(c->name);
+	ret = get_init_pid(c->name, c->config_path);
 	lxcunlock(c->slock);
 	return ret;
 }
@@ -324,7 +324,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 	lxcunlock(c->privlock);
 
 	if (useinit) {
-		ret = lxc_execute(c->name, argv, 1, conf);
+		ret = lxc_execute(c->name, argv, 1, conf, c->config_path);
 		return ret == 0 ? true : false;
 	}
 
@@ -386,7 +386,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 
 reboot:
 	conf->reboot = 0;
-	ret = lxc_start(c->name, argv, conf);
+	ret = lxc_start(c->name, argv, conf, c->config_path);
 
 	if (conf->reboot) {
 		INFO("container requested reboot");
@@ -464,7 +464,7 @@ static bool lxcapi_stop(struct lxc_container *c)
 	if (!c)
 		return false;
 
-	ret = lxc_stop(c->name);
+	ret = lxc_stop(c->name, c->config_path);
 
 	return ret == 0;
 }

commit afeecbba0359d2b4404cdf896e6b6d0b5a8443b0
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Fri Feb 8 16:06:32 2013 -0600

    lxc api: fix some config_path oddities
    
    1. When calling c->set_config_path(), update configfile.  I.e. if we
    are setting the config_path to /var/lib/lxc, then the configfile should
    be changed to /var/lib/lxc/$container/config
    
    2. Add an optional configpath argument to lxc_container_new.  If NULL,
    then the default will be used (as before).  If set, then the passed-in
    path will be used.  This way you can do
    
    	c1 = lxc.Container("r1", "/var/lib/lxc");
    	c2 = lxc.Container("r2", "/home/user/lxcbase");
    
    (Note I did *not* implement the python or lua binding to pass that
    argument along)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 6f01645..733cbb6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -871,10 +871,45 @@ static const char *lxcapi_get_config_path(struct lxc_container *c)
 	return (const char *)(c->config_path);
 }
 
+/*
+ * not for export
+ * Just recalculate the c->configfile based on the
+ * c->config_path, which must be set.
+ * The lxc_container must be locked or not yet public.
+ */
+static bool set_config_filename(struct lxc_container *c)
+{
+	char *newpath;
+	int len, ret;
+
+	if (!c->config_path)
+		return false;
+
+	/* $lxc_path + "/" + c->name + "/" + "config" + '\0' */
+	len = strlen(c->config_path) + strlen(c->name) + strlen("config") + 3;
+	newpath = malloc(len);
+	if (!newpath)
+		return false;
+
+	ret = snprintf(newpath, len, "%s/%s/config", c->config_path, c->name);
+	if (ret < 0 || ret >= len) {
+		fprintf(stderr, "Error printing out config file name\n");
+		free(newpath);
+		return false;
+	}
+
+	if (c->configfile)
+		free(c->configfile);
+	c->configfile = newpath;
+
+	return true;
+}
+
 static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 {
 	char *p;
 	bool b = false;
+	char *oldpath = NULL;
 
 	if (!c)
 		return b;
@@ -883,13 +918,28 @@ static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
 		return b;
 
 	p = strdup(path);
-	if (!p)
+	if (!p) {
+		ERROR("Out of memory setting new lxc path");
 		goto err;
+	}
+
 	b = true;
 	if (c->config_path)
-		free(c->config_path);
+		oldpath = c->config_path;
 	c->config_path = p;
+
+	/* Since we've changed the config path, we have to change the
+	 * config file name too */
+	if (!set_config_filename(c)) {
+		ERROR("Out of memory setting new config filename");
+		b = false;
+		free(c->config_path);
+		c->config_path = oldpath;
+		oldpath = NULL;
+	}
 err:
+	if (oldpath)
+		free(oldpath);
 	lxcunlock(c->privlock);
 	return b;
 }
@@ -938,10 +988,9 @@ out:
 }
 
 
-struct lxc_container *lxc_container_new(const char *name)
+struct lxc_container *lxc_container_new(const char *name, const char *configpath)
 {
 	struct lxc_container *c;
-	int ret, len;
 
 	c = malloc(sizeof(*c));
 	if (!c) {
@@ -950,7 +999,11 @@ struct lxc_container *lxc_container_new(const char *name)
 	}
 	memset(c, 0, sizeof(*c));
 
-	c->config_path = default_lxc_path();
+	if (configpath)
+		c->config_path = strdup(configpath);
+	else
+		c->config_path = default_lxc_path();
+
 	if (!c->config_path) {
 		fprintf(stderr, "Out of memory");
 		goto err;
@@ -976,17 +1029,10 @@ struct lxc_container *lxc_container_new(const char *name)
 		goto err;
 	}
 
-	len = strlen(c->config_path)+strlen(c->name)+strlen("/config")+2;
-	c->configfile = malloc(len);
-	if (!c->configfile) {
+	if (!set_config_filename(c)) {
 		fprintf(stderr, "Error allocating config file pathname\n");
 		goto err;
 	}
-	ret = snprintf(c->configfile, len, "%s/%s/config", c->config_path, c->name);
-	if (ret < 0 || ret >= len) {
-		fprintf(stderr, "Error printing out config file name\n");
-		goto err;
-	}
 
 	if (file_exists(c->configfile))
 		lxcapi_load_config(c, NULL);

commit 2a59a68183e55e38beedb6442938e31eb7d4749c
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Wed Feb 6 15:11:19 2013 -0600

    Switch from use of LXCPATH to a configurable default_lxc_path
    
    Here is a patch to introduce a configurable system-wide
    lxcpath.  It seems to work with lxc-create, lxc-start,
    and basic python3 lxc usage through the api.
    
    For shell functions, a new /usr/share/lxc/lxc.functions is
    introduced which sets some of the basic global variables,
    including evaluating the right place for lxc_path.
    
    I have not converted any of the other python code, as I was
    not sure where we should keep the common functions (i.e.
    for now just default_lxc_path()).
    
    configure.ac: add an option for setting the global config file name.
    utils: add a default_lxc_path() function
    Use default_lxc_path in .c files
    define get_lxc_path() and set_lxc_path() in C api
    use get_lxc_path() in lua api
    create sh helper for getting default path from config file
    fix up scripts to use lxc.functions
    
    Changelog:
      feb6:
    	fix lxc_path in lxc.functions
    	utils.c: as Dwight pointed out, don't close a NULL fin.
    	utils.c: fix the parsing of lxcpath line
    	lxc-start: print which rcfile we are using
    	commands.c: As Dwight alluded to, the sockname handling was just
    	   ridiculous.  Clean that up.
    	use Dwight's recommendation for lxc.functions path: $datadir/lxc
    	make lxccontainer->get_config_path() return const char *
    		Per Dwight's suggestion, much nicer than returning strdup.
      feb6 (v2):
            lxccontainer: set c->config_path before using it.
    	convert legacy lxc-ls
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 9d491fc..6f01645 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -30,6 +30,7 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <errno.h>
+#include <lxc/utils.h>
 
 lxc_log_define(lxc_container, lxc);
 
@@ -82,6 +83,10 @@ static void lxc_container_free(struct lxc_container *c)
 		lxc_conf_free(c->lxc_conf);
 		c->lxc_conf = NULL;
 	}
+	if (c->config_path) {
+		free(c->config_path);
+		c->config_path = NULL;
+	}
 	free(c);
 }
 
@@ -483,11 +488,11 @@ static bool create_container_dir(struct lxc_container *c)
 	char *s;
 	int len, ret;
 
-	len = strlen(LXCPATH) + strlen(c->name) + 2;
+	len = strlen(c->config_path) + strlen(c->name) + 2;
 	s = malloc(len);
 	if (!s)
 		return false;
-	ret = snprintf(s, len, "%s/%s", LXCPATH, c->name);
+	ret = snprintf(s, len, "%s/%s", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		free(s);
 		return false;
@@ -577,11 +582,11 @@ static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 			exit(1);
 		newargv[0] = t;
 
-		len = strlen(LXCPATH) + strlen(c->name) + strlen("--path=") + 2;
+		len = strlen(c->config_path) + strlen(c->name) + strlen("--path=") + 2;
 		patharg = malloc(len);
 		if (!patharg)
 			exit(1);
-		ret = snprintf(patharg, len, "--path=%s/%s", LXCPATH, c->name);
+		ret = snprintf(patharg, len, "--path=%s/%s", c->config_path, c->name);
 		if (ret < 0 || ret >= len)
 			exit(1);
 		newargv[1] = patharg;
@@ -859,6 +864,37 @@ static char *lxcapi_config_file_name(struct lxc_container *c)
 	return strdup(c->configfile);
 }
 
+static const char *lxcapi_get_config_path(struct lxc_container *c)
+{
+	if (!c || !c->config_path)
+		return NULL;
+	return (const char *)(c->config_path);
+}
+
+static bool lxcapi_set_config_path(struct lxc_container *c, const char *path)
+{
+	char *p;
+	bool b = false;
+
+	if (!c)
+		return b;
+
+	if (lxclock(c->privlock, 0))
+		return b;
+
+	p = strdup(path);
+	if (!p)
+		goto err;
+	b = true;
+	if (c->config_path)
+		free(c->config_path);
+	c->config_path = p;
+err:
+	lxcunlock(c->privlock);
+	return b;
+}
+
+
 static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
 {
 	int ret;
@@ -914,6 +950,12 @@ struct lxc_container *lxc_container_new(const char *name)
 	}
 	memset(c, 0, sizeof(*c));
 
+	c->config_path = default_lxc_path();
+	if (!c->config_path) {
+		fprintf(stderr, "Out of memory");
+		goto err;
+	}
+
 	c->name = malloc(strlen(name)+1);
 	if (!c->name) {
 		fprintf(stderr, "Error allocating lxc_container name\n");
@@ -934,13 +976,13 @@ struct lxc_container *lxc_container_new(const char *name)
 		goto err;
 	}
 
-	len = strlen(LXCPATH)+strlen(c->name)+strlen("/config")+2;
+	len = strlen(c->config_path)+strlen(c->name)+strlen("/config")+2;
 	c->configfile = malloc(len);
 	if (!c->configfile) {
 		fprintf(stderr, "Error allocating config file pathname\n");
 		goto err;
 	}
-	ret = snprintf(c->configfile, len, "%s/%s/config", LXCPATH, c->name);
+	ret = snprintf(c->configfile, len, "%s/%s/config", c->config_path, c->name);
 	if (ret < 0 || ret >= len) {
 		fprintf(stderr, "Error printing out config file name\n");
 		goto err;
@@ -974,6 +1016,8 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->get_config_item = lxcapi_get_config_item;
 	c->get_cgroup_item = lxcapi_get_cgroup_item;
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
+	c->get_config_path = lxcapi_get_config_path;
+	c->set_config_path = lxcapi_set_config_path;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0)) {
@@ -981,10 +1025,6 @@ struct lxc_container *lxc_container_new(const char *name)
 		goto err;
 	}
 
-	/*
-	 * default configuration file is $LXCPATH/$NAME/config
-	 */
-
 	return c;
 
 err:

commit bb9702b539188bcc0c37f351633b087d1c22d2a6
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Feb 4 16:53:25 2013 -0500

    Rename /etc/lxc/lxc.conf to /etc/lxc/default.conf.
    
    This will soon be followed by the introduction of a "real" system wide
    /etc/lxc/lxc.conf storing global LXC settings.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 502a7a7..9d491fc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -762,7 +762,7 @@ static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv,
 
 
 /* default config file - should probably come through autoconf */
-#define LXC_DEFAULT_CONFIG "/etc/lxc/lxc.conf"
+#define LXC_DEFAULT_CONFIG "/etc/lxc/default.conf"
 static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	if (!alt_file)

commit 5e1e7aaf1e244405b813c0f9e20db2fc9e7f4d10
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Thu Jan 24 12:04:54 2013 -0600

    use a default per-container logfile
    
    Until now, if a lxc-* (i.e. lxc-start) command did not specify a logfile
    (with -o logfile), the default was effectively 'none'.  With this patch,
    the default becomes a per-container log file.
    
    If a container config file specifies 'lxc.logfile', that will override
    the default.  If a '-o logfile' argument is specifed at lxc-start,
    then that will override both the default and the configuration file
    entry.  Finally, '-o none' can be used to avoid having a logfile at
    all (in other words, the previous default), and that will override
    a lxc.logfile entry in the container configuration file.
    
    If the user does not have rights to open the default, then 'none' will
    be used.  However, in that case an error will show up on console.  (We
    can work on removing that if it annoys people, but I think it is
    helpful, at least while we're still ironing this set out)  If the user
    or container configuration file specified a logfile, and the user does
    not have rights to open the default, then the action will fail.
    
    One slight "mis-behavior" which I have not fixed (and may not fix) is
    that if a lxc.logfile is specified, the default logfile will still
    get created before we read the configuration file to find out there
    is a lxc.logfile entry.
    
    changelog:  Jan 24:
    
     add --enable-configpath-log configure option
    
     When we log to /var/lib/lxc/$container/$container.log, several things
     need to be done differently than when we log into /var/log/lxc (for
     instance).  So give it a configure option so we know what to do
    
     When the user specifies a logfile, we bail if we can't open it.  But
     when opening the default logfile, the user may not have rights to
     open it, so in that case ignore it and continue as if using 'none'.
    
     When using /var/lib/lxc/$c/$c.log, we use $LOGPATH/$name/$name.log.
     Otherwise, we use $LOGPATH/$name.log.
    
     When using /var/lib/lxc/$c/$c.log, don't try to create the log path
     /var/lib/lxc/$c.  It can only not exist if the container doesn't
     exist.  We don't want to create the directory in that case.  When
     using /var/log/lxc, then we do want to create the path if it does
     not exist.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5919d2c..502a7a7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -976,7 +976,7 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
 
 	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, NULL, "lxc_container", 0)) {
+	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0)) {
 		fprintf(stderr, "failed to open log\n");
 		goto err;
 	}

commit e6cde7418c4e697876f0041b888766ab4732812b
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Wed Jan 23 17:20:11 2013 -0500

    Revert "use a default per-container logfile"
    
    The logfile changes broke lxc-info and possibly more command line
    tools. Revert for now until we get those issues addressed.
    
    This reverts commit 74476cf144523530022d76cef3a558b0662b592f.

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 502a7a7..5919d2c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -976,7 +976,7 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
 
 	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0)) {
+	if (lxc_log_init(NULL, NULL, "lxc_container", 0)) {
 		fprintf(stderr, "failed to open log\n");
 		goto err;
 	}

commit 74476cf144523530022d76cef3a558b0662b592f
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Tue Jan 15 23:02:20 2013 -0600

    use a default per-container logfile
    
    [ Thanks to Stphane and Dwight for the feedback on the previous patch ]
    
    Until now, if a lxc-* (i.e. lxc-start) command did not specify a logfile
    (with -o logfile), the default was effectively 'none'.  With this patch,
    the default becomes $LOGPATH/<container>/<container>.log.  LOGPATH is
    specified at configure time with '--with-log-path='.  If unspecified, it
    is $LXCPATH, so that logs for container r2 will show up at
    /var/lib/lxc/r2/r2/log.  LOGPATH must exist, while lxc will make sure to
    create $LOGPATH/<name>.  As another example, Ubuntu will likely specify
    --with-log-path=/var/log/lxc (and place /var/log/lxc into
    debian/lxc.dirs), placing r2's logs in /var/log/lxc/r2/r2.log.
    
    If a container config file specifies 'lxc.logfile', that will override
    the default.  If a '-o logfile' argument is specifed at lxc-start,
    then that will override both the default and the configuration file
    entry.  Finally, '-o none' can be used to avoid having a logfile at
    all (in other words, the previous default), and that will override
    a lxc.logfile entry in the container configuration file.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 5919d2c..502a7a7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -976,7 +976,7 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->set_cgroup_item = lxcapi_set_cgroup_item;
 
 	/* we'll allow the caller to update these later */
-	if (lxc_log_init(NULL, NULL, "lxc_container", 0)) {
+	if (lxc_log_init(NULL, "none", NULL, "lxc_container", 0)) {
 		fprintf(stderr, "failed to open log\n");
 		goto err;
 	}

commit 964fe051e9dc21be6c52ccf5b9ff47a8aea396fc
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Thu Dec 20 16:14:49 2012 -0600

    Clear environment for container
    
    Clear env before starting a container.  Do it right before setting
    the container=lxc variable.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index fd77aac..5919d2c 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -364,6 +364,11 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv
 		setsid();
 	}
 
+	if (clearenv()) {
+		SYSERROR("failed to clear environment");
+		/* don't error out though */
+	}
+
 	if (putenv("container=lxc")) {
 		fprintf(stderr, "failed to set environment variable");
 		if (daemonize) {

commit d2e30e99b48084375071315336cd80a52b69a122
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Tue Dec 11 17:05:11 2012 -0500

    Fix race/corruption with multiple lxc-start, lxc-execute
    
    If you start more than one lxc-start/lxc-execute with the same name at the
    same time, or just do an lxc-start/lxc-execute with the name of a container
    that is already running, lxc doesn't figure out that the container with this
    name is already running until fairly late in the initialization process: ie
    when __lxc_start() -> lxc_poll() -> lxc_command_mainloop_add() attempts to
    create the same abstract socket name.
    
    By this point a fair amount of initialization has been done that actually
    messes up the running container. For example __lxc_start() -> lxc_spawn() ->
    lxc_cgroup_create() -> lxc_one_cgroup_create() -> try_to_move_cgname() moves
    the running container's cgroup to a name of deadXXXXXX.
    
    The solution in this patch is to use the atomic existence of the abstract
    socket name as the indicator that the container is already running.  To do
    so, I just refactored lxc_command_mainloop_add() into an lxc_command_init()
    routine that attempts to bind the socket, and ensure this is called earlier
    before much initialization has been done.
    
    In testing, I verified that maincmd_fd was still open at the time of lxc_fini,
    so the entire lifetime of the container's run should be covered. The only
    explicit close of this fd was in the reboot case of lxcapi_start(), which is
    now moved to lxc_fini(), which I think is more appropriate.
    
    Even though it is not checked any more, set maincmd_fd to -1 instead of 0 to
    indicate its not open since 0 could be a valid fd.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 1345ab5..fd77aac 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -381,9 +381,6 @@ reboot:
 	if (conf->reboot) {
 		INFO("container requested reboot");
 		conf->reboot = 0;
-		if (conf->maincmd_fd)
-			close(conf->maincmd_fd);
-		conf->maincmd_fd = 0;
 		goto reboot;
 	}
 

commit 794dd12099da53adec33e8291f0f470629f8b8f6
Author: Serge Hallyn <serge.hallyn@canonical.com>
Date:   Thu Dec 6 18:41:15 2012 -0600

    api: add set_cgroup_item and get_cgroup_item (to c api)
    
    set_cgroup_item takes a pointer to a running container, a cgroup subsystem
    name, and a char *value and it mimicks
    	'lxc-cgroup -n containername subsys value'
    get_cgroup_item takes a pointer to a running container, a a cgroup
    subsystem name, a destination value * and the length of the value being
    sent in, and returns the length of what was read from the cgroup file.
    If a 0 len is passed in, then the length of the file is returned.  So
    you can do
    
    	len = c->get_cgroup_item(c, "devices.list", NULL, 0);
    	v = malloc(len+1);
    	ret = c->get_cgroup_item(c, "devices.list", v, len);
    
    to read the whole file.
    
    This patch also disables the lxc-init part of the startone test, which
    was failing because lxc-init has been moved due to multiarch issues.
    The test is salvagable, but saving it was beyond this effort.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index d25b848..1345ab5 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -163,6 +163,13 @@ static const char *lxcapi_state(struct lxc_container *c)
 	return ret;
 }
 
+static bool is_stopped_nolock(struct lxc_container *c)
+{
+	lxc_state_t s;
+	s = lxc_getstate(c->name);
+	return (s == STOPPED);
+}
+
 static bool lxcapi_is_running(struct lxc_container *c)
 {
 	const char *s;
@@ -850,6 +857,49 @@ static char *lxcapi_config_file_name(struct lxc_container *c)
 	return strdup(c->configfile);
 }
 
+static bool lxcapi_set_cgroup_item(struct lxc_container *c, const char *subsys, const char *value)
+{
+	int ret;
+	bool b = false;
+
+	if (!c)
+		return false;
+
+	if (lxclock(c->privlock, 0))
+		return false;
+
+	if (is_stopped_nolock(c))
+		goto err;
+
+	ret = lxc_cgroup_set(c->name, subsys, value);
+	if (!ret)
+		b = true;
+err:
+	lxcunlock(c->privlock);
+	return b;
+}
+
+static int lxcapi_get_cgroup_item(struct lxc_container *c, const char *subsys, char *retv, int inlen)
+{
+	int ret = -1;
+
+	if (!c || !c->lxc_conf)
+		return -1;
+
+	if (lxclock(c->privlock, 0))
+		return -1;
+
+	if (is_stopped_nolock(c))
+		goto out;
+
+	ret = lxc_cgroup_get(c->name, subsys, retv, inlen);
+
+out:
+	lxcunlock(c->privlock);
+	return ret;
+}
+
+
 struct lxc_container *lxc_container_new(const char *name)
 {
 	struct lxc_container *c;
@@ -920,6 +970,8 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->shutdown = lxcapi_shutdown;
 	c->clear_config_item = lxcapi_clear_config_item;
 	c->get_config_item = lxcapi_get_config_item;
+	c->get_cgroup_item = lxcapi_get_cgroup_item;
+	c->set_cgroup_item = lxcapi_set_cgroup_item;
 
 	/* we'll allow the caller to update these later */
 	if (lxc_log_init(NULL, NULL, "lxc_container", 0)) {

commit 4a85ce2ad0d0b24680712c60a6576713d209b7ad
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon Dec 3 12:53:46 2012 -0600

    lxc_conf logfile and loglevel support
    
    Add 'lxc.logfile' and 'lxc.loglevel' config items.  Values provided on
    the command line override the config items.
    
    Have lxccontainer not set a default loglevel and logfile.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e41fd0d..d25b848 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -922,7 +922,7 @@ struct lxc_container *lxc_container_new(const char *name)
 	c->get_config_item = lxcapi_get_config_item;
 
 	/* we'll allow the caller to update these later */
-	if (lxc_log_init("/var/log/lxccontainer.log", "trace", "lxc_container", 0)) {
+	if (lxc_log_init(NULL, NULL, "lxc_container", 0)) {
 		fprintf(stderr, "failed to open log\n");
 		goto err;
 	}

commit 12a50cc6ab5c8a4aa0bcb7ddcd7095265f7bb62b
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 15:28:14 2012 -0500

    Make config api items const
    
    This makes it easier to write a binding, and presents a cleaner API. Use
    strdupa in a few places to get mutable strings for tokenizing / parsing.
    Also change the argv type in lxcapi_start and lxcapi_create to match
    that of execv(3).
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index cc91e05..e41fd0d 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -218,7 +218,7 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 	return ret;
 }
 
-static bool load_config_locked(struct lxc_container *c, char *fname)
+static bool load_config_locked(struct lxc_container *c, const char *fname)
 {
 	if (!c->lxc_conf)
 		c->lxc_conf = lxc_conf_init();
@@ -227,10 +227,10 @@ static bool load_config_locked(struct lxc_container *c, char *fname)
 	return false;
 }
 
-static bool lxcapi_load_config(struct lxc_container *c, char *alt_file)
+static bool lxcapi_load_config(struct lxc_container *c, const char *alt_file)
 {
 	bool ret = false;
-	char *fname;
+	const char *fname;
 	if (!c)
 		return false;
 
@@ -253,7 +253,7 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 	c->daemonize = 1;
 }
 
-static bool lxcapi_wait(struct lxc_container *c, char *state, int timeout)
+static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
 {
 	int ret;
 
@@ -284,7 +284,7 @@ static bool wait_on_daemonized_start(struct lxc_container *c)
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
  */
-static bool lxcapi_start(struct lxc_container *c, int useinit, char ** argv)
+static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
 {
 	int ret;
 	struct lxc_conf *conf;
@@ -499,7 +499,7 @@ static bool create_container_dir(struct lxc_container *c)
  * for ->create, argv contains the arguments to pass to the template,
  * terminated by NULL.  If no arguments, you can just pass NULL.
  */
-static bool lxcapi_create(struct lxc_container *c, char *t, char **argv)
+static bool lxcapi_create(struct lxc_container *c, char *t, char *const argv[])
 {
 	bool bret = false;
 	pid_t pid;
@@ -703,7 +703,7 @@ out:
 	return bret;
 }
 
-static bool lxcapi_clear_config_item(struct lxc_container *c, char *key)
+static bool lxcapi_clear_config_item(struct lxc_container *c, const char *key)
 {
 	int ret;
 
@@ -717,7 +717,7 @@ static bool lxcapi_clear_config_item(struct lxc_container *c, char *key)
 	return ret == 0;
 }
 
-static int lxcapi_get_config_item(struct lxc_container *c, char *key, char *retv, int inlen)
+static int lxcapi_get_config_item(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	int ret;
 
@@ -731,7 +731,7 @@ static int lxcapi_get_config_item(struct lxc_container *c, char *key, char *retv
 	return ret;
 }
 
-static int lxcapi_get_keys(struct lxc_container *c, char *key, char *retv, int inlen)
+static int lxcapi_get_keys(struct lxc_container *c, const char *key, char *retv, int inlen)
 {
 	if (!key)
 		return lxc_listconfigs(retv, inlen);
@@ -754,7 +754,7 @@ static int lxcapi_get_keys(struct lxc_container *c, char *key, char *retv, int i
 
 /* default config file - should probably come through autoconf */
 #define LXC_DEFAULT_CONFIG "/etc/lxc/lxc.conf"
-static bool lxcapi_save_config(struct lxc_container *c, char *alt_file)
+static bool lxcapi_save_config(struct lxc_container *c, const char *alt_file)
 {
 	if (!alt_file)
 		alt_file = c->configfile;
@@ -815,7 +815,7 @@ again:
 	return WEXITSTATUS(status) == 0;
 }
 
-static bool lxcapi_set_config_item(struct lxc_container *c, char *key, char *v)
+static bool lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)
 {
 	int ret;
 	bool b = false;
@@ -850,7 +850,7 @@ static char *lxcapi_config_file_name(struct lxc_container *c)
 	return strdup(c->configfile);
 }
 
-struct lxc_container *lxc_container_new(char *name)
+struct lxc_container *lxc_container_new(const char *name)
 {
 	struct lxc_container *c;
 	int ret, len;

commit b45a7402bf5e6a0c4d03c5a428670bad7c1b4c8e
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 15:57:53 2012 -0500

    Use autoconf LXCPATH instead of hardcoded LXCDIR
    
    LXCDIR is only used in lxc_container_new, whereas LXCPATH is used throughout
    the rest of lxc, and even in the same file as lxc_container_new (for example
    create_container_dir()).
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ed2c483..cc91e05 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -882,13 +882,13 @@ struct lxc_container *lxc_container_new(char *name)
 		goto err;
 	}
 
-	len = strlen(LXCDIR)+strlen(c->name)+strlen("/config")+2;
+	len = strlen(LXCPATH)+strlen(c->name)+strlen("/config")+2;
 	c->configfile = malloc(len);
 	if (!c->configfile) {
 		fprintf(stderr, "Error allocating config file pathname\n");
 		goto err;
 	}
-	ret = snprintf(c->configfile, len, "%s/%s/config", LXCDIR, c->name);
+	ret = snprintf(c->configfile, len, "%s/%s/config", LXCPATH, c->name);
 	if (ret < 0 || ret >= len) {
 		fprintf(stderr, "Error printing out config file name\n");
 		goto err;
@@ -928,7 +928,7 @@ struct lxc_container *lxc_container_new(char *name)
 	}
 
 	/*
-	 * default configuration file is $LXCDIR/$NAME/config
+	 * default configuration file is $LXCPATH/$NAME/config
 	 */
 
 	return c;

commit 83cab6e068b64f733dbdd156319b7716b054853a
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 12:18:13 2012 -0500

    Ensure argv passed by createl to create is NULL terminated
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ac995a6..ed2c483 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -686,13 +686,14 @@ static bool lxcapi_createl(struct lxc_container *c, char *t, ...)
 		if (!arg)
 			break;
 		nargs++;
-		temp = realloc(args, nargs * sizeof(*args));
+		temp = realloc(args, (nargs+1) * sizeof(*args));
 		if (!temp)
 			goto out;
 		args = temp;
 		args[nargs - 1] = arg;
 	}
 	va_end(ap);
+	args[nargs] = NULL;
 
 	bret = c->create(c, t, args);
 

commit d95db067d28dd0480c2bd71f85668fa8d37e9064
Author: Dwight Engen <dwight.engen@oracle.com>
Date:   Mon Nov 26 12:18:06 2012 -0500

    Free allocated configuration memory
    
    Most of these were found with valgrind by repeatedly doing lxc_container_new
    followed by lxc_container_put. Also free memory when config items are
    re-parsed, as happens when lxcapi_set_config_item() is called. Refactored
    path type config items to use a common underlying routine.
    
    Signed-off-by: Dwight Engen <dwight.engen@oracle.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 37f5ed7..ac995a6 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -65,6 +65,10 @@ static void lxc_container_free(struct lxc_container *c)
 		free(c->error_string);
 		c->error_string = NULL;
 	}
+	if (c->slock) {
+		sem_close(c->slock);
+		c->slock = NULL;
+	}
 	if (c->privlock) {
 		sem_destroy(c->privlock);
 		free(c->privlock);
@@ -74,11 +78,10 @@ static void lxc_container_free(struct lxc_container *c)
 		free(c->name);
 		c->name = NULL;
 	}
-	/*
-	 * XXX TODO
-	 * note, c->lxc_conf is going to have to be freed, but the fn
-	 * to do that hasn't been written yet near as I can tell
-	 */
+	if (c->lxc_conf) {
+		lxc_conf_free(c->lxc_conf);
+		c->lxc_conf = NULL;
+	}
 	free(c);
 }
 

commit f6144ed443995a7d5bdbae217c6ba3ef3e341d16
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Thu Sep 13 09:41:01 2012 -0500

    api shutdown: don't c->stop() if already stopped.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index ea39710..37f5ed7 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -655,7 +655,7 @@ static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
 		return true;
 	kill(pid, SIGPWR);
 	retv = c->wait(c, "STOPPED", timeout);
-	if (timeout > 0) {
+	if (!retv && timeout > 0) {
 		c->stop(c);
 		retv = c->wait(c, "STOPPED", 0); // 0 means don't wait
 	}

commit 697fa6390c5d52eaef36a15c31b68d093a0d0941
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Fri Sep 7 11:14:04 2012 -0500

    dual-fork for daemonized fork in lxcapi-start
    
    So the container will be reparented by init.  Otherwise children of the
    lxc-start might be reaped by python3 rather than lxc-start.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index c8dc8c4..ea39710 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -265,8 +265,15 @@ static bool lxcapi_wait(struct lxc_container *c, char *state, int timeout)
 static bool wait_on_daemonized_start(struct lxc_container *c)
 {
 	/* we'll probably want to make this timeout configurable? */
-	int timeout = 5;
+	int timeout = 5, ret, status;
 
+	/*
+	 * our child is going to fork again, then exit.  reap the
+	 * child
+	 */
+	ret = wait(&status);
+	if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
+		DEBUG("failed waiting for first dual-fork child");
 	return lxcapi_wait(c, "RUNNING", timeout);
 }
 
@@ -325,6 +332,14 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char ** argv)
 		}
 		if (pid != 0)
 			return wait_on_daemonized_start(c);
+		/* second fork to be reparented by init */
+		pid = fork();
+		if (pid < 0) {
+			SYSERROR("Error doing dual-fork");
+			return false;
+		}
+		if (pid != 0)
+			exit(0);
 		/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
 		if (chdir("/")) {
 			SYSERROR("Error chdir()ing to /.");

commit 8eb5694bafff6be81a35542c584e82817a1e0852
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Wed Sep 5 21:55:38 2012 -0500

    Add lxc_conf_free()
    
    Then after lxcapi container->create(), free whatever lxc_conf may be
    loaded and reload from the newly created configuration file.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 471fecc..c8dc8c4 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -215,6 +215,15 @@ static pid_t lxcapi_init_pid(struct lxc_container *c)
 	return ret;
 }
 
+static bool load_config_locked(struct lxc_container *c, char *fname)
+{
+	if (!c->lxc_conf)
+		c->lxc_conf = lxc_conf_init();
+	if (c->lxc_conf && !lxc_config_read(fname, c->lxc_conf))
+		return true;
+	return false;
+}
+
 static bool lxcapi_load_config(struct lxc_container *c, char *alt_file)
 {
 	bool ret = false;
@@ -229,10 +238,7 @@ static bool lxcapi_load_config(struct lxc_container *c, char *alt_file)
 		return false;
 	if (lxclock(c->slock, 0))
 		return false;
-	if (!c->lxc_conf)
-		c->lxc_conf = lxc_conf_init();
-	if (c->lxc_conf && !lxc_config_read(fname, c->lxc_conf))
-		ret = true;
+	ret = load_config_locked(c, fname);
 	lxcunlock(c->slock);
 	return ret;
 }
@@ -596,11 +602,18 @@ again:
 		goto out_unlock;
 	}
 
-	if (WEXITSTATUS(status) != 0)
+	if (WEXITSTATUS(status) != 0) {
 		ERROR("container creation template for %s exited with %d\n",
 		      c->name, WEXITSTATUS(status));
-	else
-		bret = true;
+		goto out_unlock;
+	}
+
+	// now clear out the lxc_conf we have, reload from the created
+	// container
+	if (c->lxc_conf)
+		lxc_conf_free(c->lxc_conf);
+	c->lxc_conf = NULL;
+	bret = load_config_locked(c, c->configfile);
 
 out_unlock:
 	lxcunlock(c->slock);

commit 4a7c7daa260467f3c9b234495bf3283fe31c01cb
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Sep 4 14:18:03 2012 -0500

    Fix passing non-const char* in for const char*
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index 840679b..471fecc 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -906,7 +906,7 @@ err:
 	return NULL;
 }
 
-int lxc_get_wait_states(char **states)
+int lxc_get_wait_states(const char **states)
 {
 	int i;
 

commit c278cef2ecd6fc42132d02f982e113414f5f9ce4
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Date:   Tue Sep 4 14:10:40 2012 -0500

    check chdir(/) return value
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index e88460b..840679b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -320,7 +320,10 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char ** argv)
 		if (pid != 0)
 			return wait_on_daemonized_start(c);
 		/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
-		chdir("/");
+		if (chdir("/")) {
+			SYSERROR("Error chdir()ing to /.");
+			return false;
+		}
 		close(0);
 		close(1);
 		close(2);

commit 7a44c8b447c4cac2b71bf842a61440bae9caf918
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Aug 27 19:01:36 2012 -0400

    When starting a container daemonized, wait for it to reach RUNNING state before returning the result of start().
    
    If the container doesn't reach RUNNING state in 5 seconds, a failure will be
    returned to the user.
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
index f61ba00..e88460b 100644
--- a/src/lxc/lxccontainer.c
+++ b/src/lxc/lxccontainer.c
@@ -244,6 +244,26 @@ static void lxcapi_want_daemonize(struct lxc_container *c)
 	c->daemonize = 1;
 }
 
+static bool lxcapi_wait(struct lxc_container *c, char *state, int timeout)
+{
+	int ret;
+
+	if (!c)
+		return false;
+
+	ret = lxc_wait(c->name, state, timeout);
+	return ret == 0;
+}
+
+
+static bool wait_on_daemonized_start(struct lxc_container *c)
+{
+	/* we'll probably want to make this timeout configurable? */
+	int timeout = 5;
+
+	return lxcapi_wait(c, "RUNNING", timeout);
+}
+
 /*
  * I can't decide if it'd be more convenient for callers if we accept '...',
  * or a null-terminated array (i.e. execl vs execv)
@@ -298,7 +318,7 @@ static bool lxcapi_start(struct lxc_container *c, int useinit, char ** argv)
 			return false;
 		}
 		if (pid != 0)
-			return true;
+			return wait_on_daemonized_start(c);
 		/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
 		chdir("/");
 		close(0);
@@ -408,17 +428,6 @@ static bool lxcapi_stop(struct lxc_container *c)
 	return ret == 0;
 }
 
-static bool lxcapi_wait(struct lxc_container *c, char *state, int timeout)
-{
-	int ret;
-
-	if (!c)
-		return false;
-
-	ret = lxc_wait(c->name, state, timeout);
-	return ret == 0;
-}
-
 static bool valid_template(char *t)
 {
 	struct stat statbuf;

commit 72d0e1cb2facaa4b8ba2f15e311d6bb9491badb7
Author: Stphane Graber <stgraber@ubuntu.com>
Date:   Mon Aug 27 18:53:00 2012 -0400

    Merge the liblxc API work by Serge Hallyn.
    
    This turns liblxc into a public library implementing a container structure.
    The container structure is meant to cover most LXC commands and can easily be
    used to write bindings in other programming languages.
    
    More information on the new functions can be found in src/lxc/lxccontainer.h
    Test programs using the API can also be found in src/tests/
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Stphane Graber <stgraber@ubuntu.com>

diff --git a/src/lxc/lxccontainer.c b/src/lxc/lxccontainer.c
new file mode 100644
index 0000000..f61ba00
--- /dev/null
+++ b/src/lxc/lxccontainer.c
@@ -0,0 +1,905 @@
+/* liblxcapi
+ *
+ * Copyright  2012 Serge Hallyn <serge.hallyn@ubuntu.com>.
+ * Copyright  2012 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "lxc.h"
+#include "state.h"
+#include "lxccontainer.h"
+#include "conf.h"
+#include "config.h"
+#include "confile.h"
+#include "cgroup.h"
+#include "commands.h"
+#include "log.h"
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+
+lxc_log_define(lxc_container, lxc);
+
+/* LOCKING
+ * c->privlock protects the struct lxc_container from multiple threads.
+ * c->slock protects the on-disk container data
+ * NOTHING mutexes two independent programs with their own struct
+ * lxc_container for the same c->name, between API calls.  For instance,
+ * c->config_read(); c->start();  Between those calls, data on disk
+ * could change (which shouldn't bother the caller unless for instance
+ * the rootfs get moved).  c->config_read(); update; c->config_write();
+ * Two such updaters could race.  The callers should therefore check their
+ * results.  Trying to prevent that would necessarily expose us to deadlocks
+ * due to hung callers.  So I prefer to keep the locks only within our own
+ * functions, not across functions.
+ *
+ * If you're going to fork while holding a lxccontainer, increment
+ * c->numthreads (under privlock) before forking.  When deleting,
+ * decrement numthreads under privlock, then if it hits 0 you can delete.
+ * Do not ever use a lxccontainer whose numthreads you did not bump.
+ */
+
+static void lxc_container_free(struct lxc_container *c)
+{
+	if (!c)
+		return;
+
+	if (c->configfile) {
+		free(c->configfile);
+		c->configfile = NULL;
+	}
+	if (c->error_string) {
+		free(c->error_string);
+		c->error_string = NULL;
+	}
+	if (c->privlock) {
+		sem_destroy(c->privlock);
+		free(c->privlock);
+		c->privlock = NULL;
+	}
+	if (c->name) {
+		free(c->name);
+		c->name = NULL;
+	}
+	/*
+	 * XXX TODO
+	 * note, c->lxc_conf is going to have to be freed, but the fn
+	 * to do that hasn't been written yet near as I can tell
+	 */
+	free(c);
+}
+
+int lxc_container_get(struct lxc_container *c)
+{
+	if (!c)
+		return 0;
+
+	if (lxclock(c->privlock, 0))
+		return 0;
+	if (c->numthreads < 1) {
+		// bail without trying to unlock, bc the privlock is now probably
+		// in freed memory
+		return 0;
+	}
+	c->numthreads++;
+	lxcunlock(c->privlock);
+	return 1;
+}
+
+int lxc_container_put(struct lxc_container *c)
+{
+	if (!c)
+		return -1;
+	if (lxclock(c->privlock, 0))
+		return -1;
+	if (--c->numthreads < 1) {
+		lxcunlock(c->privlock);
+		lxc_container_free(c);
+		return 1;
+	}
+	lxcunlock(c->privlock);
+	return 0;
+}
+
+static bool file_exists(char *f)
+{
+	struct stat statbuf;
+
+	return stat(f, &statbuf) == 0;
+}
+
+static bool lxcapi_is_defined(struct lxc_container *c)
+{
+	struct stat statbuf;
+	bool ret = false;
+	int statret;
+
+	if (!c)
+		return false;
+
+	if (lxclock(c->privlock, 0))
+		return false;
+	if (!c->configfile)
+		goto out;
+	statret = stat(c->configfile, &statbuf);
+	if (statret != 0)
+		goto out;
+	ret = true;
+
+out:
+	lxcunlock(c->privlock);
+	return ret;
+}
+
+static const char *lxcapi_state(struct lxc_container *c)
+{
+	const char *ret;
+	lxc_state_t s;
+
+	if (!c)
+		return NULL;
+	if (lxclock(c->slock, 0))
+		return NULL;
+	s = lxc_getstate(c->name);
+	ret = lxc_state2str(s);
+	lxcunlock(c->slock);
+
+	return ret;
+}
+
+static bool lxcapi_is_running(struct lxc_container *c)
+{
+	const char *s;
+
+	if (!c)
+		return false;
+	s = lxcapi_state(c);
+	if (!s || strcmp(s, "STOPPED") == 0)
+		return false;
+	return true;
+}
+
+static bool lxcapi_freeze(struct lxc_container *c)
+{
+	int ret;
+	if (!c)
+		return false;
+
+	if (lxclock(c->slock, 0))
+		return false;
+	ret = lxc_freeze(c->name);
+	lxcunlock(c->slock);
+	if (ret)
+		return false;
+	return true;
+}
+
+static bool lxcapi_unfreeze(struct lxc_container *c)
+{
+	int ret;
+	if (!c)
+		return false;
+
+	if (lxclock(c->slock, 0))
+		return false;
+	ret = lxc_unfreeze(c->name);
+	lxcunlock(c->slock);
+	if (ret)
+		return false;
+	return true;
+}
+
+static pid_t lxcapi_init_pid(struct lxc_container *c)
+{
+	pid_t ret;
+	if (!c)
+		return -1;
+
+	if (lxclock(c->slock, 0))
+		return -1;
+	ret = get_init_pid(c->name);
+	lxcunlock(c->slock);
+	return ret;
+}
+
+static bool lxcapi_load_config(struct lxc_container *c, char *alt_file)
+{
+	bool ret = false;
+	char *fname;
+	if (!c)
+		return false;
+
+	fname = c->configfile;
+	if (alt_file)
+		fname = alt_file;
+	if (!fname)
+		return false;
+	if (lxclock(c->slock, 0))
+		return false;
+	if (!c->lxc_conf)
+		c->lxc_conf = lxc_conf_init();
+	if (c->lxc_conf && !lxc_config_read(fname, c->lxc_conf))
+		ret = true;
+	lxcunlock(c->slock);
+	return ret;
+}
+
+static void lxcapi_want_daemonize(struct lxc_container *c)
+{
+	if (!c)
+		return;
+	c->daemonize = 1;
+}
+
+/*
+ * I can't decide if it'd be more convenient for callers if we accept '...',
+ * or a null-terminated array (i.e. execl vs execv)
+ */
+static bool lxcapi_start(struct lxc_container *c, int useinit, char ** argv)
+{
+	int ret;
+	struct lxc_conf *conf;
+	int daemonize = 0;
+	char *default_args[] = {
+		"/sbin/init",
+		'\0',
+	};
+
+	/* container exists */
+	if (!c)
+		return false;
+	/* container has been setup */
+	if (!c->lxc_conf)
+		return false;
+
+	/* is this app meant to be run through lxcinit, as in lxc-execute? */
+	if (useinit && !argv)
+		return false;
+
+	if (lxclock(c->privlock, 0))
+		return false;
+	conf = c->lxc_conf;
+	daemonize = c->daemonize;
+	lxcunlock(c->privlock);
+
+	if (useinit) {
+		ret = lxc_execute(c->name, argv, 1, conf);
+		return ret == 0 ? true : false;
+	}
+
+	if (!argv)
+		argv = default_args;
+
+	/*
+	* say, I'm not sure - what locks do we want here?  Any?
+	* Is liblxc's locking enough here to protect the on disk
+	* container?  We don't want to exclude things like lxc_info
+	* while container is running...
+	*/
+	if (daemonize) {
+		if (!lxc_container_get(c))
+			return false;
+		pid_t pid = fork();
+		if (pid < 0) {
+			lxc_container_put(c);
+			return false;
+		}
+		if (pid != 0)
+			return true;
+		/* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
+		chdir("/");
+		close(0);
+		close(1);
+		close(2);
+		open("/dev/null", O_RDONLY);
+		open("/dev/null", O_RDWR);
+		open("/dev/null", O_RDWR);
+		setsid();
+	}
+
+	if (putenv("container=lxc")) {
+		fprintf(stderr, "failed to set environment variable");
+		if (daemonize) {
+			lxc_container_put(c);
+			exit(1);
+		} else {
+			return false;
+		}
+	}
+
+reboot:
+	conf->reboot = 0;
+	ret = lxc_start(c->name, argv, conf);
+
+	if (conf->reboot) {
+		INFO("container requested reboot");
+		conf->reboot = 0;
+		if (conf->maincmd_fd)
+			close(conf->maincmd_fd);
+		conf->maincmd_fd = 0;
+		goto reboot;
+	}
+
+	if (daemonize) {
+		lxc_container_put(c);
+		exit (ret == 0 ? true : false);
+	} else {
+		return (ret == 0 ? true : false);
+	}
+}
+
+/*
+ * note there MUST be an ending NULL
+ */
+static bool lxcapi_startl(struct lxc_container *c, int useinit, ...)
+{
+	va_list ap;
+	char **inargs = NULL, **temp;
+	int n_inargs = 0;
+	bool bret = false;
+
+	/* container exists */
+	if (!c)
+		return false;
+
+	/* build array of arguments if any */
+	va_start(ap, useinit);
+	while (1) {
+		char *arg;
+		arg = va_arg(ap, char *);
+		if (!arg)
+			break;
+		n_inargs++;
+		temp = realloc(inargs, n_inargs * sizeof(*inargs));
+		if (!temp)
+			goto out;
+		inargs = temp;
+		inargs[n_inargs - 1] = strdup(arg);  // not sure if it's safe not to copy
+	}
+	va_end(ap);
+
+	/* add trailing NULL */
+	if (n_inargs) {
+		n_inargs++;
+		temp = realloc(inargs, n_inargs * sizeof(*inargs));
+		if (!temp)
+			goto out;
+		inargs = temp;
+		inargs[n_inargs - 1] = NULL;
+	}
+
+	bret = lxcapi_start(c, useinit, inargs);
+
+out:
+	if (inargs) {
+		int i;
+		for (i = 0; i < n_inargs; i++) {
+			if (inargs[i])
+				free(inargs[i]);
+		}
+		free(inargs);
+	}
+
+	return bret;
+}
+
+static bool lxcapi_stop(struct lxc_container *c)
+{
+	int ret;
+
+	if (!c)
+		return false;
+
+	ret = lxc_stop(c->name);
+
+	return ret == 0;
+}
+
+static bool lxcapi_wait(struct lxc_container *c, char *state, int timeout)
+{
+	int ret;
+
+	if (!c)
+		return false;
+
+	ret = lxc_wait(c->name, state, timeout);
+	return ret == 0;
+}
+
+static bool valid_template(char *t)
+{
+	struct stat statbuf;
+	int statret;
+
+	statret = stat(t, &statbuf);
+	if (statret == 0)
+		return true;
+	return false;
+}
+
+/*
+ * create the standard expected container dir
+ */
+static bool create_container_dir(struct lxc_container *c)
+{
+	char *s;
+	int len, ret;
+
+	len = strlen(LXCPATH) + strlen(c->name) + 2;
+	s = malloc(len);
+	if (!s)
+		return false;
+	ret = snprintf(s, len, "%s/%s", LXCPATH, c->name);
+	if (ret < 0 || ret >= len) {
+		free(s);
+		return false;
+	}
+	ret = mkdir(s, 0755);
+	if (ret) {
+		if (errno == EEXIST)
+			ret = 0;
+		else
+			SYSERROR("failed to create container path for %s\n", c->name);
+	}
+	free(s);
+	return ret == 0;
+}
+
+/*
+ * backing stores not (yet) supported
+ * for ->create, argv contains the arguments to pass to the template,
+ * terminated by NULL.  If no arguments, you can just pass NULL.
+ */
+static bool lxcapi_create(struct lxc_container *c, char *t, char **argv)
+{
+	bool bret = false;
+	pid_t pid;
+	int ret, status;
+	char *tpath = NULL;
+	int len, nargs = 0;
+	char **newargv;
+
+	if (!c)
+		return false;
+
+	len = strlen(LXCTEMPLATEDIR) + strlen(t) + strlen("/lxc-") + 1;
+	tpath = malloc(len);
+	if (!tpath)
+		return false;
+	ret = snprintf(tpath, len, "%s/lxc-%s", LXCTEMPLATEDIR, t);
+	if (ret < 0 || ret >= len)
+		goto out;
+	if (!valid_template(tpath)) {
+		ERROR("bad template: %s\n", t);
+		goto out;
+	}
+
+	if (!create_container_dir(c))
+		goto out;
+
+	if (!c->save_config(c, NULL)) {
+		ERROR("failed to save starting configuration for %s\n", c->name);
+		goto out;
+	}
+
+	/* we're going to fork.  but since we'll wait for our child, we
+	   don't need to lxc_container_get */
+
+	if (lxclock(c->slock, 0)) {
+		ERROR("failed to grab global container lock for %s\n", c->name);
+		goto out;
+	}
+
+	pid = fork();
+	if (pid < 0) {
+		SYSERROR("failed to fork task for container creation template\n");
+		goto out_unlock;
+	}
+
+	if (pid == 0) { // child
+		char *patharg, *namearg;
+		int i;
+
+		close(0);
+		close(1);
+		close(2);
+		open("/dev/null", O_RDONLY);
+		open("/dev/null", O_RDWR);
+		open("/dev/null", O_RDWR);
+
+		/*
+		 * create our new array, pre-pend the template name and
+		 * base args
+		 */
+		if (argv)
+			for (; argv[nargs]; nargs++) ;
+		nargs += 3;  // template, path and name args
+		newargv = malloc(nargs * sizeof(*newargv));
+		if (!newargv)
+			exit(1);
+		newargv[0] = t;
+
+		len = strlen(LXCPATH) + strlen(c->name) + strlen("--path=") + 2;
+		patharg = malloc(len);
+		if (!patharg)
+			exit(1);
+		ret = snprintf(patharg, len, "--path=%s/%s", LXCPATH, c->name);
+		if (ret < 0 || ret >= len)
+			exit(1);
+		newargv[1] = patharg;
+		len = strlen("--name=") + strlen(c->name) + 1;
+		namearg = malloc(len);
+		if (!namearg)
+			exit(1);
+		ret = snprintf(namearg, len, "--name=%s", c->name);
+		if (ret < 0 || ret >= len)
+			exit(1);
+		newargv[2] = namearg;
+
+		/* add passed-in args */
+		if (argv)
+			for (i = 3; i < nargs; i++)
+				newargv[i] = argv[i-3];
+
+		/* add trailing NULL */
+		nargs++;
+		newargv = realloc(newargv, nargs * sizeof(*newargv));
+		if (!newargv)
+			exit(1);
+		newargv[nargs - 1] = NULL;
+
+		/* execute */
+		ret = execv(tpath, newargv);
+		SYSERROR("failed to execute template %s", tpath);
+		exit(1);
+	}
+
+again:
+	ret = waitpid(pid, &status, 0);
+	if (ret == -1) {
+		if (errno == -EINTR)
+			goto again;
+		SYSERROR("waitpid failed");
+		goto out_unlock;
+	}
+	if (ret != pid)
+		goto again;
+	if (!WIFEXITED(status))  { // did not exit normally
+		// we could set an error code and string inside the
+		// container_struct here if we like
+		ERROR("container creation template exited abnormally\n");
+		goto out_unlock;
+	}
+
+	if (WEXITSTATUS(status) != 0)
+		ERROR("container creation template for %s exited with %d\n",
+		      c->name, WEXITSTATUS(status));
+	else
+		bret = true;
+
+out_unlock:
+	lxcunlock(c->slock);
+out:
+	if (tpath)
+		free(tpath);
+	return bret;
+}
+
+static bool lxcapi_shutdown(struct lxc_container *c, int timeout)
+{
+	bool retv;
+	pid_t pid;
+
+	if (!c)
+		return false;
+
+	if (!timeout)
+		timeout = -1;
+	if (!c->is_running(c))
+		return true;
+	pid = c->init_pid(c);
+	if (pid <= 0)
+		return true;
+	kill(pid, SIGPWR);
+	retv = c->wait(c, "STOPPED", timeout);
+	if (timeout > 0) {
+		c->stop(c);
+		retv = c->wait(c, "STOPPED", 0); // 0 means don't wait
+	}
+	return retv;
+}
+
+static bool lxcapi_createl(struct lxc_container *c, char *t, ...)
+{
+	bool bret = false;
+	char **args = NULL, **temp;
+	va_list ap;
+	int nargs = 0;
+
+	if (!c)
+		return false;
+
+	/*
+	 * since we're going to wait for create to finish, I don't think we
+	 * need to get a copy of the arguments.
+	 */
+	va_start(ap, t);
+	while (1) {
+		char *arg;
+		arg = va_arg(ap, char *);
+		if (!arg)
+			break;
+		nargs++;
+		temp = realloc(args, nargs * sizeof(*args));
+		if (!temp)
+			goto out;
+		args = temp;
+		args[nargs - 1] = arg;
+	}
+	va_end(ap);
+
+	bret = c->create(c, t, args);
+
+out:
+	if (args)
+		free(args);
+	return bret;
+}
+
+static bool lxcapi_clear_config_item(struct lxc_container *c, char *key)
+{
+	int ret;
+
+	if (!c || !c->lxc_conf)
+		return false;
+	if (lxclock(c->privlock, 0)) {
+		return false;
+	}
+	ret = lxc_clear_config_item(c->lxc_conf, key);
+	lxcunlock(c->privlock);
+	return ret == 0;
+}
+
+static int lxcapi_get_config_item(struct lxc_container *c, char *key, char *retv, int inlen)
+{
+	int ret;
+
+	if (!c || !c->lxc_conf)
+		return -1;
+	if (lxclock(c->privlock, 0)) {
+		return -1;
+	}
+	ret = lxc_get_config_item(c->lxc_conf, key, retv, inlen);
+	lxcunlock(c->privlock);
+	return ret;
+}
+
+static int lxcapi_get_keys(struct lxc_container *c, char *key, char *retv, int inlen)
+{
+	if (!key)
+		return lxc_listconfigs(retv, inlen);
+	/*
+	 * Support 'lxc.network.<idx>', i.e. 'lxc.network.0'
+	 * This is an intelligent result to show which keys are valid given
+	 * the type of nic it is
+	 */
+	if (!c || !c->lxc_conf)
+		return -1;
+	if (lxclock(c->privlock, 0))
+		return -1;
+	int ret = -1;
+	if (strncmp(key, "lxc.network.", 12) == 0)
+		ret =  lxc_list_nicconfigs(c->lxc_conf, key, retv, inlen);
+	lxcunlock(c->privlock);
+	return ret;
+}
+
+
+/* default config file - should probably come through autoconf */
+#define LXC_DEFAULT_CONFIG "/etc/lxc/lxc.conf"
+static bool lxcapi_save_config(struct lxc_container *c, char *alt_file)
+{
+	if (!alt_file)
+		alt_file = c->configfile;
+	if (!alt_file)
+		return false;  // should we write to stdout if no file is specified?
+	if (!c->lxc_conf)
+		if (!c->load_config(c, LXC_DEFAULT_CONFIG)) {
+			ERROR("Error loading default configuration file %s while saving %s\n", LXC_DEFAULT_CONFIG, c->name);
+			return false;
+		}
+
+	FILE *fout = fopen(alt_file, "w");
+	if (!fout)
+		return false;
+	if (lxclock(c->privlock, 0)) {
+		fclose(fout);
+		return false;
+	}
+	write_config(fout, c->lxc_conf);
+	fclose(fout);
+	lxcunlock(c->privlock);
+	return true;
+}
+
+static bool lxcapi_destroy(struct lxc_container *c)
+{
+	pid_t pid;
+	int ret, status;
+
+	if (!c)
+		return false;
+
+	pid = fork();
+	if (pid < 0)
+		return false;
+	if (pid == 0) { // child
+		ret = execlp("lxc-destroy", "lxc-destroy", "-n", c->name, NULL);
+		perror("execl");
+		exit(1);
+	}
+
+again:
+	ret = waitpid(pid, &status, 0);
+	if (ret == -1) {
+		if (errno == -EINTR)
+			goto again;
+		perror("waitpid");
+		return false;
+	}
+	if (ret != pid)
+		goto again;
+	if (!WIFEXITED(status))  { // did not exit normally
+		// we could set an error code and string inside the
+		// container_struct here if we like
+		return false;
+	}
+
+	return WEXITSTATUS(status) == 0;
+}
+
+static bool lxcapi_set_config_item(struct lxc_container *c, char *key, char *v)
+{
+	int ret;
+	bool b = false;
+	struct lxc_config_t *config;
+
+	if (!c)
+		return false;
+
+	if (lxclock(c->privlock, 0))
+		return false;
+
+	if (!c->lxc_conf)
+		c->lxc_conf = lxc_conf_init();
+	if (!c->lxc_conf)
+		goto err;
+	config = lxc_getconfig(key);
+	if (!config)
+		goto err;
+	ret = config->cb(key, v, c->lxc_conf);
+	if (!ret)
+		b = true;
+
+err:
+	lxcunlock(c->privlock);
+	return b;
+}
+
+static char *lxcapi_config_file_name(struct lxc_container *c)
+{
+	if (!c || !c->configfile)
+		return NULL;
+	return strdup(c->configfile);
+}
+
+struct lxc_container *lxc_container_new(char *name)
+{
+	struct lxc_container *c;
+	int ret, len;
+
+	c = malloc(sizeof(*c));
+	if (!c) {
+		fprintf(stderr, "failed to malloc lxc_container\n");
+		return NULL;
+	}
+	memset(c, 0, sizeof(*c));
+
+	c->name = malloc(strlen(name)+1);
+	if (!c->name) {
+		fprintf(stderr, "Error allocating lxc_container name\n");
+		goto err;
+	}
+	strcpy(c->name, name);
+
+	c->numthreads = 1;
+	c->slock = lxc_newlock(name);
+	if (!c->slock) {
+		fprintf(stderr, "failed to create lock\n");
+		goto err;
+	}
+
+	c->privlock = lxc_newlock(NULL);
+	if (!c->privlock) {
+		fprintf(stderr, "failed to alloc privlock\n");
+		goto err;
+	}
+
+	len = strlen(LXCDIR)+strlen(c->name)+strlen("/config")+2;
+	c->configfile = malloc(len);
+	if (!c->configfile) {
+		fprintf(stderr, "Error allocating config file pathname\n");
+		goto err;
+	}
+	ret = snprintf(c->configfile, len, "%s/%s/config", LXCDIR, c->name);
+	if (ret < 0 || ret >= len) {
+		fprintf(stderr, "Error printing out config file name\n");
+		goto err;
+	}
+
+	if (file_exists(c->configfile))
+		lxcapi_load_config(c, NULL);
+
+	// assign the member functions
+	c->is_defined = lxcapi_is_defined;
+	c->state = lxcapi_state;
+	c->is_running = lxcapi_is_running;
+	c->freeze = lxcapi_freeze;
+	c->unfreeze = lxcapi_unfreeze;
+	c->init_pid = lxcapi_init_pid;
+	c->load_config = lxcapi_load_config;
+	c->want_daemonize = lxcapi_want_daemonize;
+	c->start = lxcapi_start;
+	c->startl = lxcapi_startl;
+	c->stop = lxcapi_stop;
+	c->config_file_name = lxcapi_config_file_name;
+	c->wait = lxcapi_wait;
+	c->set_config_item = lxcapi_set_config_item;
+	c->destroy = lxcapi_destroy;
+	c->save_config = lxcapi_save_config;
+	c->get_keys = lxcapi_get_keys;
+	c->create = lxcapi_create;
+	c->createl = lxcapi_createl;
+	c->shutdown = lxcapi_shutdown;
+	c->clear_config_item = lxcapi_clear_config_item;
+	c->get_config_item = lxcapi_get_config_item;
+
+	/* we'll allow the caller to update these later */
+	if (lxc_log_init("/var/log/lxccontainer.log", "trace", "lxc_container", 0)) {
+		fprintf(stderr, "failed to open log\n");
+		goto err;
+	}
+
+	/*
+	 * default configuration file is $LXCDIR/$NAME/config
+	 */
+
+	return c;
+
+err:
+	lxc_container_free(c);
+	return NULL;
+}
+
+int lxc_get_wait_states(char **states)
+{
+	int i;
+
+	if (states)
+		for (i=0; i<MAX_STATE; i++)
+			states[i] = lxc_state2str(i);
+	return MAX_STATE;
+}
